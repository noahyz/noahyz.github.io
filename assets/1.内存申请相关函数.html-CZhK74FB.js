import{_ as n}from"./plugin-vue_export-helper-DlAUqK2U.js";import{c as s,a as e,o as i}from"./app-D1zlwylF.js";const p={};function l(t,a){return i(),s("div",null,a[0]||(a[0]=[e(`<p>操作系统提供了相关的系统调用来完成相关工作。</p><p>对heap的操作，操作系统提供了brk()函数，C运行时库提供了sbrk()函数。</p><p>对mmap映射区域的操作，操作系统提供了mmap()和munmap()函数。</p><p>这里要提到一个很重要的概念，内存的延迟分配，只有在真正访问一个地址的时候才建立这个地址的物理映射，这是 Linux 内存管理的基本思想之一。Linux 内核在用户申请内存的时候，只是给它分配了一个线性区（也就是虚拟内存），并没有分配实际物理内存；只有当用户使用这块内存的时候，内核才会分配具体的物理页面给用户，这时候才占用宝贵的物理内存。内核释放物理页面是通过释放线性区，找到其所对应的物理页面，将其全部释放的过程。</p><h3 id="一、heap-操作相关函数" tabindex="-1"><a class="header-anchor" href="#一、heap-操作相关函数"><span>一、heap 操作相关函数</span></a></h3><p>Heap 操作函数主要有两个，<code>brk()</code> 为系统调用，<code>sbrk()</code> 为 C 库函数。系统调用通常提供一种最小功能，而库函数通常提供比较复杂的功能。Glibc 的 malloc 函数族（realloc，calloc等）就调用 sbrk() 函数将数据段的下界移动，sbrk() 函数在内核的管理下将虚拟地址空间映射到内存，供 malloc() 函数使用。</p><p>内核数据结构 mm_struct 中的成员变量 start_code 和 end_code 是进程代码段的起始和终止地址，start_data 和 end_data是进程数据段的起始和终止地址，start_stack是进程堆栈段起始地址，start_brk是进程动态内存分配起始地址（堆的起始地址），还有一个 brk（堆的当前最后地址），就是动态内存分配当前的终止地址。C语言的动态内存分配基本函数是 <code>malloc()</code>，在 Linux 上的实现是通过内核的 brk 系统调用。<code>brk()</code> 是一个非常简单的系统调用，只是简单地改变 <code>mm_struct</code> 结构的成员变量brk的值。</p><div class="language- line-numbers-mode" data-highlighter="shiki" data-ext="" data-title="" style="--shiki-light:#24292e;--shiki-dark:#abb2bf;--shiki-light-bg:#fff;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes github-light one-dark-pro vp-code"><code><span class="line"><span>#include &lt;unistd.h&gt;</span></span>
<span class="line"><span>int brk(void *addr);</span></span>
<span class="line"><span>void *sbrk(intptr_t increment);</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>需要说明的是，但 <code>sbrk()</code> 的参数 <code>increment</code> 为 0 时，<code>sbrk()</code> 返回的是进程的当前 brk 值，increment 为正数时扩展 brk 值，当increment 为负值时收缩 brk 值。</p><h3 id="二、mmap-映射区域操作相关函数" tabindex="-1"><a class="header-anchor" href="#二、mmap-映射区域操作相关函数"><span>二、mmap 映射区域操作相关函数</span></a></h3><p>mmap() 函数将一个文件或者其它对象映射进内存。文件被映射到多个页上，如果文件的大小不是所有页的大小之和，最后一个页不被使用的空间将会清零。munmap 执行相反的操作，删除特定地址区域的对象映射。</p><div class="language- line-numbers-mode" data-highlighter="shiki" data-ext="" data-title="" style="--shiki-light:#24292e;--shiki-dark:#abb2bf;--shiki-light-bg:#fff;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes github-light one-dark-pro vp-code"><code><span class="line"><span>#include &lt;sys/mman.h&gt;</span></span>
<span class="line"><span>void *mmap(void *addr, size_t length, int prot, int flags, int fd, off_t offset);</span></span>
<span class="line"><span>int munmap(void *addr, size_t length);</span></span>
<span class="line"><span></span></span>
<span class="line"><span>start：映射区的开始地址。</span></span>
<span class="line"><span>length：映射区的长度。</span></span>
<span class="line"><span></span></span>
<span class="line"><span>prot：期望的内存保护标志，不能与文件的打开模式冲突。是以下的某个值，可以通过or运算合理地组合在一起。</span></span>
<span class="line"><span>  Ptmalloc 中主要使用了如下的几个标志： </span></span>
<span class="line"><span>      PROT_EXEC //页内容可以被执行，ptmalloc中没有使用 </span></span>
<span class="line"><span>      PROT_READ //页内容可以被读取，ptmalloc直接用mmap分配内存并立即返回给用户时设置该标志 </span></span>
<span class="line"><span>      PROT_WRITE //页可以被写入，ptmalloc直接用mmap分配内存并立即返回给用户时设置该标志 </span></span>
<span class="line"><span>      PROT_NONE //页不可访问，ptmalloc用mmap向系统“批发”一块内存进行管理时设置该标志 </span></span>
<span class="line"><span></span></span>
<span class="line"><span>flags：指定映射对象的类型，映射选项和映射页是否可以共享。它的值可以是一个或者多个以下位的组合体 </span></span>
<span class="line"><span>    MAP_FIXED //使用指定的映射起始地址，如果由start和len参数指定的内存区重叠于现存的映射空间，重叠部分将会被丢弃。如果指定的起始地址不可用，操作将会失败。并且起始地址必须落在页的边界上。Ptmalloc在回收从系统中“批发”的内存时设置该标志。 </span></span>
<span class="line"><span>    MAP_PRIVATE //建立一个写入时拷贝的私有映射。内存区域的写入不会影响到原文件。这个标志和以上标志是互斥的，只能使用其中一个。Ptmalloc每次调用mmap都设置该标志。 </span></span>
<span class="line"><span>    MAP_NORESERVE //不要为这个映射保留交换空间。当交换空间被保留，对映射区修改的可能会得到保证。当交换空间不被保留，同时内存不足，对映射区的修改会引起段违例信号。Ptmalloc向系统“批发”内存块时设置该标志。 </span></span>
<span class="line"><span>    MAP_ANONYMOUS //匿名映射，映射区不与任何文件关联。Ptmalloc每次调用mmap都设置该标志。</span></span>
<span class="line"><span>    </span></span>
<span class="line"><span>fd：有效的文件描述词。如果MAP_ANONYMOUS被设定，为了兼容问题，其值应为-1。 </span></span>
<span class="line"><span>offset：被映射对象内容的起点。</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div>`,12)]))}const d=n(p,[["render",l],["__file","1.内存申请相关函数.html.vue"]]),m=JSON.parse('{"path":"/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/%E7%BC%96%E7%A8%8B%E8%B0%83%E8%AF%95/1.%E5%86%85%E5%AD%98%E7%94%B3%E8%AF%B7%E7%9B%B8%E5%85%B3%E5%87%BD%E6%95%B0.html","title":"1.内存申请相关函数","lang":"zh-CN","frontmatter":{"title":"1.内存申请相关函数","description":"操作系统提供了相关的系统调用来完成相关工作。 对heap的操作，操作系统提供了brk()函数，C运行时库提供了sbrk()函数。 对mmap映射区域的操作，操作系统提供了mmap()和munmap()函数。 这里要提到一个很重要的概念，内存的延迟分配，只有在真正访问一个地址的时候才建立这个地址的物理映射，这是 Linux 内存管理的基本思想之一。Lin...","head":[["meta",{"property":"og:url","content":"https://noahyz.github.io/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/%E7%BC%96%E7%A8%8B%E8%B0%83%E8%AF%95/1.%E5%86%85%E5%AD%98%E7%94%B3%E8%AF%B7%E7%9B%B8%E5%85%B3%E5%87%BD%E6%95%B0.html"}],["meta",{"property":"og:site_name","content":"noahyz的博客"}],["meta",{"property":"og:title","content":"1.内存申请相关函数"}],["meta",{"property":"og:description","content":"操作系统提供了相关的系统调用来完成相关工作。 对heap的操作，操作系统提供了brk()函数，C运行时库提供了sbrk()函数。 对mmap映射区域的操作，操作系统提供了mmap()和munmap()函数。 这里要提到一个很重要的概念，内存的延迟分配，只有在真正访问一个地址的时候才建立这个地址的物理映射，这是 Linux 内存管理的基本思想之一。Lin..."}],["meta",{"property":"og:type","content":"article"}],["meta",{"property":"og:locale","content":"zh-CN"}],["meta",{"property":"article:author","content":"noahyz"}],["script",{"type":"application/ld+json"},"{\\"@context\\":\\"https://schema.org\\",\\"@type\\":\\"Article\\",\\"headline\\":\\"1.内存申请相关函数\\",\\"image\\":[\\"\\"],\\"dateModified\\":null,\\"author\\":[{\\"@type\\":\\"Person\\",\\"name\\":\\"noahyz\\",\\"url\\":\\"/about-the-author/\\"}]}"]]},"headers":[{"level":3,"title":"一、heap 操作相关函数","slug":"一、heap-操作相关函数","link":"#一、heap-操作相关函数","children":[]},{"level":3,"title":"二、mmap 映射区域操作相关函数","slug":"二、mmap-映射区域操作相关函数","link":"#二、mmap-映射区域操作相关函数","children":[]}],"git":{},"readingTime":{"minutes":4.17,"words":1250},"filePathRelative":"操作系统/内存管理/编程调试/1.内存申请相关函数.md","excerpt":"<p>操作系统提供了相关的系统调用来完成相关工作。</p>\\n<p>对heap的操作，操作系统提供了brk()函数，C运行时库提供了sbrk()函数。</p>\\n<p>对mmap映射区域的操作，操作系统提供了mmap()和munmap()函数。</p>\\n<p>这里要提到一个很重要的概念，内存的延迟分配，只有在真正访问一个地址的时候才建立这个地址的物理映射，这是 Linux 内存管理的基本思想之一。Linux 内核在用户申请内存的时候，只是给它分配了一个线性区（也就是虚拟内存），并没有分配实际物理内存；只有当用户使用这块内存的时候，内核才会分配具体的物理页面给用户，这时候才占用宝贵的物理内存。内核释放物理页面是通过释放线性区，找到其所对应的物理页面，将其全部释放的过程。</p>","autoDesc":true}');export{d as comp,m as data};

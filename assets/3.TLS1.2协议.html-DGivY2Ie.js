import{_ as i}from"./plugin-vue_export-helper-DlAUqK2U.js";import{c as a,a as s,o as n}from"./app-D1zlwylF.js";const l="/assets/TLS%E6%8F%A1%E6%89%8B%E8%BF%87%E7%A8%8B-gnmLCiCW.png",r="/assets/ECDHE%E6%8F%A1%E6%89%8B%E8%BF%87%E7%A8%8B-DOzJDEoH.png",t="/assets/RSA%E6%8F%A1%E6%89%8B%E8%BF%87%E7%A8%8B-Bjkq2Ap-.png",p={};function d(c,e){return n(),a("div",null,e[0]||(e[0]=[s('<h2 id="tls-1-2-协议" tabindex="-1"><a class="header-anchor" href="#tls-1-2-协议"><span>TLS 1.2 协议</span></a></h2><p>TLS 包含几个子协议，由几个不同职责的模块组成，比较常见的有记录协议、警报协议、握手协议、变更密码规范协议等</p><ul><li>记录协议：规定了 TLS 收发数据的基本单位：记录（record）。它有点像是 TCP 里的 segment，所有的其他子协议都需要通过记录协议发出。但多个记录数据可以在一个 TCP 包里一次性发出，也并不需要像 TCP 那样返回 ACK。</li><li>警报协议：职责是向对方发出警报信息，有点像是 HTTP 协议里的状态码。比如，protocol_version 就是不支持旧版本，bad_certificate 就是证书有问题，收到警报后另一方可以选择继续，也可以立即终止连接。</li><li>握手协议：TLS 里最复杂的子协议，要比 TCP 的 SYN/ACK 复杂的多，浏览器和服务器会在握手过程中协商 TLS 版本号、随机数、密码套件等信息，然后交换证书和密钥参数，最终双方协商得到会话密钥，用于后续的混合加密系统。</li><li>变更密码规范协议：非常简单，就是一个“通知”（Change Cipher Spec），告诉对方，后续的数据都将使用加密保护。那么反过来，在它之前，数据都是明文的。如下图的 ChangeCipherSpec 出现后，后面的数据就是密文了。</li></ul><img src="'+l+'" style="zoom:33%;"><p>如图，其中每个框都是一个记录，多个记录组合成一个 TCP 包发送。所以，最多经过两次消息往返（4个消息）就可以完成握手，然后就可以在安全的通信环境里发送 HTTP 报文，实现 HTTPS 协议。</p><h3 id="二、非对称加密-ecdhe-握手过程" tabindex="-1"><a class="header-anchor" href="#二、非对称加密-ecdhe-握手过程"><span>二、非对称加密 ECDHE 握手过程</span></a></h3><p>ECDHE（ephemeral Elliptic Curve Diffie-Hellman）即短暂-椭圆曲线-迪菲-赫尔曼算法，使用椭圆曲线增强了 DH 算法的安全性和性能，公钥和私钥都是临时生成的。</p><img src="'+r+`" style="zoom:50%;"><ol><li><p>在 TCP 建立连接之后，浏览器会首先发一个“Client Hello”消息，里面有客户端的 TLS 版本号、支持的密码套件、随机数（Client Random），用于后续生成会话密钥。</p><div class="language- line-numbers-mode" data-highlighter="shiki" data-ext="" data-title="" style="--shiki-light:#24292e;--shiki-dark:#abb2bf;--shiki-light-bg:#fff;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes github-light one-dark-pro vp-code"><code><span class="line"><span>Handshake Protocol: Client Hello</span></span>
<span class="line"><span>    Version: TLS 1.2 (0x0303)</span></span>
<span class="line"><span>    Random: 1cbf803321fd2623408dfe…</span></span>
<span class="line"><span>    Cipher Suites (17 suites)</span></span>
<span class="line"><span>        Cipher Suite: TLS_ECDHE_RSA_WITH_AES_128_GCM_SHA256 (0xc02f)</span></span>
<span class="line"><span>        Cipher Suite: TLS_ECDHE_RSA_WITH_AES_256_GCM_SHA384 (0xc030)</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div></li><li><p>服务器收到“Client hello”后，会返回一个“Server Hello”消息。把版本号对一下，也给出一个随机数（Server Random），然后从客户端的列表里选一个作为本次通信使用的密码套件，如下，本次选择“TLS_ECDHE_RSA_WITH_AES_256_GCM_SHA384”</p><div class="language- line-numbers-mode" data-highlighter="shiki" data-ext="" data-title="" style="--shiki-light:#24292e;--shiki-dark:#abb2bf;--shiki-light-bg:#fff;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes github-light one-dark-pro vp-code"><code><span class="line"><span>Handshake Protocol: Server Hello</span></span>
<span class="line"><span>    Version: TLS 1.2 (0x0303)</span></span>
<span class="line"><span>    Random: 0e6320f21bae50842e96…</span></span>
<span class="line"><span>    Cipher Suite: TLS_ECDHE_RSA_WITH_AES_256_GCM_SHA384 (0xc030)</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>选择的 TLS 密码套件 Cipher Suite 意思为：握手时使用非对称加密 ECDHE 算法进行密钥交换，用 RSA 签名和身份认证，握手后的通信使用 AES 对称算法，密钥长度 256 位，分组模式是 GCM，摘要算法 SHA384 用于消息认证和产生随机数</p></li><li><p>服务端为了证明自己的身份，把证书发给了客户端</p></li><li><p>因为服务器选择了 ECDHE 算法，所以服务端会在发送证书后发送“Server Key Exchange”消息，里面是椭圆曲线的公钥（Server Params），用来实现密钥交换算法，再加上自己的私钥签名认证（原文内容的摘要，用私钥非对成加密，生成签名。方便对端用公钥解密签名内容，验证内容是否被篡改、是否是目标服务器）。</p><div class="language- line-numbers-mode" data-highlighter="shiki" data-ext="" data-title="" style="--shiki-light:#24292e;--shiki-dark:#abb2bf;--shiki-light-bg:#fff;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes github-light one-dark-pro vp-code"><code><span class="line"><span>Handshake Protocol: Server Key Exchange</span></span>
<span class="line"><span>    EC Diffie-Hellman Server Params</span></span>
<span class="line"><span>        Curve Type: named_curve (0x03)</span></span>
<span class="line"><span>        Named Curve: x25519 (0x001d)</span></span>
<span class="line"><span>        Pubkey: 3b39deaf00217894e...</span></span>
<span class="line"><span>        Signature Algorithm: rsa_pkcs1_sha512 (0x0601)</span></span>
<span class="line"><span>        Signature: 37141adac38ea4...</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div></li><li><p>发送“Server Hello Done”消息，意味着服务端的信息发送完了。这样第一个消息往返就结束了（两个TCP包），结果是客户端和服务端通过明文共享了三个信息：Client Random、Server Random 和 Server Params</p></li><li><p>客户端拿到服务器的证书，需要验证这个证书是否真实有效。开始走证书链逐级验证，确认证书的真实性，在用证书公钥验证签名，就确认了服务器的身份。</p></li><li><p>客户端按照密码套件的要求，也生成了一个椭圆曲线的公钥（Client Params），用“Client Key Exchange”消息发给服务器。</p><div class="language- line-numbers-mode" data-highlighter="shiki" data-ext="" data-title="" style="--shiki-light:#24292e;--shiki-dark:#abb2bf;--shiki-light-bg:#fff;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes github-light one-dark-pro vp-code"><code><span class="line"><span>Handshake Protocol: Client Key Exchange</span></span>
<span class="line"><span>    EC Diffie-Hellman Client Params</span></span>
<span class="line"><span>        Pubkey: 8c674d0e08dc27b5eaa…</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>现在客户端和服务器手里都拿到了密钥交换算法的两个参数（Client Params、Server Params），然后使用 ECDHE 算法算出随机数 “Pre-Master”，然后用 Client Random、Server Random 和 Pre-Master 三个值作为原材料，用 PRF 伪随机数函数计算出主密钥 Master Secret。</p><div class="language- line-numbers-mode" data-highlighter="shiki" data-ext="" data-title="" style="--shiki-light:#24292e;--shiki-dark:#abb2bf;--shiki-light-bg:#fff;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes github-light one-dark-pro vp-code"><code><span class="line"><span>master_secret = PRF(pre_master_secret, ClientHello.random,  ServerHello.random)</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div></div></div><p>为什么黑客及时劫持了Client Params、Server Params，也不能算出 Pre-Master ？看看 ECDHE的握手过程</p><ul><li><p>客户端在内存中再生成一个随机值 Ra，计算 <code>Pa(x, y) = Ra * Q(x,y) </code>其中 Q(x, y) 是全世界公认的某个椭圆曲线算法的基点。将 Pa(x, y) 发送至服务器。其实 Pa(x, y) 就是 Client Params 里的 Pubkey。</p></li><li><p>服务端在内存中再生成一个随机值 Rb，计算 <code>Pb(x, y) = Rb * Q(x,y)</code> 。将 Pb(x, y) 发送给客户端。其实 Pb(x, y) 就是 Server Params 的 Pubkey。</p></li><li><p>客户端计算 <code>Sa(x, y) = Ra * Pb(x, y)</code> ；服务端计算 <code>Sb(x, y) = Rb * Pa(x, y)</code></p></li><li><p>算法保证了 Sa = Sb = S，数学上可以证明二者相等，有点类似乘法交换律。提取其中的 S 的 x 向量作为密钥（预主密钥）。</p></li><li><p>所以会话结束后，相关内存被释放，Pre-Master 被释放，Ra 和 Rb 也被释放，就再也不能重复算出 Master-Secret。这也是 ECDHE 中 E 的由来，E 的意思是 ephemeral 短暂的。同时黑客也拿不到 Pre-Master，所以也就得不到主密钥。</p></li><li><p>需要注意的是，Server Params 中的 pubkey 和证书中的公钥没有什么关系。在 ECDHE 里，证书里的公钥的功能退化为身份验证，只是用来证明这些请求确实来自服务器。这也是 ECDHE 比 RSA 更安全的原因，因为服务器的公钥不参与 Master-Secret 的过程，哪怕服务器的私钥在未来那一天被泄露了，也无法得知 Master-Secret，这就满足了前向安全。</p></li></ul><p>Master-Secret 有 48 字节，还会使用 PRF 扩展出更多的密钥，比如客户端发送用的会话密钥（client_write_key）、服务器发送用的会话密钥（server_write_key）等等，避免只用一个密钥带来的安全隐患。这个 Master-Secret 做为对称加密算法的密钥了。</p></li><li><p>有了主密钥和派生的会话密钥。客户端发送一个 “Change Cipher Spec”，然后再发一个“Finished”消息，把之前所有发送的数据做个摘要，在加密一下，让服务器做个验证。意为告诉服务器，后面该用对称加密算法通信了，用的是打招呼时说的 AES。</p></li><li><p>服务器也是同样操作，发送 &quot;Change Cipher Spec&quot; 和 “Finished” 消息，双方都验证加密解密 OK，握手正式结束，后面的收发被加密的 HTTP 请求和响应</p></li></ol><h3 id="三、非对称加密-rsa-握手过程" tabindex="-1"><a class="header-anchor" href="#三、非对称加密-rsa-握手过程"><span>三、非对称加密 RSA 握手过程</span></a></h3><img src="`+t+'" style="zoom:50%;"><p>大体流程没有变化，只是 Pre-Master 不再需要用算法生成，而是客户端直接生成随机数，然后用服务器的公钥加密，通过“Client key Exchange”消息发送给服务器。服务器再用私钥解密，这样双方也实现了共享三个随机数，就可以生成主密钥。</p><h3 id="四、双向认证" tabindex="-1"><a class="header-anchor" href="#四、双向认证"><span>四、双向认证</span></a></h3><p>上面是“单向认证”握手过程，只认证了服务器的身份，而没有认证客户端的身份。这是因为通常单向认证通过后已经建立了安全通信，用账号、密码等简单的手段就能够确认用户的真实身份。</p><p>但为了防止账号、密码被盗，有的时候（比如网上银行）还会使用 U 盾给用户颁发客户端证书，实现“双向认证”，这样会更安全。双向认证的流程也只是在“Server Hello Done”之后，“Client Key Exchange”之前，客户端要发送“Client Certificate”消息，服务器收到后也把证书链走一遍，验证客户端的身份。</p>',15)]))}const m=i(p,[["render",d],["__file","3.TLS1.2协议.html.vue"]]),E=JSON.parse('{"path":"/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E4%B8%83%E5%B1%82%E6%A8%A1%E5%9E%8B/%E5%BA%94%E7%94%A8%E5%B1%82/%E9%80%9A%E4%BF%A1%E5%AE%89%E5%85%A8/3.TLS1.2%E5%8D%8F%E8%AE%AE.html","title":"3.TLS1.2协议","lang":"zh-CN","frontmatter":{"title":"3.TLS1.2协议","date":"2023-01-19T11:11:41.000Z","tags":["linux"],"description":"TLS 1.2 协议 TLS 包含几个子协议，由几个不同职责的模块组成，比较常见的有记录协议、警报协议、握手协议、变更密码规范协议等 记录协议：规定了 TLS 收发数据的基本单位：记录（record）。它有点像是 TCP 里的 segment，所有的其他子协议都需要通过记录协议发出。但多个记录数据可以在一个 TCP 包里一次性发出，也并不需要像 TCP...","head":[["meta",{"property":"og:url","content":"https://noahyz.github.io/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E4%B8%83%E5%B1%82%E6%A8%A1%E5%9E%8B/%E5%BA%94%E7%94%A8%E5%B1%82/%E9%80%9A%E4%BF%A1%E5%AE%89%E5%85%A8/3.TLS1.2%E5%8D%8F%E8%AE%AE.html"}],["meta",{"property":"og:site_name","content":"noahyz的博客"}],["meta",{"property":"og:title","content":"3.TLS1.2协议"}],["meta",{"property":"og:description","content":"TLS 1.2 协议 TLS 包含几个子协议，由几个不同职责的模块组成，比较常见的有记录协议、警报协议、握手协议、变更密码规范协议等 记录协议：规定了 TLS 收发数据的基本单位：记录（record）。它有点像是 TCP 里的 segment，所有的其他子协议都需要通过记录协议发出。但多个记录数据可以在一个 TCP 包里一次性发出，也并不需要像 TCP..."}],["meta",{"property":"og:type","content":"article"}],["meta",{"property":"og:locale","content":"zh-CN"}],["meta",{"property":"article:author","content":"noahyz"}],["meta",{"property":"article:tag","content":"linux"}],["meta",{"property":"article:published_time","content":"2023-01-19T11:11:41.000Z"}],["script",{"type":"application/ld+json"},"{\\"@context\\":\\"https://schema.org\\",\\"@type\\":\\"Article\\",\\"headline\\":\\"3.TLS1.2协议\\",\\"image\\":[\\"\\"],\\"datePublished\\":\\"2023-01-19T11:11:41.000Z\\",\\"dateModified\\":null,\\"author\\":[{\\"@type\\":\\"Person\\",\\"name\\":\\"noahyz\\",\\"url\\":\\"/about-the-author/\\"}]}"]]},"headers":[{"level":2,"title":"TLS 1.2 协议","slug":"tls-1-2-协议","link":"#tls-1-2-协议","children":[{"level":3,"title":"二、非对称加密 ECDHE 握手过程","slug":"二、非对称加密-ecdhe-握手过程","link":"#二、非对称加密-ecdhe-握手过程","children":[]},{"level":3,"title":"三、非对称加密 RSA 握手过程","slug":"三、非对称加密-rsa-握手过程","link":"#三、非对称加密-rsa-握手过程","children":[]},{"level":3,"title":"四、双向认证","slug":"四、双向认证","link":"#四、双向认证","children":[]}]}],"git":{},"readingTime":{"minutes":7.08,"words":2125},"filePathRelative":"计算机网络/七层模型/应用层/通信安全/3.TLS1.2协议.md","localizedDate":"2023年1月19日","excerpt":"<h2>TLS 1.2 协议</h2>\\n<p>TLS 包含几个子协议，由几个不同职责的模块组成，比较常见的有记录协议、警报协议、握手协议、变更密码规范协议等</p>\\n<ul>\\n<li>记录协议：规定了 TLS 收发数据的基本单位：记录（record）。它有点像是 TCP 里的 segment，所有的其他子协议都需要通过记录协议发出。但多个记录数据可以在一个 TCP 包里一次性发出，也并不需要像 TCP 那样返回 ACK。</li>\\n<li>警报协议：职责是向对方发出警报信息，有点像是 HTTP 协议里的状态码。比如，protocol_version 就是不支持旧版本，bad_certificate 就是证书有问题，收到警报后另一方可以选择继续，也可以立即终止连接。</li>\\n<li>握手协议：TLS 里最复杂的子协议，要比 TCP 的 SYN/ACK 复杂的多，浏览器和服务器会在握手过程中协商 TLS 版本号、随机数、密码套件等信息，然后交换证书和密钥参数，最终双方协商得到会话密钥，用于后续的混合加密系统。</li>\\n<li>变更密码规范协议：非常简单，就是一个“通知”（Change Cipher Spec），告诉对方，后续的数据都将使用加密保护。那么反过来，在它之前，数据都是明文的。如下图的 ChangeCipherSpec 出现后，后面的数据就是密文了。</li>\\n</ul>","autoDesc":true}');export{m as comp,E as data};

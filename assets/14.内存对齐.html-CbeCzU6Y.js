import{_ as s}from"./plugin-vue_export-helper-DlAUqK2U.js";import{c as e,a as i,o as a}from"./app-D1zlwylF.js";const l={};function t(p,n){return a(),e("div",null,n[0]||(n[0]=[i(`<h2 id="内存对齐" tabindex="-1"><a class="header-anchor" href="#内存对齐"><span>内存对齐</span></a></h2><p>计算机对基本类型数据在内存中存放的位置有限制，会要求这些数据的首地址的值是某个数（通常它是 4 或 8 或 16）的倍数，这个就是内存对齐</p><h3 id="一、必要性" tabindex="-1"><a class="header-anchor" href="#一、必要性"><span>一、必要性</span></a></h3><p>假设一个 int 变量（32 位系统，4字节）存放在从地址 0x1 开始的连续 4 个字节地址中，处理器去读取数据时，得先从 0x0 地址开始读取第一个 4 字节块，剔除不想要的字节（0x0 地址），然后从地址 0x4 开始读取下一个 4 字节块，同样剔除不想要的数据（0x5、6、7 地址），最后留下的两块数据合并放入寄存器。这样的话，访问一个数据需要做很多工作。</p><p>在内存对齐的情况下，一个 int 变量（32 位系统，4字节），处理器可以一次性将它读出来，效率大大提高。这是性能原因</p><p>为什么需要内存对齐：</p><ul><li><strong>平台原因(移植原因)</strong>：不是所有的硬件平台都能访问任意地址上的任意数据的；某些硬件平台只能在某些地址处取某些特定类型的数据，否则抛出硬件异常</li><li><strong>性能原因</strong>：数据结构(尤其是栈)应该尽可能地在自然边界上对齐。原因在于，为了访问未对齐的内存，处理器需要作两次内存访问；而对齐的内存访问仅需要一次访问</li></ul><h3 id="二、内存对齐规则" tabindex="-1"><a class="header-anchor" href="#二、内存对齐规则"><span>二、内存对齐规则</span></a></h3><p>不同平台、不同编译器有不同的“对齐系数”。32位系统中 gcc 对齐数默认为：<code>#pragma pack(4)</code></p><p>内存对齐需要遵循的规则</p><ul><li>结构体第一个成员的偏移量（offset）为 0，以后每个成员相对于结构体首地址的 offset 都是该成员大小与有效对齐数中较小的那个整数倍，如有需要编译器会在成员之间加上填充字节。</li><li>结构体的总大小为（有效对齐数和结构体中最大数据成员对齐长度的较小值的整数倍），如有需要编译器会在最末一个成员之后加上填充字节</li></ul><div class="language- line-numbers-mode" data-highlighter="shiki" data-ext="" data-title="" style="--shiki-light:#24292e;--shiki-dark:#abb2bf;--shiki-light-bg:#fff;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes github-light one-dark-pro vp-code"><code><span class="line"><span>// 32 位系统，对齐数为 4</span></span>
<span class="line"><span>struct {</span></span>
<span class="line"><span>		char c1;</span></span>
<span class="line"><span>		int i;</span></span>
<span class="line"><span>		char c2;</span></span>
<span class="line"><span>} stu;</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>首先使用规则 1，对成员变量进行对齐：</p><ul><li><code>sizeof(c1) = 1 &lt;= 4</code>，按照 1 字节对齐，占用第 0 单元</li><li><code>sizeof(i) = 4 &lt;= 4</code>，相对于结构体首地址的偏移要为 4 的倍数，占用第 4、5、6、7 单元</li><li><code>sizeof(c2) = 1 &lt;= 4</code>，相对于结构体首地址的偏移要为 1 的倍数，占用第 8 单元</li></ul><p>然后使用规则 2，对结构体整体进行对齐：</p><ul><li>对齐数最大的元素是变量 i，占用 4 字节，有效对齐数也是 4 字节，因此按照对齐数为 4 字节。因此结构体总共占 9 个字节，按 4 字节对齐总共占用 12 字节。</li></ul><h3 id="三、技巧" tabindex="-1"><a class="header-anchor" href="#三、技巧"><span>三、技巧</span></a></h3><p>更改编译器的缺省字节对齐方式：</p><ul><li>使用 <code>#pragma pack(n)</code> ，编译器将按照 n 个字节对齐</li><li>使用 <code>#pragma pack()</code>，取消自定义字节对齐方式</li></ul><h3 id="四、位域" tabindex="-1"><a class="header-anchor" href="#四、位域"><span>四、位域</span></a></h3><p>结构体中某字段的希望占用一位或者几位。因此可以把多个字段用一个字节来表示，如下：</p><div class="language- line-numbers-mode" data-highlighter="shiki" data-ext="" data-title="" style="--shiki-light:#24292e;--shiki-dark:#abb2bf;--shiki-light-bg:#fff;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes github-light one-dark-pro vp-code"><code><span class="line"><span>struct {</span></span>
<span class="line"><span>		int a:8;</span></span>
<span class="line"><span>		int b:2;</span></span>
<span class="line"><span>		int c:6;</span></span>
<span class="line"><span>};</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>有几点需要注意事项：</p><ul><li><p>一个位域必须存储在同一个字节中，不能跨两个字节。如一个字节所剩空间不够存放另一位域时，应从下一单元起存放该位域。也可以有意使某位域从下一单元开始。</p><div class="language- line-numbers-mode" data-highlighter="shiki" data-ext="" data-title="" style="--shiki-light:#24292e;--shiki-dark:#abb2bf;--shiki-light-bg:#fff;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes github-light one-dark-pro vp-code"><code><span class="line"><span>struct {</span></span>
<span class="line"><span>		unsigned a:6;</span></span>
<span class="line"><span>		unsigned 0;  // 空域</span></span>
<span class="line"><span>		unsigned b:4;  // 从下一单元开始存放</span></span>
<span class="line"><span>		unsigned c:4;</span></span>
<span class="line"><span>}</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div></li><li><p>由于位域不允许跨 2 个字节，因此位域的长度不能大于一个字节的长度，也就是不能超过 8 位。</p></li><li><p>位域可以无位域名，只用来填充或调整位置。无名的位域是不能使用的。</p><div class="language- line-numbers-mode" data-highlighter="shiki" data-ext="" data-title="" style="--shiki-light:#24292e;--shiki-dark:#abb2bf;--shiki-light-bg:#fff;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes github-light one-dark-pro vp-code"><code><span class="line"><span>struct {</span></span>
<span class="line"><span>		int a:1;</span></span>
<span class="line"><span>		int :2;</span></span>
<span class="line"><span>		int b:3;</span></span>
<span class="line"><span>		int c:2;</span></span>
<span class="line"><span>}</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div></li></ul>`,24)]))}const c=s(l,[["render",t],["__file","14.内存对齐.html.vue"]]),h=JSON.parse('{"path":"/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/c__%E8%AF%AD%E8%A8%80/%E7%BC%96%E7%A0%81%E6%8A%80%E5%B7%A7/14.%E5%86%85%E5%AD%98%E5%AF%B9%E9%BD%90.html","title":"14.内存对齐","lang":"zh-CN","frontmatter":{"title":"14.内存对齐","date":"2023-01-19T11:11:41.000Z","tags":["linux"],"description":"内存对齐 计算机对基本类型数据在内存中存放的位置有限制，会要求这些数据的首地址的值是某个数（通常它是 4 或 8 或 16）的倍数，这个就是内存对齐 一、必要性 假设一个 int 变量（32 位系统，4字节）存放在从地址 0x1 开始的连续 4 个字节地址中，处理器去读取数据时，得先从 0x0 地址开始读取第一个 4 字节块，剔除不想要的字节（0x0 ...","head":[["meta",{"property":"og:url","content":"https://noahyz.github.io/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/c__%E8%AF%AD%E8%A8%80/%E7%BC%96%E7%A0%81%E6%8A%80%E5%B7%A7/14.%E5%86%85%E5%AD%98%E5%AF%B9%E9%BD%90.html"}],["meta",{"property":"og:site_name","content":"noahyz的博客"}],["meta",{"property":"og:title","content":"14.内存对齐"}],["meta",{"property":"og:description","content":"内存对齐 计算机对基本类型数据在内存中存放的位置有限制，会要求这些数据的首地址的值是某个数（通常它是 4 或 8 或 16）的倍数，这个就是内存对齐 一、必要性 假设一个 int 变量（32 位系统，4字节）存放在从地址 0x1 开始的连续 4 个字节地址中，处理器去读取数据时，得先从 0x0 地址开始读取第一个 4 字节块，剔除不想要的字节（0x0 ..."}],["meta",{"property":"og:type","content":"article"}],["meta",{"property":"og:locale","content":"zh-CN"}],["meta",{"property":"article:author","content":"noahyz"}],["meta",{"property":"article:tag","content":"linux"}],["meta",{"property":"article:published_time","content":"2023-01-19T11:11:41.000Z"}],["script",{"type":"application/ld+json"},"{\\"@context\\":\\"https://schema.org\\",\\"@type\\":\\"Article\\",\\"headline\\":\\"14.内存对齐\\",\\"image\\":[\\"\\"],\\"datePublished\\":\\"2023-01-19T11:11:41.000Z\\",\\"dateModified\\":null,\\"author\\":[{\\"@type\\":\\"Person\\",\\"name\\":\\"noahyz\\",\\"url\\":\\"/about-the-author/\\"}]}"]]},"headers":[{"level":2,"title":"内存对齐","slug":"内存对齐","link":"#内存对齐","children":[{"level":3,"title":"一、必要性","slug":"一、必要性","link":"#一、必要性","children":[]},{"level":3,"title":"二、内存对齐规则","slug":"二、内存对齐规则","link":"#二、内存对齐规则","children":[]},{"level":3,"title":"三、技巧","slug":"三、技巧","link":"#三、技巧","children":[]},{"level":3,"title":"四、位域","slug":"四、位域","link":"#四、位域","children":[]}]}],"git":{},"readingTime":{"minutes":3.52,"words":1056},"filePathRelative":"编程语言/c++语言/编码技巧/14.内存对齐.md","localizedDate":"2023年1月19日","excerpt":"<h2>内存对齐</h2>\\n<p>计算机对基本类型数据在内存中存放的位置有限制，会要求这些数据的首地址的值是某个数（通常它是 4 或 8 或 16）的倍数，这个就是内存对齐</p>\\n<h3>一、必要性</h3>\\n<p>假设一个 int 变量（32 位系统，4字节）存放在从地址 0x1 开始的连续 4 个字节地址中，处理器去读取数据时，得先从 0x0 地址开始读取第一个 4 字节块，剔除不想要的字节（0x0 地址），然后从地址 0x4 开始读取下一个 4 字节块，同样剔除不想要的数据（0x5、6、7 地址），最后留下的两块数据合并放入寄存器。这样的话，访问一个数据需要做很多工作。</p>\\n<p>在内存对齐的情况下，一个 int 变量（32 位系统，4字节），处理器可以一次性将它读出来，效率大大提高。这是性能原因</p>","autoDesc":true}');export{c as comp,h as data};

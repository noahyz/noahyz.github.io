import{_ as t}from"./plugin-vue_export-helper-DlAUqK2U.js";import{c as i,a as n,o as a}from"./app-D1zlwylF.js";const s="/assets/%E9%94%81%E7%AB%9E%E4%BA%89%E6%A1%86%E6%9E%B6-CFrnA_8V.png",l="/assets/%E7%BB%93%E6%9E%9C%E5%9B%BE-C-3HsJqq.png",p={};function r(o,e){return a(),i("div",null,e[0]||(e[0]=[n('<h3 id="一、概述" tabindex="-1"><a class="header-anchor" href="#一、概述"><span>一、概述</span></a></h3><p>当很多线程争抢同一把锁时，一些线程无法立刻获得锁，而必须睡眠直到某个线程退出临界区。这个争抢过程我们称之为<strong>contention</strong>。在多核机器上，当多个线程需要操作同一个资源却被一把锁挡住时，便无法充分发挥多个核心的并发能力。现代OS通过提供比锁更底层的同步原语，使得无竞争锁完全不需要系统调用，只是一两条 wait-free，耗时 <code>10-20ns</code> 的原子操作，非常快。而锁一旦发生竞争，一些线程就要陷入睡眠，再次醒来触发了OS的调度代码，代价至少为 <code>3-5us</code> 。所以让锁尽量无竞争，让所有线程“一起起飞”是高性能服务器的永恒话题。</p><p>我们当前的 profiler 工具，可以分析在等待锁上花费的时间。等待过程中线程是休眠状态，不会占用 CPU，所以 contention profiler 中的时间并不是 cpu 时间，也不会出现在 cpu profiler 中。cpu profiler 可以抓到特别频繁的锁，因为他花费了很多 CPU，但耗时真正巨大的临界区往往不是那么频繁，而无法被 cpu profiler 发现。</p><p>因此，cpu profiler 和 contention profiler 是一种互补关系，前者分析忙碌时间，后者分析被动的等待时间。还有一类是由用户基于 condition（条件）或 sleep 发起的主动等待时间，无需分析。</p><p>注意，无竞争的锁不会被采集，我们采集的是在锁上花费的所有等待时间。</p><p>目前我们支持 pthread_mutex_t 锁，开启后每秒默认最多采集 1000 个竞争锁。如果一秒内竞争锁的次数超过了 1000，那么每把锁会有 <code>1000/N</code> 的概率被采集。在各类测试场景中，暂没有发现被采集程序的性能有明显变化。</p><h3 id="二、框架解析" tabindex="-1"><a class="header-anchor" href="#二、框架解析"><span>二、框架解析</span></a></h3><figure><img src="'+s+`" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure><p>我们 hook 了 pthread_mutex_lock 和 pthread_mutex_unlock 加锁和解锁的调用。</p><ul><li><p>在加锁的时候，决定本次是否采样，如果需要采样的话，我们将本次这把锁的相关元数据（加锁竞争耗时、锁标识、采样率）进行填充。</p></li><li><p>在解锁的时候，找到这个元数据后，更新此元数据的解锁耗时，然后将此元数据进行提交到后面队列中</p></li><li><p>元数据的获取有两种方式，</p><ul><li>第一种方式采用 TLS 线程局部缓存，让每个线程提前创建 3 个元数据。这样做有两点意义，第一提高效率，第二我们认为一个线程最多会持有三把锁。</li><li>第二种方式采用元数据池的方式。避免运行时创建数据块、开辟内存空间的开销。当解锁时，元数据释放回数据池</li></ul></li><li><p>在每个线程的 TLS 中有一个链表来存储每个线程产生的元数据。这样做尽最大可能不阻塞加锁和解锁本身的操作。</p></li><li><p>有一个 grab 线程会定期或者被动触发，去处理那些元数据，主要是对相同的锁的一些信息，比如：耗时、次数 进行合并。处理完成后，唤醒 dump 线程</p></li><li><p>dump 线程负责将合并后的数据输出到文件中，数据包括：锁的一些信息：堆栈、耗时、次数等。之后将此元数据释放回对象池。</p></li></ul><p>文件的格式</p><div class="language- line-numbers-mode" data-highlighter="shiki" data-ext="" data-title="" style="--shiki-light:#24292e;--shiki-dark:#abb2bf;--shiki-light-bg:#fff;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes github-light one-dark-pro vp-code"><code><span class="line"><span>duration_ns count @ stack_1 stack_2 ... stack_n</span></span>
<span class="line"><span>duration_ns count @ stack_1 stack_2 ... stack_n</span></span>
<span class="line"><span>...</span></span>
<span class="line"><span>duration_ns count @ stack_1 stack_2 ... stack_n</span></span>
<span class="line"><span>self_maps 的信息</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><ul><li>前面的每一行都代表一把锁的使用情况，以及锁的信息：堆栈、耗时、次数</li><li>最后存储当前进程的 maps 信息</li></ul><p>这个文件内容符合 pprof 的格式。我们最后使用 pprof 进行解析即可。</p><div class="language- line-numbers-mode" data-highlighter="shiki" data-ext="" data-title="" style="--shiki-light:#24292e;--shiki-dark:#abb2bf;--shiki-light-bg:#fff;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes github-light one-dark-pro vp-code"><code><span class="line"><span>pprof --pdf ./sample result.prof &gt; sample_01.pdf</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div></div></div><h3 id="三、结果图" tabindex="-1"><a class="header-anchor" href="#三、结果图"><span>三、结果图</span></a></h3><img src="`+l+'" style="zoom:50%;">',17)]))}const h=t(p,[["render",r],["__file","1.锁竞争分析工具.html.vue"]]),u=JSON.parse('{"path":"/%E6%8A%80%E6%9C%AF%E4%B8%93%E9%A2%98/%E9%94%81%E7%AB%9E%E4%BA%89%E5%88%86%E6%9E%90%E5%B7%A5%E5%85%B7/1.%E9%94%81%E7%AB%9E%E4%BA%89%E5%88%86%E6%9E%90%E5%B7%A5%E5%85%B7.html","title":"1.锁竞争分析工具","lang":"zh-CN","frontmatter":{"title":"1.锁竞争分析工具","description":"一、概述 当很多线程争抢同一把锁时，一些线程无法立刻获得锁，而必须睡眠直到某个线程退出临界区。这个争抢过程我们称之为contention。在多核机器上，当多个线程需要操作同一个资源却被一把锁挡住时，便无法充分发挥多个核心的并发能力。现代OS通过提供比锁更底层的同步原语，使得无竞争锁完全不需要系统调用，只是一两条 wait-free，耗时 10-20ns...","head":[["meta",{"property":"og:url","content":"https://noahyz.github.io/%E6%8A%80%E6%9C%AF%E4%B8%93%E9%A2%98/%E9%94%81%E7%AB%9E%E4%BA%89%E5%88%86%E6%9E%90%E5%B7%A5%E5%85%B7/1.%E9%94%81%E7%AB%9E%E4%BA%89%E5%88%86%E6%9E%90%E5%B7%A5%E5%85%B7.html"}],["meta",{"property":"og:site_name","content":"noahyz的博客"}],["meta",{"property":"og:title","content":"1.锁竞争分析工具"}],["meta",{"property":"og:description","content":"一、概述 当很多线程争抢同一把锁时，一些线程无法立刻获得锁，而必须睡眠直到某个线程退出临界区。这个争抢过程我们称之为contention。在多核机器上，当多个线程需要操作同一个资源却被一把锁挡住时，便无法充分发挥多个核心的并发能力。现代OS通过提供比锁更底层的同步原语，使得无竞争锁完全不需要系统调用，只是一两条 wait-free，耗时 10-20ns..."}],["meta",{"property":"og:type","content":"article"}],["meta",{"property":"og:locale","content":"zh-CN"}],["meta",{"property":"article:author","content":"noahyz"}],["script",{"type":"application/ld+json"},"{\\"@context\\":\\"https://schema.org\\",\\"@type\\":\\"Article\\",\\"headline\\":\\"1.锁竞争分析工具\\",\\"image\\":[\\"\\"],\\"dateModified\\":null,\\"author\\":[{\\"@type\\":\\"Person\\",\\"name\\":\\"noahyz\\",\\"url\\":\\"/about-the-author/\\"}]}"]]},"headers":[{"level":3,"title":"一、概述","slug":"一、概述","link":"#一、概述","children":[]},{"level":3,"title":"二、框架解析","slug":"二、框架解析","link":"#二、框架解析","children":[]},{"level":3,"title":"三、结果图","slug":"三、结果图","link":"#三、结果图","children":[]}],"git":{},"readingTime":{"minutes":3.37,"words":1012},"filePathRelative":"技术专题/锁竞争分析工具/1.锁竞争分析工具.md","excerpt":"<h3>一、概述</h3>\\n<p>当很多线程争抢同一把锁时，一些线程无法立刻获得锁，而必须睡眠直到某个线程退出临界区。这个争抢过程我们称之为<strong>contention</strong>。在多核机器上，当多个线程需要操作同一个资源却被一把锁挡住时，便无法充分发挥多个核心的并发能力。现代OS通过提供比锁更底层的同步原语，使得无竞争锁完全不需要系统调用，只是一两条 wait-free，耗时 <code>10-20ns</code> 的原子操作，非常快。而锁一旦发生竞争，一些线程就要陷入睡眠，再次醒来触发了OS的调度代码，代价至少为 <code>3-5us</code> 。所以让锁尽量无竞争，让所有线程“一起起飞”是高性能服务器的永恒话题。</p>","autoDesc":true}');export{h as comp,u as data};

import{_ as e}from"./plugin-vue_export-helper-DlAUqK2U.js";import{c as a,a as n,o as p}from"./app-D1zlwylF.js";const o={};function r(E,t){return p(),a("div",null,t[0]||(t[0]=[n('<h3 id="一、为什么要有协程" tabindex="-1"><a class="header-anchor" href="#一、为什么要有协程"><span>一、为什么要有协程</span></a></h3><p>对于操作系统来说，线程是 CPU 调度的最小单元，进程是资源管理的最小单元。</p><p>在多核场景下，如果是 IO 密集型场景，就算开多个线程来处理，也未必能提升 CPU 的利用率，反而会增加线程切换的开销。另外，多线程之间假如存在临界区或者共享数据，那么同步的开销也可能比较大。</p><p>那么协程可以解决如上的问题。</p><p>协程是一种比线程更加轻量化的存在，一个线程中可以拥有多个协程。协程的调度由用户实现的调度器来控制。协程拥有自己的寄存器上下文和栈。协程在做调度切换时，一般会将寄存器上下文和栈保存到某个指定地方，在切回来时，恢复先前保存的寄存器上下文和栈，这个过程都是在用户空间完成的，不需要内核的参与。所以切换过程是非常快的。</p><p>对于 CPU 密集型场景，使用协程可能还会增加调度切换的开销。</p><h3 id="二、实现" tabindex="-1"><a class="header-anchor" href="#二、实现"><span>二、实现</span></a></h3><p>在线程的时间片中进行调度。在线程的栈中保存协程的上下文，采用轮询的方式调度协程的执行。</p><p>利用 Linux 的信号机制模拟时钟中断。每当模拟的信号来临时，进行协程切换。</p>',9)]))}const c=e(o,[["render",r],["__file","6.协程的实现方式.html.vue"]]),B=JSON.parse('{"path":"/%E6%8A%80%E6%9C%AF%E4%B8%93%E9%A2%98/%E6%89%8B%E5%86%99%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/5.%E8%BF%9B%E7%A8%8B%E5%92%8C%E7%BA%BF%E7%A8%8B/6.%E5%8D%8F%E7%A8%8B%E7%9A%84%E5%AE%9E%E7%8E%B0%E6%96%B9%E5%BC%8F.html","title":"协程的实现","lang":"zh-CN","frontmatter":{"title":"协程的实现","description":"一、为什么要有协程 对于操作系统来说，线程是 CPU 调度的最小单元，进程是资源管理的最小单元。 在多核场景下，如果是 IO 密集型场景，就算开多个线程来处理，也未必能提升 CPU 的利用率，反而会增加线程切换的开销。另外，多线程之间假如存在临界区或者共享数据，那么同步的开销也可能比较大。 那么协程可以解决如上的问题。 协程是一种比线程更加轻量化的存在...","head":[["meta",{"property":"og:url","content":"https://noahyz.github.io/%E6%8A%80%E6%9C%AF%E4%B8%93%E9%A2%98/%E6%89%8B%E5%86%99%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/5.%E8%BF%9B%E7%A8%8B%E5%92%8C%E7%BA%BF%E7%A8%8B/6.%E5%8D%8F%E7%A8%8B%E7%9A%84%E5%AE%9E%E7%8E%B0%E6%96%B9%E5%BC%8F.html"}],["meta",{"property":"og:site_name","content":"noahyz的博客"}],["meta",{"property":"og:title","content":"协程的实现"}],["meta",{"property":"og:description","content":"一、为什么要有协程 对于操作系统来说，线程是 CPU 调度的最小单元，进程是资源管理的最小单元。 在多核场景下，如果是 IO 密集型场景，就算开多个线程来处理，也未必能提升 CPU 的利用率，反而会增加线程切换的开销。另外，多线程之间假如存在临界区或者共享数据，那么同步的开销也可能比较大。 那么协程可以解决如上的问题。 协程是一种比线程更加轻量化的存在..."}],["meta",{"property":"og:type","content":"article"}],["meta",{"property":"og:locale","content":"zh-CN"}],["meta",{"property":"article:author","content":"noahyz"}],["script",{"type":"application/ld+json"},"{\\"@context\\":\\"https://schema.org\\",\\"@type\\":\\"Article\\",\\"headline\\":\\"协程的实现\\",\\"image\\":[\\"\\"],\\"dateModified\\":null,\\"author\\":[{\\"@type\\":\\"Person\\",\\"name\\":\\"noahyz\\",\\"url\\":\\"/about-the-author/\\"}]}"]]},"headers":[{"level":3,"title":"一、为什么要有协程","slug":"一、为什么要有协程","link":"#一、为什么要有协程","children":[]},{"level":3,"title":"二、实现","slug":"二、实现","link":"#二、实现","children":[]}],"git":{},"readingTime":{"minutes":1.27,"words":381},"filePathRelative":"技术专题/手写操作系统/5.进程和线程/6.协程的实现方式.md","excerpt":"<h3>一、为什么要有协程</h3>\\n<p>对于操作系统来说，线程是 CPU 调度的最小单元，进程是资源管理的最小单元。</p>\\n<p>在多核场景下，如果是 IO 密集型场景，就算开多个线程来处理，也未必能提升 CPU 的利用率，反而会增加线程切换的开销。另外，多线程之间假如存在临界区或者共享数据，那么同步的开销也可能比较大。</p>\\n<p>那么协程可以解决如上的问题。</p>\\n<p>协程是一种比线程更加轻量化的存在，一个线程中可以拥有多个协程。协程的调度由用户实现的调度器来控制。协程拥有自己的寄存器上下文和栈。协程在做调度切换时，一般会将寄存器上下文和栈保存到某个指定地方，在切回来时，恢复先前保存的寄存器上下文和栈，这个过程都是在用户空间完成的，不需要内核的参与。所以切换过程是非常快的。</p>","autoDesc":true}');export{c as comp,B as data};

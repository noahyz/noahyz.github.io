import{_ as l}from"./plugin-vue_export-helper-DlAUqK2U.js";import{c as t,a as n,o as a}from"./app-D1zlwylF.js";const i={};function p(o,e){return a(),t("div",null,e[0]||(e[0]=[n('<p><strong>实现线程的两种方式 --- 内核或用户进程</strong></p><p>线程的实现：</p><ul><li>由操作系统原生支持，用户进程通过系统调用使用线程。线程在 0 特权级的内核空间中实现（并不是线程所运行的代码也必须是 0 特权级的内核级代码，也可以是 3 特权级的用户级代码）</li><li>进程自己实现线程，线程在 3 特权级的用户空间实现。通常情况下，标准库提供了用户级线程库，我们直接调用即可</li></ul><p>线程仅仅是个执行流，在用户空间，还是在内核空间实现它，最大的区别就是线程表在哪里，由谁来调度它上处理器。</p><ul><li>如果线程在用户空间中实现，线程表就在用户进程中，用户进程就要专门写个线程用作线程调度器，由他来调度进程内部的其他线程</li><li>如果线程在内核空间中实现，线程表就在内核中，该线程就会由操作系统的调度器统一调度，无论该线程属于内核，还是用户进程</li></ul><h3 id="一、在用户空间实现线程" tabindex="-1"><a class="header-anchor" href="#一、在用户空间实现线程"><span>一、在用户空间实现线程？</span></a></h3><ul><li>在用户空间中实现线程的好处就是可移植性强，由于是用户级的实现，所以在不支持线程的操作系统上也可以写出完美支持线程的用户程序</li><li>在用户空间实现线程，操作系统不会意识到线程的存在，因为操作系统调度器只会以整个进程的方式调度，将处理器的使用权交给这个进程，由进程中的调度器自己去协调分配处理器时间。</li><li>线程调度涉及到调度器以及线程表。因此，进程还要自己在进程内维护线程表</li><li>这种方式一般由权威机构发布线程库，开发人员使用此库即可。</li></ul><p>在用户空间实现线程的优缺点：</p><ul><li><p>优点：线程调度算法由用户程序自己实现，可以根据实际情况为某些线程加权调度</p></li><li><p>优点：将线程的寄存器映像装载到 CPU 时，可以在用户空间完成，即不用陷入内核态，这样就免去了进入内核时的入栈和出栈操作</p></li><li><p>缺点：进程中某个线程如果出现了阻塞（通常由于系统调用引起），操作系统不知道进程中存在线程，操作系统会认为他是传统型进程（单线程进程），因此会将整个进程挂起，导致进程中所有线程都无法运行。</p></li><li><p>缺点：在用户空间实现线程，对于操作系统来说，调度器的调度单元是整个进程，并不是进程中的线程，所以时钟中断只能影响进程一级的执行流。</p><p>进程中某个线程在处理器上运行后，只要该线程不主动让出 CPU，此进程中的其他线程都没有机会运行。也就是说，可能会出现单一线程过度使用 CPU，其他线程没有调度的机会。只能凭借线程主动让出 CPU（通过类似 pthread_yield、pthread_exit），给进程中的其他线程。</p></li><li><p>缺点：线程在用户空间实现线程，和在内核空间实现相比，只是在内部调度时少了陷入内核的代价，但由于整个进程占据 CPU 的时间片是有限的，这有限的时间片还要再分给内部的线程，所以每个线程执行的时间片非常短暂，再加上进程内线程调度器维护线程表、运行调度算法的时间片消耗，反而抵消了内部调度带来的提速</p></li></ul><h3 id="二、在内核空间实现线程" tabindex="-1"><a class="header-anchor" href="#二、在内核空间实现线程"><span>二、在内核空间实现线程</span></a></h3><p>线程管理的所有工作（创建和撤销）由操作系统内核完成</p><p>在内核空间中实现线程的优缺点：</p><ul><li>优点：内核提供的线程相当于让进程多占了 CPU 资源。比如进程 A 创建了 3 个线程，那么在系统中就一共有 4 个线程在和其他进程或者线程在竞争 CPU 时间。</li><li>优点：当进程中某一线程阻塞后，操作系统只会阻塞这个线程，而这个进程中的其他线程不受影响。就有相当于提速了</li><li>缺点：用户进程需要通过系统调用陷入内核，这里会增加一些现场保护的栈操作，这还是会消耗一些处理器时间。但和上面两个提速相比，这点消耗可以接受。</li></ul><h3 id="三、线程实现的组合策略" tabindex="-1"><a class="header-anchor" href="#三、线程实现的组合策略"><span>三、线程实现的组合策略</span></a></h3><p>由操作系统内核支持内核级多线程，由操作系统的程序库来支持用户级多线程，线程创建完全在用户空间创建，线程的调度也在应用程序内部进行，然后把用户级多线程映射到（或者说是绑定到）一些内核级多线程。编程人员可以针对不同的应用特点调节内核级线程的数目来达到物理并行性和逻辑并行性的最佳方案。</p><h4 id="_1-多对一-many-to-one" tabindex="-1"><a class="header-anchor" href="#_1-多对一-many-to-one"><span>1. 多对一（Many to One）</span></a></h4><p>多个用户线程对应同一个内核线程。线程的创建、调度、同步的所有细节全部由进程的用户空间线程库来处理。这样极大的减少了创建内核态线程的成本，但是线程不可以并行。因此这种模型用的很少。</p><p>用户态线程如何使用内核态线程执行程序？程序是存储在内存中的指令，用户态线程是可以准备好程序让内核态线程执行的</p><ul><li>优点：用户线程的很多操作对内核来说都是透明的，不需要用户态和内核态的频繁切换。这样线程的创建、调度、同步会很快</li><li>缺点：由于多个用户线程对应到同一个内核线程，如果其中一个用户线程阻塞，那么其他用户线程也无法执行</li><li>缺点：内核并不知道用户态有哪些线程，无法像内核线程一样实现较完整的调度、优先级等</li></ul><h4 id="_2-一对一-one-to-one" tabindex="-1"><a class="header-anchor" href="#_2-一对一-one-to-one"><span>2. 一对一（One to One）</span></a></h4><p>每个用户态线程都通过系统调用创建一个绑定的内核线程，并附加在上面执行。这种模型允许所有线程并行执行，能够充分利用多核优势。目前 Linux 中的线程、OpenJDK Java 线程等采用的都是一对一线程模型。每一个JVM线程，都有一个对应的内核线程。</p><ul><li>缺点：每创建一个用户线程，相应地就需要创建一个内核线程，开销较大，因此需要限制整个系统的线程数量。</li><li>缺点：用户线程的大部分操作都会映射到内核线程上，引起用户态和内核态的频繁切换。</li></ul><h4 id="_3-多对多-many-to-many" tabindex="-1"><a class="header-anchor" href="#_3-多对多-many-to-many"><span>3. 多对多（Many to Many）</span></a></h4><p>这种模式下会为 n 个用户态线程分配 m 个内核态线程，m 通过小于 n。一种可行的策略是将 m 设置为 CPU 核心数。这种多对多的关系，减少了内核线程，同时也保证了多核心并行。多对多模型中线程的调度需要由内核态和用户态一起来实现。例如线程间同步需要用户态和内核态共同实现。用户态和内核态的分工合作导致实现该模型非常复杂。</p><p>Linux 采用一对一的模型，我们的系统采用在内核空间中实现线程。</p>',25)]))}const s=l(i,[["render",p],["__file","2.实现线程的方式.html.vue"]]),E=JSON.parse('{"path":"/%E6%8A%80%E6%9C%AF%E4%B8%93%E9%A2%98/%E6%89%8B%E5%86%99%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/5.%E8%BF%9B%E7%A8%8B%E5%92%8C%E7%BA%BF%E7%A8%8B/2.%E5%AE%9E%E7%8E%B0%E7%BA%BF%E7%A8%8B%E7%9A%84%E6%96%B9%E5%BC%8F.html","title":"实现线程的方式","lang":"zh-CN","frontmatter":{"title":"实现线程的方式","description":"实现线程的两种方式 --- 内核或用户进程 线程的实现： 由操作系统原生支持，用户进程通过系统调用使用线程。线程在 0 特权级的内核空间中实现（并不是线程所运行的代码也必须是 0 特权级的内核级代码，也可以是 3 特权级的用户级代码） 进程自己实现线程，线程在 3 特权级的用户空间实现。通常情况下，标准库提供了用户级线程库，我们直接调用即可 线程仅仅是...","head":[["meta",{"property":"og:url","content":"https://noahyz.github.io/%E6%8A%80%E6%9C%AF%E4%B8%93%E9%A2%98/%E6%89%8B%E5%86%99%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/5.%E8%BF%9B%E7%A8%8B%E5%92%8C%E7%BA%BF%E7%A8%8B/2.%E5%AE%9E%E7%8E%B0%E7%BA%BF%E7%A8%8B%E7%9A%84%E6%96%B9%E5%BC%8F.html"}],["meta",{"property":"og:site_name","content":"noahyz的博客"}],["meta",{"property":"og:title","content":"实现线程的方式"}],["meta",{"property":"og:description","content":"实现线程的两种方式 --- 内核或用户进程 线程的实现： 由操作系统原生支持，用户进程通过系统调用使用线程。线程在 0 特权级的内核空间中实现（并不是线程所运行的代码也必须是 0 特权级的内核级代码，也可以是 3 特权级的用户级代码） 进程自己实现线程，线程在 3 特权级的用户空间实现。通常情况下，标准库提供了用户级线程库，我们直接调用即可 线程仅仅是..."}],["meta",{"property":"og:type","content":"article"}],["meta",{"property":"og:locale","content":"zh-CN"}],["meta",{"property":"article:author","content":"noahyz"}],["script",{"type":"application/ld+json"},"{\\"@context\\":\\"https://schema.org\\",\\"@type\\":\\"Article\\",\\"headline\\":\\"实现线程的方式\\",\\"image\\":[\\"\\"],\\"dateModified\\":null,\\"author\\":[{\\"@type\\":\\"Person\\",\\"name\\":\\"noahyz\\",\\"url\\":\\"/about-the-author/\\"}]}"]]},"headers":[{"level":3,"title":"一、在用户空间实现线程？","slug":"一、在用户空间实现线程","link":"#一、在用户空间实现线程","children":[]},{"level":3,"title":"二、在内核空间实现线程","slug":"二、在内核空间实现线程","link":"#二、在内核空间实现线程","children":[]},{"level":3,"title":"三、线程实现的组合策略","slug":"三、线程实现的组合策略","link":"#三、线程实现的组合策略","children":[]}],"git":{},"readingTime":{"minutes":6.6,"words":1980},"filePathRelative":"技术专题/手写操作系统/5.进程和线程/2.实现线程的方式.md","excerpt":"<p><strong>实现线程的两种方式 --- 内核或用户进程</strong></p>\\n<p>线程的实现：</p>\\n<ul>\\n<li>由操作系统原生支持，用户进程通过系统调用使用线程。线程在 0 特权级的内核空间中实现（并不是线程所运行的代码也必须是 0 特权级的内核级代码，也可以是 3 特权级的用户级代码）</li>\\n<li>进程自己实现线程，线程在 3 特权级的用户空间实现。通常情况下，标准库提供了用户级线程库，我们直接调用即可</li>\\n</ul>\\n<p>线程仅仅是个执行流，在用户空间，还是在内核空间实现它，最大的区别就是线程表在哪里，由谁来调度它上处理器。</p>\\n<ul>\\n<li>如果线程在用户空间中实现，线程表就在用户进程中，用户进程就要专门写个线程用作线程调度器，由他来调度进程内部的其他线程</li>\\n<li>如果线程在内核空间中实现，线程表就在内核中，该线程就会由操作系统的调度器统一调度，无论该线程属于内核，还是用户进程</li>\\n</ul>","autoDesc":true}');export{s as comp,E as data};

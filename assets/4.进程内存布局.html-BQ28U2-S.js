import{_ as o}from"./plugin-vue_export-helper-DlAUqK2U.js";import{c as a,a as t,o as c}from"./app-D1zlwylF.js";const d="/assets/32%E4%BD%8D%E6%A8%A1%E5%BC%8F%E4%B8%8B%E8%BF%9B%E7%A8%8B%E5%86%85%E5%AD%98%E5%B8%83%E5%B1%80-D34Pv7ph.png",n="/assets/32%E4%BD%8D%E6%A8%A1%E5%BC%8F%E4%B8%8B%E8%BF%9B%E7%A8%8B%E9%BB%98%E8%AE%A4%E5%86%85%E5%AD%98%E5%B8%83%E5%B1%80-CM2Na3jL.png",i="/assets/64%E4%BD%8D%E6%A8%A1%E5%BC%8F%E4%B8%8B%E8%BF%9B%E7%A8%8B%E5%86%85%E5%AD%98%E5%B8%83%E5%B1%80-BNz9SECC.png",s={};function r(p,e){return c(),a("div",null,e[0]||(e[0]=[t('<p>本文简单介绍下 x86 平台 Linux 进程内存布局</p><h3 id="一、x86-平台-linux-进程内存布局" tabindex="-1"><a class="header-anchor" href="#一、x86-平台-linux-进程内存布局"><span>一、X86 平台 Linux 进程内存布局</span></a></h3><p>Linux 系统在装载 <code>elf</code> 格式的程序文件时，会调用 <code>loader</code> 把可执行文件中的各个段依次载入到从某一地址开始的空间中（载入地址取决<code>link editor(ld)</code> 和机器地址位数，在 32 位机器上是 <code>0x8048000</code>，即 <code>128M</code> 处）。如下图所示，以 <code>32</code> 位机器为例，首先被载入的是 <code>.text</code> 段，然后是 <code>.data</code> 段，最后是 <code>.bss</code> 段。这可以看作是程序的开始空间。程序所能访问的最后的地址是 <code>0xbfffffff</code>，也就是到 3G 地址处，3G 以上的 1G 空间是内核使用的，应用程序不可以直接访问。应用程序的堆栈从最高地址处开始向下生长，<code>.bss</code> 段与堆栈之间的空间是空闲的，空闲空间被分成两部分，一部分为 heap，一部分为 mmap 映射区域，mmap 映射区域一般从<code>TASK_SIZE/3</code> 的地方开始，但在不同的 Linux 内核和机器上，mmap 区域的开始位置一般是不同的。Heap 和 mmap 区域都可以供用户自由使用，但是它在刚开始的时候并没有映射到内存空间内，是不可访问的。在向内核请求分配该空间之前，对这个空间的访问会导致<code>segmentation fault</code>。用户程序可以直接使用系统调用来管理 heap 和 mmap 映射区域，但更多的时候程序都是使用 C 语言提供的<code>malloc()</code> 和 <code>free()</code> 函数来动态的分配和释放内存。Stack 区域是唯一不需要映射，用户却可以访问的内存区域，这也是利用堆栈溢出进行攻击的基础。</p><h4 id="_1-32位模式下进程内存经典布局" tabindex="-1"><a class="header-anchor" href="#_1-32位模式下进程内存经典布局"><span>1. 32位模式下进程内存经典布局</span></a></h4><img src="'+d+'" alt="s" style="zoom:60%;"><p>这种布局是 Linux 内核 2.6.7 以前的默认进程内存布局形式，mmap 区域与栈区域相对增长，这意味着堆只有 1GB 的虚拟地址空间可以使用，继续增长就会进入 mmap 映射区域，这显然不是我们想要的。这是由于 32 模式地址空间限制造成的，所以内核引入了另一种虚拟地址空间的布局形式，将在下面介绍。但对于 64 位系统，提供了巨大的虚拟地址空间，这种布局就相当好。</p><h4 id="_2-32位模式下进程默认内存布局" tabindex="-1"><a class="header-anchor" href="#_2-32位模式下进程默认内存布局"><span>2. 32位模式下进程默认内存布局</span></a></h4><img src="'+n+'" style="zoom:70%;"><p>从上图可以看到，栈至顶向下扩展，并且栈是有界的。堆至底向上扩展，mmap 映射区域至顶向下扩展，mmap 映射区域和堆相对扩展，直至耗尽虚拟地址空间中的剩余区域，这种结构便于 C运行时库使用 mmap 映射区域和堆进行内存分配。上图的布局形式是在内核 2.6.7以后才引入的，这是 32 位模式下进程的默认内存布局形式。 可以看到在不同的段之间会有一定偏移，解决越界问题。</p><h4 id="_3-64位模式下进程内存布局" tabindex="-1"><a class="header-anchor" href="#_3-64位模式下进程内存布局"><span>3. 64位模式下进程内存布局</span></a></h4><img src="'+i+'" alt="s" style="zoom:53%;"><p>上图是 X86_64 下 Linux 进程的默认内存布局形式，这只是一个示意图，当前内核默认配置下，进程的栈和 mmap 映射区域并不是从一个固定地址开始，并且每次启动时的值都不一样，这是程序在启动时随机改变这些值的设置，使得使用缓冲区溢出进行攻击更加困难。当然也可以让进程的栈和 mmap 映射区域从一个固定位置开始，只需要设置全局变量 <code>randomize_va_space</code> 值为0，这个变量默认值为1。用户可以通过设置 <code>/proc/sys/kernel/randomize_va_space</code> 来停用该特性，也可以用如下命令：</p><div class="language- line-numbers-mode" data-highlighter="shiki" data-ext="" data-title="" style="--shiki-light:#24292e;--shiki-dark:#abb2bf;--shiki-light-bg:#fff;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes github-light one-dark-pro vp-code"><code><span class="line"><span>sudo sysctl -w kernel.randomize_va_space=0</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div></div></div>',13)]))}const E=o(s,[["render",r],["__file","4.进程内存布局.html.vue"]]),h=JSON.parse('{"path":"/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/%E5%86%85%E6%A0%B8%E5%8E%9F%E7%90%86/4.%E8%BF%9B%E7%A8%8B%E5%86%85%E5%AD%98%E5%B8%83%E5%B1%80.html","title":"4.进程内存布局","lang":"zh-CN","frontmatter":{"title":"4.进程内存布局","description":"本文简单介绍下 x86 平台 Linux 进程内存布局 一、X86 平台 Linux 进程内存布局 Linux 系统在装载 elf 格式的程序文件时，会调用 loader 把可执行文件中的各个段依次载入到从某一地址开始的空间中（载入地址取决link editor(ld) 和机器地址位数，在 32 位机器上是 0x8048000，即 128M 处）。如下...","head":[["meta",{"property":"og:url","content":"https://noahyz.github.io/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/%E5%86%85%E6%A0%B8%E5%8E%9F%E7%90%86/4.%E8%BF%9B%E7%A8%8B%E5%86%85%E5%AD%98%E5%B8%83%E5%B1%80.html"}],["meta",{"property":"og:site_name","content":"noahyz的博客"}],["meta",{"property":"og:title","content":"4.进程内存布局"}],["meta",{"property":"og:description","content":"本文简单介绍下 x86 平台 Linux 进程内存布局 一、X86 平台 Linux 进程内存布局 Linux 系统在装载 elf 格式的程序文件时，会调用 loader 把可执行文件中的各个段依次载入到从某一地址开始的空间中（载入地址取决link editor(ld) 和机器地址位数，在 32 位机器上是 0x8048000，即 128M 处）。如下..."}],["meta",{"property":"og:type","content":"article"}],["meta",{"property":"og:locale","content":"zh-CN"}],["meta",{"property":"article:author","content":"noahyz"}],["script",{"type":"application/ld+json"},"{\\"@context\\":\\"https://schema.org\\",\\"@type\\":\\"Article\\",\\"headline\\":\\"4.进程内存布局\\",\\"image\\":[\\"\\"],\\"dateModified\\":null,\\"author\\":[{\\"@type\\":\\"Person\\",\\"name\\":\\"noahyz\\",\\"url\\":\\"/about-the-author/\\"}]}"]]},"headers":[{"level":3,"title":"一、X86 平台 Linux 进程内存布局","slug":"一、x86-平台-linux-进程内存布局","link":"#一、x86-平台-linux-进程内存布局","children":[]}],"git":{},"readingTime":{"minutes":3.45,"words":1036},"filePathRelative":"操作系统/内存管理/内核原理/4.进程内存布局.md","excerpt":"<p>本文简单介绍下 x86 平台 Linux 进程内存布局</p>\\n<h3>一、X86 平台 Linux 进程内存布局</h3>\\n<p>Linux 系统在装载 <code>elf</code> 格式的程序文件时，会调用 <code>loader</code> 把可执行文件中的各个段依次载入到从某一地址开始的空间中（载入地址取决<code>link editor(ld)</code> 和机器地址位数，在 32 位机器上是 <code>0x8048000</code>，即 <code>128M</code> 处）。如下图所示，以 <code>32</code> 位机器为例，首先被载入的是 <code>.text</code> 段，然后是 <code>.data</code> 段，最后是 <code>.bss</code> 段。这可以看作是程序的开始空间。程序所能访问的最后的地址是 <code>0xbfffffff</code>，也就是到 3G 地址处，3G 以上的 1G 空间是内核使用的，应用程序不可以直接访问。应用程序的堆栈从最高地址处开始向下生长，<code>.bss</code> 段与堆栈之间的空间是空闲的，空闲空间被分成两部分，一部分为 heap，一部分为 mmap 映射区域，mmap 映射区域一般从<code>TASK_SIZE/3</code> 的地方开始，但在不同的 Linux 内核和机器上，mmap 区域的开始位置一般是不同的。Heap 和 mmap 区域都可以供用户自由使用，但是它在刚开始的时候并没有映射到内存空间内，是不可访问的。在向内核请求分配该空间之前，对这个空间的访问会导致<code>segmentation fault</code>。用户程序可以直接使用系统调用来管理 heap 和 mmap 映射区域，但更多的时候程序都是使用 C 语言提供的<code>malloc()</code> 和 <code>free()</code> 函数来动态的分配和释放内存。Stack 区域是唯一不需要映射，用户却可以访问的内存区域，这也是利用堆栈溢出进行攻击的基础。</p>","autoDesc":true}');export{E as comp,h as data};

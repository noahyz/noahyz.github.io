import{_ as s}from"./plugin-vue_export-helper-DlAUqK2U.js";import{c as a,a as l,o as n}from"./app-D1zlwylF.js";const e="/assets/%E5%93%88%E5%B8%8C%E7%8E%AF%E6%B3%95-DfrI_obJ.png",t="/assets/HRW-DJYZhFLT.png",h="/assets/HRW-opt-D5YMOqoW.png",p="/assets/maglev-entry-table-DIZJncbm.png",d="/assets/maglev-perumation-g0E2hDAg.png",r="/assets/DxHash-example-DAxtWrxf.png",k="/assets/%E9%9C%80%E6%B1%82-DeQHarpW.png",c="/assets/slot-hash-DHW5U5Fm.png",o="/assets/slot-perumation-in-8n_kk.png",g="/assets/slot-weight-add-WwbCOsVU.png",u="/assets/slot-weight-sub-CU7-7luo.png",b="/assets/slot-multi-node-eL7ACwZb.png",y="/assets/slot-rebalance-ByQ29Ori.png",B="/assets/vod-infra-2-C05dcZx4.png",v="/assets/%E6%9C%BA%E6%88%BF%E6%96%87%E4%BB%B6%E6%AF%94%E8%AE%A1%E7%AE%97-CRR2fy8F.png",m="/assets/MCMF-Dle80rnb.png",A="/assets/pid-algorithm-CmGF-rp9.png",D="/assets/%E6%A7%BD%E4%BD%8D%E5%93%88%E5%B8%8C%E8%90%BD%E5%9C%B0-CIDzVRS9.png",E="/assets/%E8%AF%B7%E6%B1%82%E6%B5%81%E7%A8%8B-BpRIUg20.png",f={};function C(_,i){return n(),a("div",null,i[0]||(i[0]=[l('<p>一致性哈希最早于1997年提出，用于在大规模分布式缓存、CDN和负载均衡系统中，将大量请求或数据均匀分配到一组后端节点，并在节点动态增删时最小化的重映射数据。</p><p>我们目前常见的一致性哈希算法，包括：ring hash、jump consistent hash、rendevous hash、maglev hash、Anchor hash等。</p><p>本文首先调研了业界主流的一致性哈希算法，并深入抽象CDN节点缓存场景的核心需求，自主研发了“离散型槽位哈希”算法。该算法高度契合CDN点播业务的特定需求，已成功应用于“快手点播CDN节点”的缓存调度场景，覆盖近2500台机器，直接承接并调度近20T带宽流量。</p><h2 id="一、缘起" tabindex="-1"><a class="header-anchor" href="#一、缘起"><span>一、缘起</span></a></h2><p>我们有 N 个缓存服务器节点，如何将数据（或请求）均衡的映射到这N个节点呢？最简单的方法就是对于请求数据（key）计算一个哈希值，然后将这个哈希值对节点数N取模。如果哈希函数分布均匀，计算出来的哈希值足够均匀，那数据也就可以均匀的映射到N个节点上了。</p><p>但是问题是，如果服务器节点有扩缩容（即N变化），可用节点的数量发生变化，那数据的映射关系就会发生变化。会造成大量缓存失效，对系统的稳定性和性能产生显著冲击。</p><p>因此，我们在寻找一种算法，不仅要求对相同的 key 的多次映射结果一致，还要尽可能减少 N 变化时带来的不一致映射的变化。构建这种映射的算法，一般称之为“一致性哈希”。</p><p>即，我们希望构造一个函数：<code>f(k, n) -&gt; m</code></p><ul><li>输入是请求k 和 节点的数量 n</li><li>输出是映射到节点的标号 m</li></ul><p>理想的一致性哈希方案需要满足：</p><ul><li>平衡性（均衡均衡）：各节点负载近似相同，能按节点权重进行负载分配。</li><li>一致性： <ul><li>相同的 k，n 输入，一定会有相同的输出</li><li>当槽的数目增减时，只能有 <code>K/n</code> 个请求k 进行重新映射</li></ul></li><li>单调性：在新增节点时，原有请求只能映射到原节点或新节点，不会从一个老节点映射到另一个老节点；在移除节点时，仅影响被移除节点对应的请求。</li><li>稳定性（最小扰动）：节点扩容或缩容时，只有极少部分请求需要重新分配，且扰动量应可控。避免不必要的大规模数据迁移。</li></ul><p>还有一些工程上的要求：</p><ul><li>无状态性：算法映射结果不依赖于历史操作顺序（如先前的节点增删次序），以降低在分布式环境中对操作顺序同步的开销。</li><li>高吞吐查询：能够快速完成 key-&gt;node 的映射。衡量 Key→节点 映射的速率，是评估一致性哈希算法性能的核心指标。</li><li>更新低开销：支持高效的节点增删。指节点状态发生变化（节点故障／恢复、集群扩缩容）时，算法完成映射数据结构更新所需的时间与资源。</li><li>低内存占用：算法在内存中的数据结构占用。更小的占用能够降低成本，避免因内存过载导致的性能退化</li></ul><h2 id="二、调研" tabindex="-1"><a class="header-anchor" href="#二、调研"><span>二、调研</span></a></h2><p>我们先来探讨一下常见的一致性哈希的实现思路。</p><h3 id="_1-经典一致性哈希" tabindex="-1"><a class="header-anchor" href="#_1-经典一致性哈希"><span>1. 经典一致性哈希</span></a></h3><p>经典一致性哈希也被称为割环法、哈希环法。这个算法较早提出，应用比较广泛，也比较容易理解。</p><h4 id="_1-算法实现" tabindex="-1"><a class="header-anchor" href="#_1-算法实现"><span>(1). 算法实现</span></a></h4><ul><li>将物理节点通过哈希的方式，映射到一个范围为 <code>[0, 2^32]</code> 的环上，同时根据物理节点的权重，为每个物理节点分配若干个虚拟节点，将这些虚拟节点也映射到环上。</li><li>将数据也通过哈希的方式映射到环上，然后按顺时针方向查找第一个“节点哈希值”大于等于“数据哈希值”的节点。该节点就是数据所分配到的节点。</li></ul><img src="'+e+'" alt="s" style="zoom:30%;"><p>当某一个节点故障之后，相当于在环上去掉对应节点及其对应虚拟节点，只会导致变化的节点上的数据发生重新映射。同理新增一个节点也是类似的。因此可以较好的满足单调性。</p><p>当虚拟节点数较多并且搭配的哈希函数比较均衡，可以使割环法具备不错的平衡性和稳定性。</p><h4 id="_2-性能分析" tabindex="-1"><a class="header-anchor" href="#_2-性能分析"><span>(2). 性能分析</span></a></h4><p>哈希环的查找逻辑是：如何在环上找一个和目标值相近的槽位。因为这些槽位都是有序的，在有序表中可以进行二分查找。所以哈希环的查找时间复杂度是：<code>O(logN)</code>。空间复杂度为：<code>O(N)</code>。</p><p>假设有 N 个节点，新增一个节点，大约有 <code>1/(N+1)</code> 的key需要迁移到新节点。删除一个节点，大约有 <code>1/N</code> 的key需要迁移。总之，添加或者删除槽位，总会影响一个槽位的映射量。因此，哈希环做到了最小化重新映射。</p><h4 id="_3-优缺点" tabindex="-1"><a class="header-anchor" href="#_3-优缺点"><span>(3). 优缺点</span></a></h4><p>优点：</p><ul><li>实现简单，被广泛使用</li><li>支持权重，通过虚拟节点的数量</li></ul><p>缺点：</p><ul><li>虚拟节点数较少的情况下，平衡性较差</li><li>占用内存较大，内存占用 <code>O(v*N)</code> ，其中 v 为节点的虚拟节点数</li></ul><h3 id="_2-rendezvous-hash" tabindex="-1"><a class="header-anchor" href="#_2-rendezvous-hash"><span>2. rendezvous hash</span></a></h3><p>rendezvous hash 也称为最高随机权重哈希，简称为 HRW。</p><p>wiki：<a href="https://en.wikipedia.org/wiki/Rendezvous_hashing" target="_blank" rel="noopener noreferrer">https://en.wikipedia.org/wiki/Rendezvous_hashing</a></p><h4 id="_1-算法实现-1" tabindex="-1"><a class="header-anchor" href="#_1-算法实现-1"><span>(1). 算法实现</span></a></h4><p>基本思路：</p><ul><li>对每个key和每台服务器计算一个“随机权重”值，然后把key分配给权重最大的服务器。也可以理解为，每个key会为所有服务器生成一个随机排序列表，选择列表中的第一名作为归属服务器。这样每个key都能选出最佳服务器。</li><li>如果某台服务器挂掉了，则改用次高值对应的服务器</li><li>如果扩容了一个服务器，相当于增加了一次计算哈希的机会，如果计算出来的哈希值超过原来的最大值，则该部分key分配到新节点</li></ul><img src="'+t+'" style="zoom:50%;"><p>可见，当节点变化时，rendezvous hash 算法只会影响到最大权重值落到变化的节点的key，也就是说只有变化的节点上的数据需要重新映射，因此很符合单调性的要求。而算法的平衡性和稳定性则取决于哈希函数的随机特性。</p><p>时间复杂度：每次选择需要对所有节点计算一次哈希，然后比较，复杂度为 O(N)。当节点数量很大时，耗时就比较长了。针对这一缺点，也提出了一些解决方案。比如分层筛选、增量计算方案。</p><h5 id="a-分层筛选" tabindex="-1"><a class="header-anchor" href="#a-分层筛选"><span>(a). 分层筛选</span></a></h5><ul><li>将节点划分为多个层级或分组，可以按照场景做具体划分</li><li>首先在最顶层分组中执行一次 HRW 选举，确定一个或少数候选分组</li><li>然后仅在候选分组内再次执行 HRW，完成最终节点选择</li></ul><p>通过两级或多级筛选，可以大幅减少每次计算的节点数。计算量可以近似接近 <code>O(logN)</code></p><p>和 wiki 上提出的改进算法一致，也是类似的构建了一棵树。</p><figure><img src="'+h+`" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure><h5 id="b-增量计算" tabindex="-1"><a class="header-anchor" href="#b-增量计算"><span>(b). 增量计算</span></a></h5><ul><li>维护一份按 key 分片的候选节点列表与对应的最高权重</li><li>当节点列表不发生变化时，可直接重用上次的选举结果，无需重新哈希</li><li>在节点增删或者列表更新时，仅对受影响的 key 分片重新计算权重和比较。</li></ul><p>该方法适用于节点变更相对少、请求高频的场景，能将大部分选举操作降至常数时间。</p><h4 id="_2-优缺点" tabindex="-1"><a class="header-anchor" href="#_2-优缺点"><span>(2). 优缺点</span></a></h4><p>优点</p><ul><li>负载均衡：对每个节点计算权重后选最大节点，天然均匀且也有最小扰动的特性。每台服务器承担的key数量相近，</li><li>避免级联故障：当某台服务器故障时，其上的key会均匀的转移到其他服务器上，由于每个key有不同的备选服务器，可以避免将所有失效key都压到同一台机器</li><li>支持权重：权重可以融入哈希计算，可以为不同服务器指定权重</li><li>实现简单：只需维护服务器列表，每次计算权重即可</li></ul><p>缺点：</p><ul><li>新增节点开销较大：添加新服务器时，需要重新计算许多key对各服务器的权重，才能确定新的分配，这会带来较高的计算开销</li><li>查找效率：redezvous 哈希选服务器时需要计算所有服务器的哈希值，查找耗时随服务器数量线性增加。时间复杂度<code>O(n)</code></li></ul><h3 id="_3-jump-consistent-hash" tabindex="-1"><a class="header-anchor" href="#_3-jump-consistent-hash"><span>3. jump consistent hash</span></a></h3><p>论文：<a href="https://arxiv.org/abs/1406.2294" target="_blank" rel="noopener noreferrer">https://arxiv.org/abs/1406.2294</a></p><p>我来根据论文中的思路，分步拆解一下算法的核心原理。</p><p>核心思想：随着槽位数量增多，只有一小部分键会“跳”到新槽位。</p><ul><li>均衡性：当槽位由 n 增至 n+1 时，<code>1/n+1</code> 的键应“跳”到新槽位。其余 <code>n/n+1</code> 的键应该保持原槽位不变。</li><li>单调性：仅在槽位数增加时才会重新分配，且不会把键从新槽位“跳”回旧槽位。</li></ul><p>我们定义一个目标函数 <code>ch(k, n)</code> ，表示当槽位数量为 n 时，给定键 k 映射到槽位的编号，范围是 <code>[0, n)</code>。我们分别建立不同的跳跃模型来推导算法的思想。</p><h4 id="_1-线性时间版本-逐槽位跳跃模型" tabindex="-1"><a class="header-anchor" href="#_1-线性时间版本-逐槽位跳跃模型"><span>(1). 线性时间版本：逐槽位跳跃模型</span></a></h4><p>最为简单粗暴的一种解法就是，针对某个key，我们依次对每个槽位都判断一下。如下代码实现</p><div class="language-c line-numbers-mode" data-highlighter="shiki" data-ext="c" data-title="c" style="--shiki-light:#24292e;--shiki-dark:#abb2bf;--shiki-light-bg:#fff;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes github-light one-dark-pro vp-code"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#C678DD;">int</span><span style="--shiki-light:#6F42C1;--shiki-dark:#61AFEF;"> ch</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">(</span><span style="--shiki-light:#D73A49;--shiki-dark:#C678DD;">int</span><span style="--shiki-light:#E36209;--shiki-dark:#E06C75;--shiki-light-font-style:inherit;--shiki-dark-font-style:italic;"> key</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">,</span><span style="--shiki-light:#D73A49;--shiki-dark:#C678DD;"> int</span><span style="--shiki-light:#E36209;--shiki-dark:#E06C75;--shiki-light-font-style:inherit;--shiki-dark-font-style:italic;"> num_buckets</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">) {</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E5C07B;">  random</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#61AFEF;">seed</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">(key);</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#C678DD;">  int</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;"> b </span><span style="--shiki-light:#D73A49;--shiki-dark:#C678DD;">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#D19A66;"> 0</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">;</span><span style="--shiki-light:#6A737D;--shiki-dark:#7F848E;--shiki-light-font-style:inherit;--shiki-dark-font-style:italic;">  // 当前映射的槽位号</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#C678DD;">  for</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;"> (</span><span style="--shiki-light:#D73A49;--shiki-dark:#C678DD;">int</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;"> j </span><span style="--shiki-light:#D73A49;--shiki-dark:#C678DD;">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#D19A66;"> 1</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">; j </span><span style="--shiki-light:#D73A49;--shiki-dark:#C678DD;">&lt;</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;"> num_buckets; j</span><span style="--shiki-light:#D73A49;--shiki-dark:#C678DD;">++</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">) {</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#7F848E;--shiki-light-font-style:inherit;--shiki-dark-font-style:italic;">    // 以概率 1/(j+1) “跳”到 j 号槽位</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#C678DD;">    if</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;"> (</span><span style="--shiki-light:#24292E;--shiki-dark:#E5C07B;">random</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#61AFEF;">next</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">() </span><span style="--shiki-light:#D73A49;--shiki-dark:#C678DD;">&lt;</span><span style="--shiki-light:#005CC5;--shiki-dark:#D19A66;"> 1.0</span><span style="--shiki-light:#D73A49;--shiki-dark:#C678DD;"> /</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;"> (j </span><span style="--shiki-light:#D73A49;--shiki-dark:#C678DD;">+</span><span style="--shiki-light:#005CC5;--shiki-dark:#D19A66;"> 1</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">)) {</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">      b </span><span style="--shiki-light:#D73A49;--shiki-dark:#C678DD;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;"> j;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">    }</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">  }</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#C678DD;">  return</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;"> b;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">}</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>这种方法对每一个槽位都做了一次随机判断，时间复杂度是 <code>O(n)</code></p><h4 id="_2-对数时间版本" tabindex="-1"><a class="header-anchor" href="#_2-对数时间版本"><span>(2). 对数时间版本</span></a></h4><p>为了避免对所有槽位都遍历一次，我们利用“跳跃只发生在少数位置”这一事实，直接跳过不跳跃的区间。</p><h5 id="a-定义随机跳跃变量" tabindex="-1"><a class="header-anchor" href="#a-定义随机跳跃变量"><span>(a). 定义随机跳跃变量</span></a></h5><p>假设当前上一次跳跃到的位置为b，我们想直接计算下一个跳跃会落地第 j 号槽位，其中<br> $$<br> j = max{i &gt; b | ch(k,i) = ch(k, b+1)}<br> $$<br> 换言之，j 是“下一次映射改变”的槽位编号，i 为每次遍历的槽位号。</p><p>这个公式我们分两层来理解：</p><p>第一： <code>ch(k,i)</code> 在那些区间里保持不变？</p><ul><li>我们已经知道，上一次真正“跳跃”发生在槽位号 b，也就是说：<code>ch(k,b) != ch(k, b+1)</code></li><li>从槽位 b+1 开始，如果后面几个槽位里都没有再发生新的跳跃，那么这些槽位的映射值都会跟 “在 b+1 时的槽位号” 一样</li><li>具体来说，只要对于某个 <code>i&gt;b</code>，则有 <code>ch(k,i) = ch(k,b+1)</code>。就说明从槽位 b+1 到槽位 i 的这段区间里，键 key 还粘在原来的槽位上，没有再跳到新的槽位。</li></ul><p>第二：找出这段区间的最后一个槽位</p><ul><li><p>我们知道，这个“不跳槽位”的状态能够持续到那个槽位号，之后才会真正有一次新的跳转。</p></li><li><p>那么 j 就定义为“所有大于b且映射仍等于 <code>ch(k,b+1)</code>的槽位号” 中的最大值</p></li><li><p>换句话说，从槽位 b+1 开始，直到槽位 j，<code>ch(k,i)</code>都还没有变；在下一号槽位 j+1 上，<code>ch(k,j+1)</code>就会跟 <code>ch(b+1)</code>不一样，也就是发生了新的跳跃。</p></li></ul><p>举个例子，假设上一个跳到的槽位是 b=2，那么我们从槽位 3 开始观察：</p><ul><li>若 <code>ch(k,3)=5, ch(k,4)=5, ch(k,5)=5</code>，但是 <code>ch(k,6)=7</code></li><li>则这时“保持<code>ch(k,3)</code>”的最大槽位号就是 <code>j=5</code></li><li>意味着真正的下一个跳跃点位于 <code>j+1=6</code>，在哪里映射才会变成别的槽位</li></ul><h5 id="b-概率约束" tabindex="-1"><a class="header-anchor" href="#b-概率约束"><span>(b). 概率约束</span></a></h5><p>对任意 <code>i&gt;b</code>，有：<br> $$<br> P(j \\geq i) = P(映射在槽位 i 之前不变) = \\frac{b+1}{i}<br> $$<br> 我们对这个公式做下解释</p><ul><li>记 <code>ch(k,i)</code>为键key在 i 个槽位时映射到的槽位号</li><li>假设我们已经在槽位 b 发生了上一次映射跳转，也就是说：<code>ch(k,b) != ch(k,b+1)</code>。而在所有 i 满足 <code>b+1 &lt; i &lt;= n</code>的情况下，如果映射不再改变，则：<code>ch(k,i) = ch(k,b+1)</code></li><li>那么，对于任意 <code>i&gt;b</code>，映射在 <code>[b+1, i]</code> 这段区间的槽位一直不改变的概率是：</li></ul><p>$$<br> P(槽位不变) = \\frac{b+1}{b+2} \\times \\frac{b+2}{b+3} \\times ... \\times \\frac{i-1}{i} = \\frac{b+1}{i}<br> $$</p><h5 id="c-引入均匀随机数" tabindex="-1"><a class="header-anchor" href="#c-引入均匀随机数"><span>(c). 引入均匀随机数</span></a></h5><ul><li><p>令 <code>r ∈ (0,1] </code> 为伪随机数（依赖key和迭代）</p></li><li><p>我们要让“下一个跳转点”落在“槽位大于等于 i ” 的事件，等价于 “直到槽位 i 之前都不跳”， 其概率为 <code>(b+1)/i</code></p></li><li><p>按照逆变换抽样的方法</p></li></ul><p>$$<br> P(j \\geq i) = \\frac{b+1}{i} &lt;==&gt; P(r \\leq \\frac{b+1}{i}) = \\frac{b+1}{i}<br> $$</p><p>也就是说，只要随机数 r 落在 <code>[0, (b+1)/i]</code> 中，就意味着“跳点不会早于 i”</p><p>我们对不等式进行一下转换<br> $$<br> r \\leq \\frac{b+1}{i} ==&gt; i \\leq \\frac{b+1}{r}<br> $$<br> 由于 j 要是“不跳前 i” 中最大的那个 i，自然就取如上式中的最大整数解：<br> $$<br> j = [\\frac{b+1}{r}]<br> $$<br> 我们举一个例子感受一下。</p><ul><li>假设当前 b=2，那么我们从槽位3开始观察</li><li>若 <code>r=0.2</code>，则 <code>(b+1)/r = 3/0.2 = 15</code>，向下取整得到 <code>j=15</code>。意味着下次跳转直接落在槽位15。</li><li>若 <code>r=0.9</code>，则 <code>(b+1)/r ≈ 3/0.9 ≈ 3.33</code>，向下取整得到 <code>j=3</code>。即下一跳落到槽位3。</li><li>这样 r 越小，<code>(b+1)/r</code> 越大，跳的就越远；r 越大，跳的就越近。且由于 r 均匀分布，这正好匹配了我们的需求：越靠前的槽位，越小概率跳过去；越靠后的槽位，概率越低但是区间更大。</li></ul><p>这样，一次运算就能跳到下一个有可能改变映射的位置，而无需遍历中间所有的槽位。</p><h5 id="d-最终实现" tabindex="-1"><a class="header-anchor" href="#d-最终实现"><span>(d). 最终实现</span></a></h5><p>我们将上述的“跳跃逻辑”和“伪随机数生成器”结合，就得到了论文中给出的简洁实现。</p><p>跳跃一致性哈希的算法代码比较精简。如下：</p><div class="language-c line-numbers-mode" data-highlighter="shiki" data-ext="c" data-title="c" style="--shiki-light:#24292e;--shiki-dark:#abb2bf;--shiki-light-bg:#fff;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes github-light one-dark-pro vp-code"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#C678DD;">int32_t</span><span style="--shiki-light:#6F42C1;--shiki-dark:#61AFEF;"> JumpConsistentHash</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">(</span><span style="--shiki-light:#D73A49;--shiki-dark:#C678DD;">uint64_t</span><span style="--shiki-light:#E36209;--shiki-dark:#E06C75;--shiki-light-font-style:inherit;--shiki-dark-font-style:italic;"> key</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">,</span><span style="--shiki-light:#D73A49;--shiki-dark:#C678DD;"> int32_t</span><span style="--shiki-light:#E36209;--shiki-dark:#E06C75;--shiki-light-font-style:inherit;--shiki-dark-font-style:italic;"> num_buckets</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">) {</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#C678DD;">  int64_t</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;"> b </span><span style="--shiki-light:#D73A49;--shiki-dark:#C678DD;">=</span><span style="--shiki-light:#D73A49;--shiki-dark:#C678DD;"> -</span><span style="--shiki-light:#005CC5;--shiki-dark:#D19A66;">1</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">, j </span><span style="--shiki-light:#D73A49;--shiki-dark:#C678DD;">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#D19A66;"> 0</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">;</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#C678DD;">  while</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;"> (j </span><span style="--shiki-light:#D73A49;--shiki-dark:#C678DD;">&lt;</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;"> num_buckets) {</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">    b </span><span style="--shiki-light:#D73A49;--shiki-dark:#C678DD;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;"> j;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">    key </span><span style="--shiki-light:#D73A49;--shiki-dark:#C678DD;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;"> key </span><span style="--shiki-light:#D73A49;--shiki-dark:#C678DD;">*</span><span style="--shiki-light:#005CC5;--shiki-dark:#D19A66;"> 2862933555777941757</span><span style="--shiki-light:#D73A49;--shiki-dark:#E06C75;">ULL</span><span style="--shiki-light:#D73A49;--shiki-dark:#C678DD;"> +</span><span style="--shiki-light:#005CC5;--shiki-dark:#D19A66;"> 1</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">    j </span><span style="--shiki-light:#D73A49;--shiki-dark:#C678DD;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;"> (b </span><span style="--shiki-light:#D73A49;--shiki-dark:#C678DD;">+</span><span style="--shiki-light:#005CC5;--shiki-dark:#D19A66;"> 1</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">) </span><span style="--shiki-light:#D73A49;--shiki-dark:#C678DD;">*</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;"> (</span><span style="--shiki-light:#D73A49;--shiki-dark:#C678DD;">double</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">(</span><span style="--shiki-light:#005CC5;--shiki-dark:#D19A66;">1</span><span style="--shiki-light:#D73A49;--shiki-dark:#E06C75;">LL</span><span style="--shiki-light:#D73A49;--shiki-dark:#C678DD;"> &lt;&lt;</span><span style="--shiki-light:#005CC5;--shiki-dark:#D19A66;"> 31</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">) </span><span style="--shiki-light:#D73A49;--shiki-dark:#C678DD;">/</span><span style="--shiki-light:#D73A49;--shiki-dark:#C678DD;"> double</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">((key </span><span style="--shiki-light:#D73A49;--shiki-dark:#C678DD;">&gt;&gt;</span><span style="--shiki-light:#005CC5;--shiki-dark:#D19A66;"> 33</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">) </span><span style="--shiki-light:#D73A49;--shiki-dark:#C678DD;">+</span><span style="--shiki-light:#005CC5;--shiki-dark:#D19A66;"> 1</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">));</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">  }</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#C678DD;">  return</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;"> b;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">}</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>函数 JumpConsistentHash 是一个一致性哈希函数，输入 key 和槽位数量，输出槽位编号。</p><ul><li>线性同余生成器：常数 <code>2862933555777941757ULL</code> 用于在高维空间保持良好分布</li><li>位运算+浮点：通过 <code>key &gt;&gt; 33</code> 提取高位，再用浮点除数模拟 <code>1/r</code>，合并就是 <code>(b+1)/r</code></li></ul><h4 id="_3-性质" tabindex="-1"><a class="header-anchor" href="#_3-性质"><span>(3). 性质</span></a></h4><ul><li><p>时间复杂度：因为 r 的分布是均匀的，在槽位数将变化为 i 的时候发生跳跃的概率为 <code>1/i</code>，那么期望的迭代次数就是 <code>1/2+...+1/i+...1/n</code>。复杂度是 <code>log(n)</code></p></li><li><p>空间开销：没有额外内存占用</p></li><li><p>负载均匀：r 的分布是均匀的，分配的标准差极低，论文中描述 99%的置信区间几乎完美均衡</p></li><li><p>重分布平滑：从 n 扩容到 n+1 时，仅 <code>1/n+1</code> 的键会改变归属，且在各槽位间均匀分布</p></li><li><p>局限性：仅支持在末尾顺序添加或者删除节点，不支持任意节点的增删或者权重设置。</p></li></ul><h3 id="_4-maglev-hash" tabindex="-1"><a class="header-anchor" href="#_4-maglev-hash"><span>4. Maglev hash</span></a></h3><p>论文：<a href="https://research.google/pubs/maglev-a-fast-and-reliable-software-network-load-balancer/" target="_blank" rel="noopener noreferrer">https://research.google/pubs/maglev-a-fast-and-reliable-software-network-load-balancer/</a></p><h4 id="_1-算法详解" tabindex="-1"><a class="header-anchor" href="#_1-算法详解"><span>(1). 算法详解</span></a></h4><p>maglev hash 算法的思路是查表，建立一个槽位的查找表，对输入key座哈希再取余，即可映射到表中一个槽位。</p><p>如下查找表的长度为 M，当输入一个key时，映射到目标槽位就是：<code>table[hash(key)%M]</code></p><img src="`+p+`" alt="s" style="zoom:33%;"><p>此算法的重点就是如何生成一张查找表。我们根据论文的思路，逐步拆解下算法。</p><h5 id="a-为每个后端节点生成-随机排列" tabindex="-1"><a class="header-anchor" href="#a-为每个后端节点生成-随机排列"><span>(a). 为每个后端节点生成“随机排列”</span></a></h5><p>在 maglev hash 中，我们要为每个后端节点找到一条能遍历整个查找表且不重复的“路径”（论文中将其称为 permulation），以便后面轮流分配槽位时，每个后端节点都有一个完整、随机且可重现的候选序列。要做到这一点，关键有两个要素：</p><ul><li>随机起点（offset）</li><li>随机步长（skip）</li></ul><p>我们用两个独立的哈希函数 h1 和 h2 来分别产出这两个要素。</p><blockquote><p>为什么要使用两个哈希函数</p><ul><li>保证随机性和独立性。如果只用一个哈希值去同时决定起点和步长，很难既保证起点在 <code>[0,M)</code> 均匀，又保证步长在 <code>[1,M−1]</code> 上独立且与表长度无关。用两个哈希函数，各自负责一部分，就能保证这两个参数彼此独立，从而让整条路径更加“随机”、更难出现系统性冲突。</li><li>不同含义，不同范围。 <ul><li>offset 需要落在 <code>[0, M-1]</code>之间</li><li>skip 需要落在 <code>[1, M-1]</code> 之间（不能为0，否则路径相当于没动，也不能为M，同样路径相当于回到起点）。两者的取值范围不同，分开用两个哈希函数来映射最为合适。</li></ul></li></ul></blockquote><p>对于后端节点 i。计算出两个哈希值<br> $$<br> offset = h1(i) \\quad mod \\quad M<br> $$</p><ul><li>作用：决定这条路径从查找表索引那一个槽开始尝试分配</li><li>意义：不同后端通过 h1 映射到不同的起点，确保各自的路径分散在表中，不会集中在某一块区域</li></ul><p>$$<br> skip = (h2(i) \\quad mod \\quad (M-1)) +1<br> $$</p><ul><li>作用：决定每次“下一跳”跳过多少槽</li><li>为什么要加1？ <ul><li>如果直接取 <code>mod M</code>，可能得到 0，那么每次都在同一个槽上“打转”</li><li>如果直接取 <code>mod M</code>，可能得到 M，那么可能会出现 <code>mod M</code> 后等于 0</li><li>所以我们用 <code>mod (M-1)</code> 确保结果在 <code>[0, M-2]</code> 范围，再+1让他变成 <code>[1, M-1]</code></li></ul></li><li>意义： <ul><li>步长不能与表长公约：当M为质数时，任意在 <code>[1, M-1]</code>的步长都与 M 互质，保证走 M 步后能遍历全表</li><li>随机性：不同后端通过 h2 得到不同步长，路径不会同步，也就不会总是抢统一个空槽</li></ul></li></ul><p>将如上内容合起来就是一个“伪随机全表遍历”方法。某个后端节点每次生成的 permutation元素为：<br> $$<br> permutation[j] = (offset + j × skip) \\quad mod \\quad M \\quad (j=0,1,..,M-1)<br> $$</p><ul><li>offset 决定第一步走到哪里</li><li>skip 决定了下一步绕过多少个槽</li><li>反复累加，就能在 M 步内打卡表中所有槽，且顺序对不同后端节点都不同</li></ul><h5 id="b-轮流抢占空槽-填充查找表" tabindex="-1"><a class="header-anchor" href="#b-轮流抢占空槽-填充查找表"><span>(b). 轮流抢占空槽，填充查找表</span></a></h5><p>这一阶段的目标：在大小为 M 的表中，公平的给每个后端节点分配 <code>M/N</code> 或 <code>N/M</code> 个槽，使得每个后端节点最终得到的槽位数只相差1。</p><ul><li><p>初始化：</p><ul><li><code>next[i] = 0</code>，表示后端节点 i 下一次要尝试的 permutation 下标</li><li><code>table[0..M-1] = -1</code>，表示表的槽都还空着</li><li><code>n = 0</code>，记录已分配槽的总数</li></ul></li><li><p>如下伪代码</p><div class="language- line-numbers-mode" data-highlighter="shiki" data-ext="" data-title="" style="--shiki-light:#24292e;--shiki-dark:#abb2bf;--shiki-light-bg:#fff;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes github-light one-dark-pro vp-code"><code><span class="line"><span>for i = 0 .. N−1:                  // 依次让所有后端节点轮流尝试</span></span>
<span class="line"><span>  c = permutation[i][ next[i] ]    // 取出后端 i 的下一个候选槽号</span></span>
<span class="line"><span>  while entry[c] != −1:             // 如果该槽已被占用，就跳到它的下一个候选</span></span>
<span class="line"><span>    next[i] += 1</span></span>
<span class="line"><span>    c = permutation[i][ next[i] ]</span></span>
<span class="line"><span>  entry[c] = i                     // 抢到空槽，就把槽分给后端 i</span></span>
<span class="line"><span>  next[i] += 1                     // 下次尝试从下一个候选开始</span></span>
<span class="line"><span>  n += 1                           // 分配计数加 1</span></span>
<span class="line"><span>  if n == M:</span></span>
<span class="line"><span>  	break                					 // 填满就结束</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div></li></ul><p>我们举个例子，我们现在有三个后端节点：N1、N2、N3。查找表长度M为6。随机生成的每个后端节点的 permutation 如下：</p><div class="language- line-numbers-mode" data-highlighter="shiki" data-ext="" data-title="" style="--shiki-light:#24292e;--shiki-dark:#abb2bf;--shiki-light-bg:#fff;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes github-light one-dark-pro vp-code"><code><span class="line"><span>N1 permutation: [0, 2, 4, 1, 3, 5]</span></span>
<span class="line"><span>N2 permutation: [1, 3, 5, 0, 2, 4]</span></span>
<span class="line"><span>N3 permutation: [2, 5, 1, 4, 0, 3]</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>按照如上的伪代码，便可以进行填充了，流程如下图</p><img src="`+d+`" style="zoom:33%;"><h5 id="c-查表选后端节点" tabindex="-1"><a class="header-anchor" href="#c-查表选后端节点"><span>(c). 查表选后端节点</span></a></h5><p>得到查找表之后，请求键key通过哈希和取模便可以从查找表中选择一个后端节点。</p><h4 id="_2-优缺点-1" tabindex="-1"><a class="header-anchor" href="#_2-优缺点-1"><span>(2). 优缺点</span></a></h4><ul><li>极致均衡：每一轮都让所有后端节点公平的抢一个槽，保证后端节点占据的槽位数量差距不超过1</li><li>平滑重映射（相对）：增删后端节点时，只需要对哪些空出来或新增的槽做少量重分配，不影响已确定的其他槽，扰动相对可控</li><li>性能良好：<code>O(1)</code>查找时间复杂度。查表过程仅一次取模和一次数组访问，非常快速，</li></ul><p>缺点：</p><ul><li>无法严格最小扰动：节点变更时需要重建表</li><li>内存开销巨大：表大小 M 通常远大于节点数N（需为大质数）</li><li>不支持权重（原生）</li></ul><h3 id="_5-anchor-hash" tabindex="-1"><a class="header-anchor" href="#_5-anchor-hash"><span>5. anchor hash</span></a></h3><p>论文：<a href="https://arxiv.org/pdf/1812.09674" target="_blank" rel="noopener noreferrer">https://arxiv.org/pdf/1812.09674</a></p><p>传统算法往往难以同时兼顾全局一致性（最小扰动）、负载均衡、高吞吐率、低内存和快速更新等需求。Anchorhash算法应运而生。它是一种新的可扩展一致性哈希算法，通过借助额外的状态信息，保证在节点任意增删时仍实现最小扰动和均衡分布，同时提供极高的查询速度、低内存占用和快速的节点更新。</p><p>论文中指出 AnchorHash 是目前唯一兼顾以上所有目标的算法。接下来我们将深入探讨 AnchorHash 的核心原理和性能特性。</p><h4 id="_1-核心算法" tabindex="-1"><a class="header-anchor" href="#_1-核心算法"><span>(1). 核心算法</span></a></h4><p>假设我们有一个工作集列表W，里面保存的是可用的后端节点，假设现在有 8 个。那对于每个请求 key 计算出一个哈希值，然后取模8，就可以均衡的映射到每个后端节点。此时，如果某个节点故障了，剩余可用节点有7个，那对于每个请求key计算哈希值并且取模7，就会导致所有节点之前的映射全部作废，也即所有请求key全部重新映射。破坏了“最小映射”属性（如果有节点被删除，应该只会影响到该节点）。</p><p>为了解决该问题，AnchorHash提出来，虽然某个节点故障了（原来有8个节点，现在有7个节点），但是对于每个请求 key 计算出来的哈希值，仍然按照 8 进行取模。只有映射到故障节点的“请求key”才需要被重新映射。这样可以保证最小映射。</p><p>那现在的问题是，命中故障节点后如何被重新映射。故障节点被加回来之后，又该如何重新映射。</p><h5 id="a-初始化数据" tabindex="-1"><a class="header-anchor" href="#a-初始化数据"><span>(a). 初始化数据</span></a></h5><div class="language- line-numbers-mode" data-highlighter="shiki" data-ext="" data-title="" style="--shiki-light:#24292e;--shiki-dark:#abb2bf;--shiki-light-bg:#fff;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes github-light one-dark-pro vp-code"><code><span class="line"><span>type AnchorHash struct {</span></span>
<span class="line"><span>    A []uint32  // “活跃度”标记：记录每个桶（slot）是否在用，以及移除时的 W 大小</span></span>
<span class="line"><span>    K []uint32  // “后继指针” ：帮助我们在递归重哈希时，快速跳到下一个有效桶</span></span>
<span class="line"><span>    W []uint32  // “工作集列表”：在移除/添加过程中，维护当前 W 中的桶序列</span></span>
<span class="line"><span>    L []uint32  // “位置映射”：记录某个桶在 W 列表里的下标，便于 O(1) 删除</span></span>
<span class="line"><span>    R []uint32  // “移除栈”  ：按照后进先出的顺序，记录被移除的桶 ID</span></span>
<span class="line"><span>    N uint32    // 当前工作集大小 |W|，即还在用的桶数量</span></span>
<span class="line"><span>}</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>其中，我们用 slot 表示故障的桶（或者称为槽位）</p><ul><li><code>A[slot]</code> 表示每个桶的可用情况 <ul><li><code>A[slot]=0</code> 表示桶 slot 在工作集W中，此桶是可用的</li><li><code>A[slot]&gt;0</code> 表示桶 slot 已被移除过，且会记录移除前 W 的大小。且 <code>A[slot]=当前的在线桶数</code></li></ul></li><li><code>K[slot]</code> 如果在哈希时，跳到了一个故障桶，此时会使用 <code>K[slot]</code> 这个后继找，直到落到一个真正有效的桶。</li><li>W 数组就是当前还在线的桶ID列表，范围在：0到 N-1 之间。即只用前N项。</li><li><code>L[slot]</code> 桶 slot 在 W 中是第几个，方便在删除某个 slot 时能够快速找到他的位置</li><li>R 是一个栈，记录移除过哪些桶，以便能够在添加桶的时候能捡回最新移除的那个</li><li>N 则是 W 的长度，也就是当前在线桶数</li></ul><p>如下就是类的初始化代码</p><div class="language- line-numbers-mode" data-highlighter="shiki" data-ext="" data-title="" style="--shiki-light:#24292e;--shiki-dark:#abb2bf;--shiki-light-bg:#fff;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes github-light one-dark-pro vp-code"><code><span class="line"><span>func NewAnchorHash(buckets, used int) *AnchorHash {</span></span>
<span class="line"><span>	r := &amp;AnchorHash{</span></span>
<span class="line"><span>		A: make([]uint32, buckets),</span></span>
<span class="line"><span>		K: make([]uint32, buckets),</span></span>
<span class="line"><span>		W: make([]uint32, buckets),</span></span>
<span class="line"><span>		L: make([]uint32, buckets),</span></span>
<span class="line"><span>		R: make([]uint32, buckets),</span></span>
<span class="line"><span>		N: uint32(used),</span></span>
<span class="line"><span>	}</span></span>
<span class="line"><span>	for i := uint32(0); i &lt; uint32(used); i++ {</span></span>
<span class="line"><span>		r.K[i] = i</span></span>
<span class="line"><span>		r.W[i] = i</span></span>
<span class="line"><span>		r.L[i] = i</span></span>
<span class="line"><span>	}</span></span>
<span class="line"><span>	for i, j := uint32(buckets)-1, 0; i &gt;= uint32(used); i, j = i-1, j+1 {</span></span>
<span class="line"><span>		r.A[i] = i</span></span>
<span class="line"><span>		r.R[j] = i</span></span>
<span class="line"><span>	}</span></span>
<span class="line"><span>	return r</span></span>
<span class="line"><span>}</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>简单来说，就是：</p><ul><li>先准备好一个“最大桶池”，大小为 buckets</li><li>把 <code>[0, used-1]</code> 号桶作为在线，放入 W 中</li><li>把 <code>[used, bucket-1]</code> 号桶作为候补，按顺序压入“移除栈R”，标记 <code>A[slot]=slot</code>（用他记录当时 W 大小）</li><li>N=used，表示我们现在有 used 个可用桶</li></ul><h5 id="b-请求key选择桶" tabindex="-1"><a class="header-anchor" href="#b-请求key选择桶"><span>(b). 请求key选择桶</span></a></h5><p>我们会对请求 key 计算哈希值，在整个 Anchor 池中选择一个桶。如果这个桶可用，就直接返回了。如果这个桶不可用被移除了，那此时需要找新桶。伪代码流程如下：</p><div class="language- line-numbers-mode" data-highlighter="shiki" data-ext="" data-title="" style="--shiki-light:#24292e;--shiki-dark:#abb2bf;--shiki-light-bg:#fff;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes github-light one-dark-pro vp-code"><code><span class="line"><span>b := HashA(key) mod |A|          // 首先从整个 Anchor 池选择桶</span></span>
<span class="line"><span>while A[b] &gt; 0 {                // 如果点到的是“已删桶”，就要重哈希</span></span>
<span class="line"><span>    h := Hash_b(key) mod A[b]   // 在它被删时的 W 大小范围内，重新选择</span></span>
<span class="line"><span>    // 如果 h 也已删，就用 K[h] 一路追溯到它的“后继”</span></span>
<span class="line"><span>    while A[h] &gt;= A[b] {</span></span>
<span class="line"><span>        h = K[h]</span></span>
<span class="line"><span>    }</span></span>
<span class="line"><span>    b = h                        // 定位到新的候选 b</span></span>
<span class="line"><span>}</span></span>
<span class="line"><span>return b                        // 找到一个 A[b]==0 的“在线”桶</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>这样做：</p><ul><li>只有选择到已删除桶的请求key才多做一次或几次选择，而其他key一次就可以定位，保证查找高效</li><li>重哈希范围严格受限于：桶被删时 W 的大小限制，key的重映射数量就是受影响桶上的key，满足一致性哈希的“最小扰动”</li></ul><h5 id="c-动态扩缩容" tabindex="-1"><a class="header-anchor" href="#c-动态扩缩容"><span>(c). 动态扩缩容</span></a></h5><p>移除桶的操作，伪代码如下：</p><div class="language- line-numbers-mode" data-highlighter="shiki" data-ext="" data-title="" style="--shiki-light:#24292e;--shiki-dark:#abb2bf;--shiki-light-bg:#fff;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes github-light one-dark-pro vp-code"><code><span class="line"><span>if A[b] != 0 { return }     // 只能删在线的</span></span>
<span class="line"><span>N--                         // 工作集少了一个</span></span>
<span class="line"><span>R.push(b)                   // 把它压到“移除栈”顶</span></span>
<span class="line"><span>A[b] = N                    // 记录删它时的 W 大小</span></span>
<span class="line"><span>// 从 W 列表里把 b “踢出去”，在 W/L 数组中，用尾部桶替换位置 L[b]</span></span>
<span class="line"><span>W[L[b]] = W[N]              // 用最后一个在线桶号填补 b 原来的位置</span></span>
<span class="line"><span>K[b] = W[N]                 // 后继指向这个尾部桶</span></span>
<span class="line"><span>// 更新被搬来的桶在 W 中的新位置</span></span>
<span class="line"><span>L[ W[N] ] = L[b]</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>新增桶的操作，伪代码如下：</p><div class="language- line-numbers-mode" data-highlighter="shiki" data-ext="" data-title="" style="--shiki-light:#24292e;--shiki-dark:#abb2bf;--shiki-light-bg:#fff;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes github-light one-dark-pro vp-code"><code><span class="line"><span>// 1. 弹出最近删除的桶 b</span></span>
<span class="line"><span>idx := len(r.R) - 1</span></span>
<span class="line"><span>b := r.R[idx]</span></span>
<span class="line"><span>r.R = r.R[:idx]</span></span>
<span class="line"><span></span></span>
<span class="line"><span>// 2. 恢复在线状态 A[b]=0</span></span>
<span class="line"><span>r.A[b] = 0</span></span>
<span class="line"><span></span></span>
<span class="line"><span>// 3. 在 W/L 数组末尾还原 b</span></span>
<span class="line"><span>W, L, K := r.W, r.L, r.K</span></span>
<span class="line"><span>W[r.N], K[b] = b, b    // 在尾部写回桶 b，后继指向自己</span></span>
<span class="line"><span>L[b] = r.N             // 位置映射到 N</span></span>
<span class="line"><span></span></span>
<span class="line"><span>// 4. 在线桶数 N++</span></span>
<span class="line"><span>r.N++</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>那么，我们可以简单总结：</p><ul><li>删除时，我们用尾部桶来填补被删桶在 W 中的位置，保持 W 数组紧凑；同时记录在删除时的在线桶数和后继指针，供查询时“回退”使用</li><li>添加时，直接从栈中把最近删除的桶恢复到尾部，后继指针置回自身；栈的先进后出性质保证“回退重哈希”能正确对应到上一次删除的集合</li><li>整个过程只修改少量数组元素和栈操作，都是 <code>O(1)</code> 时间，不会随着桶数量增长而变慢。</li><li>查询时结合这些状态，即可在需要的时候回退到正确的工作子集，保证最小扰动和均衡分布</li></ul><p>AnchorHash可以支持任意添加和删除节点，其节点数据的备份迁移也比较简单，即重新对key执行哈希即可。</p><h4 id="_2-优缺点-2" tabindex="-1"><a class="header-anchor" href="#_2-优缺点-2"><span>(2). 优缺点</span></a></h4><p>优点：</p><ul><li>严格最小扰动：理论上保证只有被移除节点上的 key 才需要重映射</li><li>查询高效：平均接近 <code>O(1)</code></li><li>内存占用低：仅需 <code>O(N)</code> 空间占用。其中 N 为最大规划节点数。</li><li>支持任意增删</li></ul><p>缺点：</p><ul><li>AnchorHash 需要对集群大小有所规划，这就限制了集群的上限，无法进行扩容。</li><li>此算法是有状态的，节点状态变更（增删）操作非幂等，需串行之行，无法对集群状态进行并行更新</li></ul><h3 id="_6-dxhash" tabindex="-1"><a class="header-anchor" href="#_6-dxhash"><span>6. DxHash</span></a></h3><p>论文：<a href="https://arxiv.org/pdf/2107.07930" target="_blank" rel="noopener noreferrer">https://arxiv.org/pdf/2107.07930</a></p><p>论文中提到，DxHash 旨在兼顾六项关键特征：一致性、最小扰动、负载均衡、高查询吞吐、低内存开销、快速更新。</p><h4 id="_1-核心算法-1" tabindex="-1"><a class="header-anchor" href="#_1-核心算法-1"><span>(1). 核心算法</span></a></h4><p>DxHash 通过一个定长数组 NSArray 来表示集群中节点的状态。数组长度为：大于当前“集群中活跃节点数”的 2 的最小幂。比如当前活跃节点数是4，则 NSArray 的长度为8。</p><blockquote><p>为什么是 2的幂？</p><ul><li>能保证随机数分布更加均匀，尤其是伪随机数取模场景</li><li>方便支持快速扩容，DxHash扩容时会直接把数组长度翻倍</li><li>还有的话，就是便于位运算优化（如掩码 <code>r&amp;(n-1)</code>替代 <code>r%n</code>），提升查找效率</li></ul></blockquote><p>我们直接使用论文中的图示来直观展示。如下图a中，NSArray数组中包含活跃节点0，1，2，3；其他位置为非活跃节点，包括：4，5，6，7。NSArray数组使用状态位来标识节点的活跃情况。</p><img src="`+r+`" alt="s" style="zoom:50%;"><h5 id="a-查找" tabindex="-1"><a class="header-anchor" href="#a-查找"><span>(a). 查找</span></a></h5><p>DxHash 使用伪随机数生成器 PRNG 来将请求key映射到节点上。</p><blockquote><p>伪随机数生成器（PRNG，Pseudo-Random Number Generator）是一类通过确定性算法，利用有限状态和初始种子（seed）生成“看似随机”数列的工具。虽然输出并非真正的随机（可预测、可重现），但在大多数工程应用中，PRNG 的统计特性足够“随机”，且具备高效、可控、可复现等优点。即当种子相同时可以再次生成相同的序列。</p></blockquote><p>查找过程如下：</p><ul><li>将请求key作为 PRNG 的种子。不断的调用 PRNG，然后取模 n（NSArray数组长度）。最终得到一个随机的节点Id序列S，序列中包含活跃节点和非活跃节点。</li><li>从序列S中依次选取节点，碰到第一个活跃节点即返回</li></ul><div class="language-c++ line-numbers-mode" data-highlighter="shiki" data-ext="c++" data-title="c++" style="--shiki-light:#24292e;--shiki-dark:#abb2bf;--shiki-light-bg:#fff;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes github-light one-dark-pro vp-code"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#C678DD;">uint32_t</span><span style="--shiki-light:#6F42C1;--shiki-dark:#61AFEF;"> getNodeID</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">(</span><span style="--shiki-light:#D73A49;--shiki-dark:#C678DD;">uint32_t</span><span style="--shiki-light:#E36209;--shiki-dark:#E06C75;--shiki-light-font-style:inherit;--shiki-dark-font-style:italic;"> key</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">, </span><span style="--shiki-light:#D73A49;--shiki-dark:#C678DD;">uint32_t*</span><span style="--shiki-light:#E36209;--shiki-dark:#E06C75;--shiki-light-font-style:inherit;--shiki-dark-font-style:italic;"> numHash</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">){</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#C678DD;">    uint32_t</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;"> key2 </span><span style="--shiki-light:#D73A49;--shiki-dark:#C678DD;">=</span><span style="--shiki-light:#6F42C1;--shiki-dark:#61AFEF;"> gen32bitRandNumber</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">(key);</span><span style="--shiki-light:#6A737D;--shiki-dark:#7F848E;--shiki-light-font-style:inherit;--shiki-dark-font-style:italic;">     // 通过key生成一个随机种子key2</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#C678DD;">    uint32_t</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;"> bs </span><span style="--shiki-light:#D73A49;--shiki-dark:#C678DD;">=</span><span style="--shiki-light:#6F42C1;--shiki-dark:#61AFEF;"> crc32c_sse42_u64</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">(key, key2);</span><span style="--shiki-light:#6A737D;--shiki-dark:#7F848E;--shiki-light-font-style:inherit;--shiki-dark-font-style:italic;">   // 通过key和种子生成第一个id</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#C678DD;">    uint32_t</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;"> index </span><span style="--shiki-light:#D73A49;--shiki-dark:#C678DD;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;"> bs </span><span style="--shiki-light:#D73A49;--shiki-dark:#56B6C2;">%</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;"> size;</span><span style="--shiki-light:#6A737D;--shiki-dark:#7F848E;--shiki-light-font-style:inherit;--shiki-dark-font-style:italic;">                  // 通过对id取模获取节点的索引</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#C678DD;">    uint32_t</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;"> i </span><span style="--shiki-light:#D73A49;--shiki-dark:#C678DD;">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#D19A66;"> 1</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">;</span><span style="--shiki-light:#6A737D;--shiki-dark:#7F848E;--shiki-light-font-style:inherit;--shiki-dark-font-style:italic;">                              // 将初始的哈希次数设置为1</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#C678DD;">    while</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">(</span><span style="--shiki-light:#D73A49;--shiki-dark:#56B6C2;">!</span><span style="--shiki-light:#24292E;--shiki-dark:#E5C07B;">nodes</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">[index]){</span><span style="--shiki-light:#6A737D;--shiki-dark:#7F848E;--shiki-light-font-style:inherit;--shiki-dark-font-style:italic;">                        // 查询index所在的节点是否是活动节点，如果是，则返回该节点索引，否则继续重复上述操作</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">        bs </span><span style="--shiki-light:#D73A49;--shiki-dark:#C678DD;">=</span><span style="--shiki-light:#6F42C1;--shiki-dark:#61AFEF;"> crc32c_sse42_u64</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">(bs, key2);</span><span style="--shiki-light:#6A737D;--shiki-dark:#7F848E;--shiki-light-font-style:inherit;--shiki-dark-font-style:italic;">         // 再次生成id并取模</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">        index </span><span style="--shiki-light:#D73A49;--shiki-dark:#C678DD;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;"> bs </span><span style="--shiki-light:#D73A49;--shiki-dark:#56B6C2;">%</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;"> size;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">        i </span><span style="--shiki-light:#D73A49;--shiki-dark:#C678DD;">+=</span><span style="--shiki-light:#005CC5;--shiki-dark:#D19A66;"> 1</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">;</span><span style="--shiki-light:#6A737D;--shiki-dark:#7F848E;--shiki-light-font-style:inherit;--shiki-dark-font-style:italic;">                                  // 每查找一次，增加哈希计数</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#C678DD;">        if</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;"> (i </span><span style="--shiki-light:#D73A49;--shiki-dark:#C678DD;">&gt;=</span><span style="--shiki-light:#005CC5;--shiki-dark:#D19A66;"> 8</span><span style="--shiki-light:#D73A49;--shiki-dark:#56B6C2;"> *</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;"> size){</span><span style="--shiki-light:#6A737D;--shiki-dark:#7F848E;--shiki-light-font-style:inherit;--shiki-dark-font-style:italic;">                      // 查找次数达到上限，查找失败，返回错误</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#C678DD;">            return</span><span style="--shiki-light:#D73A49;--shiki-dark:#56B6C2;"> -</span><span style="--shiki-light:#005CC5;--shiki-dark:#D19A66;">1</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">        }</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">    };</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#56B6C2;">    *</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">numHash </span><span style="--shiki-light:#D73A49;--shiki-dark:#C678DD;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;"> i;</span><span style="--shiki-light:#6A737D;--shiki-dark:#7F848E;--shiki-light-font-style:inherit;--shiki-dark-font-style:italic;">                                // 出参numHash表示总的哈希次数</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#C678DD;">    return</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;"> index;</span><span style="--shiki-light:#6A737D;--shiki-dark:#7F848E;--shiki-light-font-style:inherit;--shiki-dark-font-style:italic;">                                // 返回节点索引</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">}</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>如图所示代码中，有一个查询上限 <code>i &gt;= 8*size</code>。论文中提到，因为 PRNG 并不是真正随机，可能存在极少数请求键连续落入空闲槽。因此算法中设置一个查找上限 8n，超过则强制终止并抛弃或特殊处理，旨在平衡查询效率和匹配效率。理论上，未命中任何活跃位的概率为：<br> $$<br> P=(\\frac{n-1}{n})^{8n} ≈ e^{-8} ≈ 0.0003<br> $$<br> 即可能存在 0.03% 的请求键会受到影响。</p><h5 id="b-节点的更新" tabindex="-1"><a class="header-anchor" href="#b-节点的更新"><span>(b). 节点的更新</span></a></h5><p>NSArray的长度通常会大于集群节点数。</p><ul><li>当新增一个节点时，会将NSArray数组对应节点位置的状态置为“活跃状态”。</li><li>当移除一个节点时，对应的，将NSArray数组中对应节点位置的状态置为“非活跃状态”</li></ul><p>新增节点或者移除节点后，查找序列S中对应的某些节点的活跃状态会变化。这样，如图b和c所示。新增节点便可以抢到一些请求；移除节点便可以释放请求。</p><h5 id="c-节点扩缩容" tabindex="-1"><a class="header-anchor" href="#c-节点扩缩容"><span>(c). 节点扩缩容</span></a></h5><p>当 NSArray 中活跃节点数接近 n 时，会将数组长度翻倍为 2n，新增的数组索引全部初始化为空闲。此时需重新映射约50%的请求key。</p><p>当 NSArray 中活跃节点数空闲率过高时，会将数组长度缩小。由于缩容时，会带来更多的重映射。因此根据场景只有在空闲率非常低的时候才可以启动缩容。</p><h4 id="_2-优缺点-3" tabindex="-1"><a class="header-anchor" href="#_2-优缺点-3"><span>(2). 优缺点</span></a></h4><p>优点：</p><ul><li>无状态查询</li><li>支持任意增删</li><li>内存占用相对固定</li></ul><p>缺点：</p><ul><li>存在查找边界：DxHash存在查找边界问题，即如果集群较小的情况下，可能会出现无法为key找到活动节点的问题。</li><li>扩缩容扰动较大：尽管DxHash支持扩缩容，但仍然建议初始化时使用足够大的NSArray，避免对象重映射带来的迁移问题。</li><li>建议初始化的较大的数组长度：减少扩容频率和影响。</li></ul><h3 id="_7-其他算法" tabindex="-1"><a class="header-anchor" href="#_7-其他算法"><span>7. 其他算法</span></a></h3><p>还有很多一致性哈希算法，都有提出一些新的思路。</p><p>MementoHash： <a href="https://arxiv.org/html/2306.09783v3" target="_blank" rel="noopener noreferrer">https://arxiv.org/html/2306.09783v3</a></p><p>BinomialHash：<a href="https://www.semanticscholar.org/reader/e3b51975a2ea5d4a50b3dc621c27a608db0c782c" target="_blank" rel="noopener noreferrer">https://www.semanticscholar.org/reader/e3b51975a2ea5d4a50b3dc621c27a608db0c782c</a></p><h2 id="三、需求" tabindex="-1"><a class="header-anchor" href="#三、需求"><span>三、需求</span></a></h2><p>我们CDN缓存节点的场景基本如下：</p><img src="`+k+'" style="zoom:33%;"><p>用户请求 key 来了先选择机房、然后再选择机房中某个机器。然后通过这个机器去下载请求key对应的文件。重点来论述一下“用户请求 key 来了之后选择机房”的场景。</p><p>前提条件：</p><ul><li>请求key命中某个机房时 <ul><li>每次请求都要下载文件，都会产生跑量带宽。</li><li>如果命中机器缓存，则直接返回用户。</li><li>如果未命中机器缓存，则机器需要进行回源下载文件并缓存，然后返回给用户。回源会产生回源网络带宽。</li><li>可能会存在较多相同的请求key，如果都打到某台机器的话，会产生大量跑量带宽</li></ul></li><li>机房的能力 <ul><li>机器的内存缓存有限，内部回源网络带宽有限，机房的跑量带宽有限。</li><li>不同场景下希望每个机房承接一部分无耦合的请求 key。比如A机房承接30%的文件比。</li><li>机房的文件比大小，会影响：机房的缓存命中率、机房回源带宽、机房的跑量带宽</li><li>请求key的数量多少，会影响：机房跑量带宽</li></ul></li></ul><p>需求：</p><ul><li>我们希望机房跑量带宽最高，同时机房的缓存命中率最高，同时机房的回源带宽最小。在这三个指标中达到均衡。</li><li>由于请求key的数量在变动，且变动幅度较大。因此机房承接的文件比也有对应的变动。比如A机房低峰期承接30%的文件比，高峰期可能只能承接10%的文件比。 <ul><li>重要的是文件比变动后，对应的槽位必须是灰度增加或减少。且灰度时间和灰度槽位数需要可控、配置化、可人工介入。</li></ul></li><li>保证负载均衡，务必按照设置的文件比进行分配。需要精确度保证，30%的文件比一定只有30%的文件，不能有超过1%的误差。</li><li>文件比总和可以超过100%，请求key命中某槽位后，此槽位可以返回多个机房。（机房之间有优先级，存在备份机房）</li><li>某机房故障剔除后，不能直接将机房的文件/流量转移到其他机房，可能会打高其他机房的回源，极易造成雪崩。此时需要保证的不是最小扰动，而是无扰动。即使扰动是符合预期的，也需要有灰度、可控、配置化、人工介入的机制。</li><li>同理，新上线机房也不能对原有机房产生影响</li><li>需要有较高的查询吞吐，能够快速完成 key-&gt;node 的映射。</li><li>需要低资源占用，对CPU、内存等资源都有较小的占用，避免因内存过载导致的性能退化 。以及在状态变化（节点故障／恢复、集群扩缩容）时，算法必须在占用较小资源的情况下快速完成变更。</li><li>有一点是，如果变更引起了某槽位没有节点，则可以返回空，会兜底到三方厂商。</li></ul><p>对于如上我们CDN的场景，要求非常严格，任何变动都需要灰度完成，并且提供人工介入的机制。并且对于查询性能、占用资源情况要求严苛，业界的一致性哈希算法无法直接落地。</p><p>因此我们针对我们的场景，自研了“离散型槽位哈希”，保证一致性哈希要求的同时，融入工程化求解思路，完美支持了我们CDN的场景。</p><h2 id="四、自研离散型槽位哈希" tabindex="-1"><a class="header-anchor" href="#四、自研离散型槽位哈希"><span>四、自研离散型槽位哈希</span></a></h2><p>针对我们的场景，我们自研了一款 “离散型槽位一致性哈希”，能够在固定数量的槽位空间内，将节点按照权重分配到每个槽位，并提供：</p><ul><li><strong>快速查询</strong>：键通过一次哈希定位到槽位，再直接返回该槽位的节点列表，时间复杂度 <code>O(1)</code>。</li><li><strong>动态增删</strong>：节点增删和权重变更时仅局部调整槽位分配，操作复杂度接近 <code>O(log⁡S)</code>（S 为槽位数），远优于哈希环的虚拟节点重构。</li><li><strong>负载均衡</strong>：每个节点在全体槽位上有随机打分，根据节点权重计算“配额”，以加权方式分配槽位，保证节点最终获得的槽位数与权重成正比。</li><li><strong>最小扰动</strong>：只有增删节点或调整配额时，节点才在有限数量的槽位上做分配/释放，其他键映射保持不变。</li></ul><p>下面，我们详细剖析下 SlotHash 的底层实现、负载均衡原理以及工程实践。帮读者理解清楚其设计思路和应用价值。</p><h3 id="_1-数据结构" tabindex="-1"><a class="header-anchor" href="#_1-数据结构"><span>1. 数据结构</span></a></h3><p>我们会使用数组作为基础数据结构，根据节点之间的权重，让不同节点填充对应数量的槽位。</p><img src="'+c+`" style="zoom:50%;"><p>这里会出现两个问题。</p><ul><li>每个槽位如何分配节点？以及节点的权重如何体现？</li><li>扩缩容场景下，如何保证最小扰动？</li></ul><h3 id="_2-节点和槽位的映射" tabindex="-1"><a class="header-anchor" href="#_2-节点和槽位的映射"><span>2. 节点和槽位的映射</span></a></h3><p>我们需要对每个槽位选择一个后端节点，并且要尽可能公平，且槽位的数量要和后端节点的权重挂钩。我是这样做的。</p><p>使用槽位和节点这两个输入，求一个哈希值。计算每个节点在每个槽位的哈希值。然后进行离散化，取得每个节点在每个槽位的打分。计算方式如下：</p><div class="language-go line-numbers-mode" data-highlighter="shiki" data-ext="go" data-title="go" style="--shiki-light:#24292e;--shiki-dark:#abb2bf;--shiki-light-bg:#fff;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes github-light one-dark-pro vp-code"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#C678DD;">func</span><span style="--shiki-light:#6F42C1;--shiki-dark:#61AFEF;"> getNodeSlotScore</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">(</span><span style="--shiki-light:#E36209;--shiki-dark:#E06C75;--shiki-light-font-style:inherit;--shiki-dark-font-style:italic;">hashFunc</span><span style="--shiki-light:#6F42C1;--shiki-dark:#E5C07B;"> HashFuncType</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">, </span><span style="--shiki-light:#E36209;--shiki-dark:#E06C75;--shiki-light-font-style:inherit;--shiki-dark-font-style:italic;">nodeKey</span><span style="--shiki-light:#D73A49;--shiki-dark:#C678DD;"> string</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">) []</span><span style="--shiki-light:#D73A49;--shiki-dark:#C678DD;">float64</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;"> {</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E06C75;">	slotScores</span><span style="--shiki-light:#D73A49;--shiki-dark:#E5C07B;"> :=</span><span style="--shiki-light:#6F42C1;--shiki-dark:#61AFEF;"> make</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">([]</span><span style="--shiki-light:#D73A49;--shiki-dark:#C678DD;">float64</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">, </span><span style="--shiki-light:#24292E;--shiki-dark:#E06C75;">defaultSlotNum</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">)</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#C678DD;">	for</span><span style="--shiki-light:#24292E;--shiki-dark:#E06C75;"> slot</span><span style="--shiki-light:#D73A49;--shiki-dark:#E5C07B;"> :=</span><span style="--shiki-light:#005CC5;--shiki-dark:#D19A66;"> 0</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">; </span><span style="--shiki-light:#24292E;--shiki-dark:#E06C75;">slot</span><span style="--shiki-light:#D73A49;--shiki-dark:#56B6C2;"> &lt;</span><span style="--shiki-light:#24292E;--shiki-dark:#E06C75;"> defaultSlotNum</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">; </span><span style="--shiki-light:#24292E;--shiki-dark:#E06C75;">slot</span><span style="--shiki-light:#D73A49;--shiki-dark:#56B6C2;">++</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;"> {</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E06C75;">		score</span><span style="--shiki-light:#D73A49;--shiki-dark:#E5C07B;"> :=</span><span style="--shiki-light:#6F42C1;--shiki-dark:#61AFEF;"> getHashScore</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">(</span><span style="--shiki-light:#24292E;--shiki-dark:#E06C75;">hashFunc</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">, </span><span style="--shiki-light:#24292E;--shiki-dark:#E06C75;">nodeKey</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">, </span><span style="--shiki-light:#24292E;--shiki-dark:#E06C75;">slot</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">)</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E06C75;">		slotScores</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">[</span><span style="--shiki-light:#24292E;--shiki-dark:#E06C75;">slot</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">] </span><span style="--shiki-light:#D73A49;--shiki-dark:#E5C07B;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#E06C75;"> score</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">	}</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#C678DD;">	return</span><span style="--shiki-light:#24292E;--shiki-dark:#E06C75;"> slotScores</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">}</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#C678DD;">func</span><span style="--shiki-light:#6F42C1;--shiki-dark:#61AFEF;"> getHashScore</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">(</span><span style="--shiki-light:#E36209;--shiki-dark:#E06C75;--shiki-light-font-style:inherit;--shiki-dark-font-style:italic;">hashFunc</span><span style="--shiki-light:#6F42C1;--shiki-dark:#E5C07B;"> HashFuncType</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">, </span><span style="--shiki-light:#E36209;--shiki-dark:#E06C75;--shiki-light-font-style:inherit;--shiki-dark-font-style:italic;">nodeKey</span><span style="--shiki-light:#D73A49;--shiki-dark:#C678DD;"> string</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">, </span><span style="--shiki-light:#E36209;--shiki-dark:#E06C75;--shiki-light-font-style:inherit;--shiki-dark-font-style:italic;">slot</span><span style="--shiki-light:#D73A49;--shiki-dark:#C678DD;"> int</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">) </span><span style="--shiki-light:#D73A49;--shiki-dark:#C678DD;">float64</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;"> {</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E06C75;">	nodeSlot</span><span style="--shiki-light:#D73A49;--shiki-dark:#E5C07B;"> :=</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;"> []</span><span style="--shiki-light:#D73A49;--shiki-dark:#C678DD;">byte</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">(</span><span style="--shiki-light:#24292E;--shiki-dark:#E06C75;">nodeKey</span><span style="--shiki-light:#D73A49;--shiki-dark:#C678DD;"> +</span><span style="--shiki-light:#032F62;--shiki-dark:#98C379;"> &quot;_&quot;</span><span style="--shiki-light:#D73A49;--shiki-dark:#C678DD;"> +</span><span style="--shiki-light:#24292E;--shiki-dark:#E06C75;"> strconv</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#61AFEF;">Itoa</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">(</span><span style="--shiki-light:#24292E;--shiki-dark:#E06C75;">slot</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">))</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E06C75;">	rawHash</span><span style="--shiki-light:#D73A49;--shiki-dark:#E5C07B;"> :=</span><span style="--shiki-light:#6F42C1;--shiki-dark:#61AFEF;"> hashFunc</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">(</span><span style="--shiki-light:#24292E;--shiki-dark:#E06C75;">nodeSlot</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">)</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#7F848E;--shiki-light-font-style:inherit;--shiki-dark-font-style:italic;">	// h 的取值范围是 [0, 2^64-1]。加1后是 [1, 2^64]</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#7F848E;--shiki-light-font-style:inherit;--shiki-dark-font-style:italic;">	// 将哈希值规整到范围 (0, 1]</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E06C75;">	normalizedHash</span><span style="--shiki-light:#D73A49;--shiki-dark:#E5C07B;"> :=</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;"> (</span><span style="--shiki-light:#D73A49;--shiki-dark:#C678DD;">float64</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">(</span><span style="--shiki-light:#24292E;--shiki-dark:#E06C75;">rawHash</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">) </span><span style="--shiki-light:#D73A49;--shiki-dark:#C678DD;">+</span><span style="--shiki-light:#005CC5;--shiki-dark:#D19A66;"> 1</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">) </span><span style="--shiki-light:#D73A49;--shiki-dark:#C678DD;">/</span><span style="--shiki-light:#D73A49;--shiki-dark:#C678DD;"> float64</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">(</span><span style="--shiki-light:#24292E;--shiki-dark:#E06C75;">math</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">.</span><span style="--shiki-light:#24292E;--shiki-dark:#E06C75;">MaxUint64</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">)</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E06C75;">	logScore</span><span style="--shiki-light:#D73A49;--shiki-dark:#E5C07B;"> :=</span><span style="--shiki-light:#005CC5;--shiki-dark:#D19A66;"> 1.0</span><span style="--shiki-light:#D73A49;--shiki-dark:#C678DD;"> /</span><span style="--shiki-light:#D73A49;--shiki-dark:#C678DD;"> -</span><span style="--shiki-light:#24292E;--shiki-dark:#E06C75;">math</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#61AFEF;">Log</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">(</span><span style="--shiki-light:#24292E;--shiki-dark:#E06C75;">normalizedHash</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">)</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#C678DD;">	return</span><span style="--shiki-light:#24292E;--shiki-dark:#E06C75;"> logScore</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">}</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>打分函数采用经典的做法，如下公式，近似指数分布。确保打分无偏且具备统计特性。<br> $$<br> \\frac{1}{-log(r)}<br> $$<br> 此时，我们拿到了每个节点对于每个槽位的打分了。</p><p>于是，我们可以知道每个槽位上，分配节点的优先级了，也就是说某槽位上打分越高的节点，越有机会占据此槽位。</p><p>但是，我们还要考虑节点之间的权重。我们举个例子来说明下这里的算法。</p><p>假设节点之间的权重为 <code>20%:30%:50%</code>（节点的权重加和可以不等于100%，大于或者小于100%都可以），然后一共有10个槽位。那为了保证节点权重符合预期。各节点所占的槽位也应该是 <code>2:3:5</code>。然后我们对各个节点的的槽位分数进行排序，得到降序排序的索引列表。</p><ul><li>我们先算出来每个节点在每个槽位上的得分，然后按照节点的得分降序排序。</li><li>我们先填充 N1 的槽位，N1 应该填充 2 个槽位。按照得分的降序，此时依次填充 2、6 两个槽位。</li><li>再填充 N2 的槽位，N2 应该填充 3 个槽位。按照得分的降序，此时依次填充 1、7、8 三个槽位。</li><li>最后填充 N3 的槽位，N3 应该填充 5 个槽位。按照得分的降序，此时应该依次填充 3、4、5、9、10 四个槽位。如果某个槽位被占据了则继续向后找。</li></ul><img src="`+o+'" style="zoom:50%;"><p>这样，只要每个节点在每个槽位的打分足够均匀，足够离散。那最终每个槽位的节点映射便会足够均匀随机。而且节点所占据的槽位数量严格和节点的权重对应。</p><h3 id="_3-节点槽位的变化场景" tabindex="-1"><a class="header-anchor" href="#_3-节点槽位的变化场景"><span>3. 节点槽位的变化场景</span></a></h3><p>节点所占据的槽位变化的场景，包括：扩容场景（新上线节点）、缩容场景（节点下线）、节点权重调整场景。</p><p>“新上线节点”和“节点权重增加”这两种场景是同质化的操作，新节点上线相当于节点的权重从0调整到某一定值，算法需要抢占槽位。</p><p>“节点下线”和“节点权重减小”这两种场景是同质化操作，节点下线相当于节点的权重减小到0，算法需要释放槽位。</p><p>在节点槽位的变化场景中，我们需要保证的是最小扰动。即某个节点的上下线，不会影响到其他节点，且需要迁移的请求key要尽可能少。这是普通的一致性哈希所需要满足的性质。</p><h4 id="_1-节点抢占槽位" tabindex="-1"><a class="header-anchor" href="#_1-节点抢占槽位"><span>(1). 节点抢占槽位</span></a></h4><p>节点的权重调整过程，我们需要保证变动的槽位尽可能少，并且只应该影响调整的节点。</p><p>我们借着上面的例子继续阐述，假设节点1 的权重我希望从 2 变成 4。即节点1 所占用的槽位应该从 2 个变成 4个。此时我们要去抢占哪些槽位呢？让我阐述下这块的算法。</p><ul><li>为了满足单调性，即没有变化的节点不应该有槽位的变动。</li><li>权重变化的节点，我们应该以较为平滑的算法去让他抢占槽位</li></ul><p>抢占逻辑概括来说，就是让节点优先占据“剩余最空”、“对自己最有利”的槽位。玩法如下：</p><ul><li>对于节点1 计算每个槽位的 slotDiff 列表。列表中的元素包含三个字段。分别是： <ul><li>槽位索引</li><li>槽位当前的节点数</li><li>打分差值，<code>scoreDiff = 节点当前的槽位打分-当前槽位所有节点的最高打分</code>。则 scoreDiff 值最大为0（此节点就是当前槽位的最高打分）</li></ul></li><li>列表中会剔除部分槽位：这些槽位中已有节点1了</li><li>然后进行排序，排序规则是：如果“槽位当前的节点数”相同，则打分差值越大排在前面。如果“槽位当前节点数”不同，则“槽位当前节点数”越少会排在前面。</li><li>最后会去填充槽位。就可以实现先填充节点数量少的槽位，再填充分值较大的槽位</li></ul><img src="'+g+'" style="zoom:50%;"><p>总而言之，第一步找节点数量较少的槽位去填充；第二步找得分最高的槽位去填充。保证槽位上的节点数量均衡、且分布离散。（槽位数越多分布越离散）</p><h4 id="_2-节点释放槽位" tabindex="-1"><a class="header-anchor" href="#_2-节点释放槽位"><span>(2). 节点释放槽位</span></a></h4><p>当节点的权重减小，对应的槽位数量要进行减少，需要释放一部分槽位。释放槽位的逻辑概括来说：让节点优先释放“最拥挤”或“对自己最不重要”的槽位。假设节点3的槽位要从 5 变成3。 玩法如下：</p><ul><li>对于节点3来说，计算节点所在槽位的 slotScore 列表，列表中的元素有三个字段，分别是： <ul><li>槽位索引</li><li>槽位当前的节点数</li><li>当前节点槽位的打分</li></ul></li><li>列表中只会保留有此节点的槽位。</li><li>然后进行排序，排序规则是：如果槽位上节点数量相同，则分数越低越优先释放；如果槽位上节点数量不同，则节点数量越多越优先释放。</li><li>最后按照排序后的序列，再去释放对应数量的槽位数量。</li></ul><img src="'+u+'" style="zoom:50%;"><p>总之，第一步找节点数量较多的槽位去释放；第二步找得分最低的槽位去释放节点。保证槽位上节点数量严格按照权重来执行。</p><h3 id="_4-槽位上节点数量" tabindex="-1"><a class="header-anchor" href="#_4-槽位上节点数量"><span>4. 槽位上节点数量</span></a></h3><p>如上的操作我们可以看出，一个槽位上可以有多个节点，也可以没有节点。</p><ul><li>多个节点的槽位，请求key命中此槽位时，算法会返回所有节点。需要工程上做进一步的分发流量。</li><li>没有节点的槽位，请求key命中此槽位时，算法会返回空。需要工程上做兜底修补。算法上不做修补，做到严格不扰动。</li></ul><img src="'+b+'" style="zoom:50%;"><p>我们为了保证算法的完全单调和最小扰动。将节点权重变动后产生的问题，放在后置的工程侧去处理。这样就能适用于更加灵活可控的场景。</p><p>为什么要这么设计呢？</p><ul><li><p><strong>完全的单调性</strong>：我们的后端节点一般都是缓存型的，槽位中节点的变化，一定会经历缓存的失效，而缓存失效就会产生回源。如果有太大的回源就会对整个系统产生影响，甚至产生雪崩。因此，我们需要的是A节点的变化，必须不能影响到其他节点的缓存变化。</p><ul><li>业界所有的一致性哈希算法，比如某节点的权重减小，一定会导致其他节点的权重增加、缓存变化。这些算法都在追求将多出来的流量分摊的更均衡。且需要较多的系统资源支持，比如较多的虚拟节点数。某些算法甚至不支持节点的权重。</li><li>自研离散型槽位哈希算法，以工程的思路去求解。A节点的权重变化，只去操作A节点的槽位，不会操作其他节点的槽位，也就不会影响其他节点的缓存。</li></ul></li><li><p><strong>真正的最小扰动</strong>：我们需要保证节点的权重和节点所占的槽位数量完全映射。比如节点的权重为30%，槽位总数为10个的情况下，此节点一定占据3个槽位，不会多也不会少。</p><ul><li>这里我们先做一个定义。当算法的上游输入去改变节点的权重时，一致性哈希需要保证的是“最小扰动”。也即变更此节点一定数量的槽位，并且此数量一定是可控的、符合预期的。</li><li>其他的一致性哈希算法对于此场景，要么依赖于较多的虚拟节点数量（哈希环）；要么依赖于哈希算法的离散性（rendezvous-hash、maglev-hash、jump-consistent-hash）。做不到完全精准，只能说是控制了一定程度的误差。对精度要求较高的场景，我们认为节点权重的调整，带来的扰动不可控。<br> 比如虚拟节点数较少的情况下，将节点的权重从50调整到30。也许对应的哈希环上此此节点的虚拟节点会从50调整到28或者33。无法完全按照我们的实际预期调整。</li><li>而自研离散型槽位哈希算法，严格按照上游输入去改变槽位，做到了零扰动。做到了完全可控。</li></ul></li></ul><p>这里就会产生一个问题，也就是槽位上节点的平衡分布问题，要让每个槽位上节点数量处于一个均衡的水平。最极端的场景下，一个槽位上填充了所有节点，但其他槽位上没有节点。我们需要保证的是槽位上节点数量的差值不超过1个。我们的做法是“槽位重平衡”。</p><h3 id="_5-槽位重平衡" tabindex="-1"><a class="header-anchor" href="#_5-槽位重平衡"><span>5. 槽位重平衡</span></a></h3><p>在槽位重平衡流程中，简单来说就是把节点数量较多的槽位上的节点移动到空槽位或者节点数量较少的槽位上。保证槽位上节点数量的最大值和最小值的差值不超过1个。玩法如下：</p><ul><li>我们会遍历所有槽位的节点数量情况。记录大于1个节点的槽位和空槽位</li><li>对于“多节点槽位”按照节点数量进行排序，优先处理节点数量较多的槽位</li><li>对于某个槽位，我们要迁移那个节点呢？我们会按照此槽位中节点的打分进行排序，得分越低的节点将会被迁移。比如下图中：在槽位1中，节点1的得分是77，节点2的得分是225。那我们应该迁移节点1。</li><li>那么节点应该迁移到那个槽位呢？我们会按照槽位中节点数量排序，数量越少，优先级越高，空槽位的优先级最高。如下图，节点1被迁移到槽位9了。</li><li>整个迁移过程中，节点1的槽位数虽然没有变化，但是节点1所占据的槽位却发生了变化，这一定会影响到节点缓存。</li><li>因此我们的重平衡过程中，会有一些条件限制。比如：比如单次最多迁移2个槽位，1小时允许重平衡一次，只允许在规定时间段内进行重平衡。</li></ul><img src="'+y+'" style="zoom:50%;"><p>在重平衡前，</p><ul><li>槽位1所对应的请求key被分给了两个节点，可能会导致节点承载的请求key总数变少。比如请求key总共有100个，每个槽位分配10个请求key。预期节点1槽位有4个，分配40个请求key；预期节点2分配30个请求key。但实际上节点1和节点2总共只分了60个请求key。相当于这两个节点分配的请求小于可承载的请求，会产生节点资源浪费。</li><li>而槽位9所对应的请求key返回了空，导致某一部分请求key没有分配到预期的后端节点。</li></ul><p>重平衡后，</p><ul><li>我们可以杜绝空槽位，保证请求key都可以分配到预期的后端节点（假设基数为100，只要后端节点的权重总和大于等于100即可）。</li><li>保证每个槽位分配的后端节点数的差值不超过1，这样可以让每个后端节点尽可能承接预期数量的请求key。</li></ul><p>这样，我们通过灰度的方式，保证了请求key可以合理的哈希到后端节点，后端节点的权重和请求key之间满足线性的关系。</p><h2 id="五、-工程化落地" tabindex="-1"><a class="header-anchor" href="#五、-工程化落地"><span>五、 工程化落地</span></a></h2><p>算法解决的是“能否实现目标”？工程解决“到达目的地的最优路径”，即“如何高效、稳定、可控的实现目标”。</p><h3 id="_1-cdn点播架构" tabindex="-1"><a class="header-anchor" href="#_1-cdn点播架构"><span>1. CDN点播架构</span></a></h3><p>此算法主要落地于CDN点播这边的调度场景，我们先来看下CDN点播架构。</p><img src="'+B+'" style="zoom:50%;"><p>自建点播CDN共分为两层架构：边缘节点L1和缓存节点L2。其中，边缘节点是真正服务用户的节点。</p><p>其中边缘节点L1，机器分为接入机和存储机。</p><ul><li>接入机，配置大内存，用来对外提供服务并缓存文件。</li><li>存储机，配置大容量磁盘，用于缓存尽可能多的冷门文件，降低边缘节点的整体回源率，从而减少延迟，节省回源带宽。</li></ul><p>此算法主要落地于如图中的“调度服务”。主要是调度服务在处理自建边缘L1机房的场景。流程如下：</p><ul><li>用户请求下载短视频文件，请求调度服务</li><li>调度服务根据文件信息，在结合自建/三方CDN的资源信息。返回给用户CDN地址。选择自建的流程 <ul><li><strong>对于用户请求，根据“自研离散型槽位哈希算法”从多个边缘机房中选择一个机房</strong></li><li>机房选定之后，根据文件信息，再通过“经典一致性哈希算法”选择此机房中的某个接入机。</li><li>如果此接入机存在此文件，则直接返回；如果不存在，则一致性哈希选择机房中存储机进行回源。</li><li>后续流程如上图</li></ul></li><li>用户通过CDN地址下载短视频文件。</li></ul><p>我们希望的是尽可能将所有的请求都拦截在“接入机”，让其命中内存缓存。那具体如何应用算法选择机房呢？</p><h3 id="_2-核心输入" tabindex="-1"><a class="header-anchor" href="#_2-核心输入"><span>2. 核心输入</span></a></h3><p>在选择边缘机房时，我们先来确认一下算法都有哪些核心输入。</p><h4 id="_1-oc的文件分配比例" tabindex="-1"><a class="header-anchor" href="#_1-oc的文件分配比例"><span>(1). OC的文件分配比例</span></a></h4><p>因为我们接入机的内存缓存有限，因此只能承接部分“文件”(视频/图片)。这些文件都有一个ID标识。我们将这些ID归一化到 <code>[0, 10w]</code>这个区间。因此我们的输入输出就变成：</p><ul><li>输入是自建OC跑量限制、机房点播最大可跑带宽(参考机房回源能力)、机房直播带宽、机房静态带宽、OC中nc5机器跑静态的带宽、地区可控带宽</li><li>输出是自建OC的文件比</li></ul><img src="'+v+'" style="zoom:50%;"><p>我们拿到自建OC的文件比之后，再通过“离散型槽位哈希”算法即可将OC文件比离散的映射到 <code>[0,10w]</code> 这个区间。</p><h4 id="_2-oc的流量分配比例" tabindex="-1"><a class="header-anchor" href="#_2-oc的流量分配比例"><span>(2). OC的流量分配比例</span></a></h4><p>简单来说，就是一个省份运营商下有 X 可控带宽，有三个自建机房，有五个三方厂商。我们要把这些可控带宽如何分配？</p><p>我们采用“最小费用最大流算法”（MCMF算法），指导算出自建机房或三方厂商流量的分配结果。</p><blockquote><p>最小费用最大流算法：<a href="https://zh.wikipedia.org/wiki/%E6%9C%80%E5%B0%8F%E8%B4%B9%E7%94%A8%E6%9C%80%E5%A4%A7%E6%B5%81%E9%97%AE%E9%A2%98" target="_blank" rel="noopener noreferrer">https://zh.wikipedia.org/wiki/最小费用最大流问题</a></p></blockquote><figure><img src="'+m+'" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure><p>我们举个例子来阐述一下，假设广东移动有150G的可控带宽，有三个自建机房OC1、OC2、OC3，有一个三方厂商。经过MCMF算法进行计算之后。</p><ul><li>自建机房OC1的上限为60G。分配带宽50G。则流量分配比例为：<code>50G/150G=0.33</code></li><li>自建机房OC2的上限为30G。分配带宽30G。则流量分配比例为：<code>30G/150G=0.2</code></li><li>自建机房OC3的上限为50G。分配带宽40G。则流量分配比例为：<code>40G/150G=0.27</code></li><li>三方厂商的上限可以认为有500G。分配带宽30G。则流量分配比例为：<code>30G/150G=0.2</code></li></ul><p>分配比: 实际分配的带宽 / 地区的可控带宽。</p><p>这样，我们就可以得到某个地区的可控带宽，要分给自建机房或三方厂商的比例了。</p><h4 id="_3-机器的流量分配比例" tabindex="-1"><a class="header-anchor" href="#_3-机器的流量分配比例"><span>(3). 机器的流量分配比例</span></a></h4><p>针对自建机房，我们知道了给这个自建机房分配多少流量，但是自建机房中有多台机器，如何将这些流量合理的分配到这些机器上呢？我们按照机器的能力进行分配。假设机房OC1有三台机器，机房OC1分配了50G的带宽。</p><p><code>机器的分配带宽 = 机器的上限 * 机房的分配带宽 / 机器的上限加和</code></p><p><code>机器的分配比例 = 机器的上限 / 机器的上限加和</code></p><ul><li>机器1的上限为20G。分配带宽：<code>20G*50G/(20G+30G+10G)=16.7G</code>。分配比例：<code>20G/(20G+30G+10G)=0.33</code></li><li>机器2的上限为30G。分配带宽：<code>30G*50G/(20G+30G+10G)=25G</code>。分配比例：<code>30G/(20G+30G+10G)=0.5</code></li><li>机器3的上限为10G。分配带宽：<code>10G*50G/(20G+30G+10G)=8.3G</code>。分配比例：<code>10G/(20G+30G+10G)=0.17</code></li></ul><p>这样可以算出来某个机房中，某台机器可以分配多少带宽，以及机器的流量分配比例了。</p><h4 id="_4-机器的负反馈比例" tabindex="-1"><a class="header-anchor" href="#_4-机器的负反馈比例"><span>(4). 机器的负反馈比例</span></a></h4><p>由于CDN的下发链路和实际的用户请求CDN地址链路，中间链路较长，且经历了非常多的核心数据的转化、计算。导致外部输入的数据存在一定的误差，且此误差来自于多个团队、不同方向同学的贡献。因此我们需要根据实际的机器跑量情况做进一步调度校准。</p><p>我们可以拿到机器的网卡带宽，也即机器的实际跑量。我们将此网卡带宽作为参考，采用PID算法，来修正误差，进一步指导调度。</p><blockquote><p>PID算法：<a href="https://zh.wikipedia.org/wiki/PID%E6%8E%A7%E5%88%B6%E5%99%A8" target="_blank" rel="noopener noreferrer">https://zh.wikipedia.org/wiki/PID控制器</a></p></blockquote><figure><img src="'+A+'" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure><p>图中，<code>r(t)</code> 是给定值，<code>y(t)</code> 是系统的实际输出值，给定值与实际输出值构成控制偏差：<br> $$<br> e(t)=r(t)−y(t)<br> $$<br><code>e(t)</code> 作为 PID 控制的输入， 作为 PID 控制器的输出和被控对象的输入。 所以模拟 PID 控制器的 控制规律为<br> $$<br> u(t)=kp[e(t) + \\frac{1}{Ti} ∫e(t)dt + Td \\frac{de(t)}{dt} ]<br> $$<br> 其中，<code>Kp</code> 为控制器的比例系数，<code>Ti</code> 为控制器的积分时间，也称积分系数，<code>Td</code> 为控制器的微分时间，也称微分系数。</p><p>根据实际情况，使用线上大批量的数据样本进行训练，不同场景下采用不同的“控制比例系数、积分系数、微分系数”作为参数。可以有效的调节调度。</p><p>比如机器分配了20G的带宽，但通过负反馈进行调节之后，实际只能跑19G的带宽。此时我们便可以算出机器的负反馈比例了，即为：<code>19G/20G=0.95</code>。此时，我们即可通过负反馈比例进一步精准化的调度了。</p><h3 id="_3-算法落地" tabindex="-1"><a class="header-anchor" href="#_3-算法落地"><span>3. 算法落地</span></a></h3><p>我们当前的场景再来阐述一下。</p><ul><li>某个地区有一定的可控带宽，有多个自建机房和三方厂商。需要将流量分配给这些自建机房或三方厂商。</li><li>假设我们把文件(视频或图片)ID我们归一化到 <code>[0,100]</code>这个区间。</li><li>由于自建机房的接入机内存有限，接入机和存储机之间网络带宽有一定成本。我们需要尽可能复用缓存。因此我们期望机房之间的文件尽可能不重合。比如A机房承接 <code>[0, 30)</code>区间的文件，B机房承接 <code>[30,100]</code>区间的文件。以此来保证缓存的高复用率。</li><li>我们希望自建机房所承接的流量和自建机房所承接的文件区间尽可能达到均衡。 <ul><li>比如某地区的可控带宽有 150G，文件ID归一到 <code>[0,100]</code>区间后，每份文件区间的带宽大致有 1.5M。如果此地区某个机房可承接的带宽有50G。那理论上分配任意 33% 的文件区间即能产生50G的可控带宽。因此此机房的文件区间占比不要超过33%，保证机房跑量的同时，接入机和存储机之间回源带宽最小。</li><li>理论上，机房的文件区间占比越大，接入机和存储机之间的回源越大。当然还要看其他条件，比如机型、地区可控带宽等</li></ul></li><li>我们如果使用连续性区间比如 <code>[0, 30]</code>作为机房的文件区间。当出现机房扩缩容、机房的文件区间调整的场景时，处理逻辑将呈指数型爆炸，运维成本非常高。 <ul><li>某地区有三个机房，文件区间分别为：<code>A:[0, 20), B:[2w, 60), C:[60,100] </code>。此时如果扩容一个机房，就需要从其他机房挤出一些文件区间，比如：<code>A:[0,15), B:[15, 50), C:[50, 90), D:[90, 100]</code>。可以看到扩容一个机房，其他机房的文件区间都需要调整，产生的回源成本将非常大，运维需要计算维护的成本非常高。</li><li>机房的扩容、缩容、文件区间的调整，一定会影响到其他机房。变更影响不够单调。</li><li>某个三方厂商的文件区间为：<code>A:[0, 50]</code>，此厂商故障时，我们希望能够分给两个或多个厂商，保证故障转移的压力不会很大。则文件区间变成：<code>B:[0, 25), C:[25,50]</code>。如果在A厂商恢复之前，B厂商又故障了，则文件区间变成:<code>D:[0, 12), E:[13, 25), C:[25,50]</code>。以此类推，连续的文件区间将在多次故障之后变得非常离散，人工介入操作难，配置数量将非常多，运维成本非常高。</li></ul></li><li>我们使用文件比（一个百分比）来代替文件区间。对外呈现的操作更加简单，运维成本降低。由算法保证变更的单调性和稳定性。</li></ul><p>场景我们梳理清楚后，我们来看下“离散型槽位哈希算法”是如何工程实践落地的。</p><p>假设机房的文件比分别为：<code>node1:30%, node2: 20%, node3: 40%</code>。假设槽位总数由10个。也即机房分配的槽位数：<code>node1:3个, node2:2个, node3:4个</code>。如下图，是经过多次机房权重调整后，还未进行重平衡的结果。</p><img src="'+D+'" style="zoom:50%;"><p>我们可以看到：</p><ul><li><p>机房的文件比之和，不一定为100%。</p><ul><li>可以小于100%，此时，一定存在空槽位。空槽位的流量会流到三方</li><li>可以等于100%，此时，重平衡之后的最终态，每个槽位都有自建机房，非常理想</li><li>可以大于100%，此时，重平衡之后的最终态，某些槽位可能存在多个自建机房。命中这些槽位的请求，算法会返回多个自建节点。</li></ul></li><li><p>槽位就代表着一份最小的可控文件区间。</p></li><li><p>某个槽位上的后端节点可以返回空。当用户请求命中“槽位8”时，选不到自建节点，此时返回三方CDN。</p></li><li><p>某个槽位上的后端节点可以返回多个。 当用户请求命中“槽位2”时，可以有多个自建节点争抢流量，节点之间的流量按照“机房的流量分配比例”去分发。</p></li><li><p>我们会定时对槽位进行重平衡，尽量填充空槽位，并且槽位上的节点数量的差值不超过一个，保证尽量均衡。</p><ul><li><p>每天只有 <code>[09:00, 17:00]</code> 这个时间段才会进行重平衡</p></li><li><p>每隔一个小时会触发重平衡</p></li><li><p>每次重平衡时，每个机房槽位变化数量不超过2个（基数为100）</p></li><li><p>通过这种灰度的方式，来保证稳定性。</p></li></ul></li></ul><h3 id="_4-场景分析" tabindex="-1"><a class="header-anchor" href="#_4-场景分析"><span>4. 场景分析</span></a></h3><p>在机房的变更场景中，我们来分别分析下。</p><ul><li>当机房的文件比增大时，对应的，通过算法进行抢占对应数量的槽位。</li><li>当机房的文件比减少时，对应的，通过算法进行释放对应数量的槽位。</li><li>当某地区有新机房上线时，对应的，给这个新机房抢占对应数量的槽位</li><li>当某地区有机房下线时，对应的，将这个机房的槽位释放掉</li></ul><p>如上不同场景的策略做工后，可能会产生如下的结果</p><ul><li>抢占槽位后，槽位上可能会有多个自建节点。这些自建节点的分量逻辑是：按照“机房流量分配比例”作为权重，将命中此槽位的请求分发给不同自建节点。</li><li>释放槽位后，槽位上可能会没有自建节点。此时命中此槽位的请求将返回三方厂商。</li><li>调整之后，可能会出现槽位上自建节点分布不均衡的情况，通过“重平衡”的方式灰度的完成槽位上自建节点的均衡分布。</li></ul><p>最终，用户的请求流程如下：</p><ol><li>使用“离散型槽位哈希算法”，为多个自建节点构建槽位。用户请求进来之后先选择槽位。</li><li>槽位中的多个自建节点，使用“节点的流量分配比例”作为权重，选择出一个节点</li><li>节点下的机器，我们采用“机器的流量分配比例”作为权重，使用经典一致性哈希算法构建机器间的哈希环。选择一个机器。</li><li>最后再根据机器的负反馈比例，来决定是否使用当前机器。</li></ol><img src="'+E+'" style="zoom:50%;"><p>这样，便完成了CDN调度的整个流程。</p><h2 id="六、测试" tabindex="-1"><a class="header-anchor" href="#六、测试"><span>六、测试</span></a></h2><p>代码库：<a href="https://github.com/noahyz/consistent-hash/tree/master" target="_blank" rel="noopener noreferrer">https://github.com/noahyz/consistent-hash/tree/master</a></p><p>此代码库我实现了如上所有的一致性哈希算法，并且从“分布均匀性”、“节点变动重映射比例”、“查询性能”方面做了测试。</p><p>测试环境：OS：MacOS；CPU：Apple M2 Pro；MEM：32G；Go版本：1.23.8</p><h3 id="_1-分布均匀性" tabindex="-1"><a class="header-anchor" href="#_1-分布均匀性"><span>1. 分布均匀性</span></a></h3><p>分布均匀性测试衡量的是当大量键被分配到固定数量的节点时，每个节点被分配到的键数量是否接近平均值。我们使用标准差来衡量分布均匀性：</p><ul><li><strong>标准差越小</strong>：表示各节点被分配到的键数量越接近平均值，分布越均匀</li><li><strong>标准差越大</strong>：表示某些节点被分配到的键数量远高于或低于平均值，分布不均匀</li></ul><p>测试方法：使用 1000 个节点和 100,000 个键进行测试。每个节点平均分配键数为 100。</p><p>具体测试结果：</p><table><thead><tr><th>算法</th><th>标准差</th><th>分布均匀性</th></tr></thead><tbody><tr><td>RendezvousHash</td><td>9.81</td><td>优秀</td></tr><tr><td>JumpHash</td><td>9.87</td><td>优秀</td></tr><tr><td>SlotHash</td><td>10.09</td><td>优秀</td></tr><tr><td>MaglevHash(65537表长)</td><td>10.40</td><td>优秀</td></tr><tr><td>RingHash(160个虚拟节点)</td><td>13.04</td><td>良好</td></tr><tr><td>MaglevHash(2039表长)</td><td>14.00</td><td>良好</td></tr><tr><td>RingHash(40个虚拟节点)</td><td>19.66</td><td>一般</td></tr><tr><td>DxHash</td><td>30.86</td><td>一般</td></tr><tr><td>AnchorHash(2000数组长)</td><td>787.60</td><td>差，极不均匀</td></tr></tbody></table><p>可以看出：</p><ul><li>RendezvousHash、JumHash、SlotHash 的分布均匀性非常优秀</li><li>MaglevHash、RingHash 只有在表长或虚拟节点数较大的情况下，才能有良好的均匀分布。</li><li>而 AnchorHash算法的分布极不均匀（存在大量的空槽位）</li></ul><h3 id="_2-重映射比例" tabindex="-1"><a class="header-anchor" href="#_2-重映射比例"><span>2. 重映射比例</span></a></h3><p>重映射测试衡量的是当系统中增加新节点时，有多少比例的键需要重新分配到不同的节点：</p><ul><li><strong>重映射比例越低</strong>：表示系统扩展时对现有服务的影响越小</li><li><strong>重映射比例越高</strong>：表示系统扩展时对现有服务的影响越大</li></ul><p>测试方法：添加 10 个节点到 1000 个初始节点，测试key为 100000个</p><p>具体测试结果：</p><table><thead><tr><th>算法</th><th>重映射键数</th><th>重映射比例</th><th>添加节点耗时</th><th>重映射性能</th></tr></thead><tbody><tr><td>SlotHash</td><td>0</td><td>0.00%</td><td>88.74ms</td><td>无需重映射</td></tr><tr><td>AnchorHash</td><td>735</td><td>0.73%</td><td>2.167µs</td><td>最小化</td></tr><tr><td>RingHash(160个虚拟节点)</td><td>973</td><td>0.97%</td><td>170.29ms</td><td>最小化</td></tr><tr><td>RendezvousHash</td><td>1023</td><td>1.02%</td><td>2.583µs</td><td>中等</td></tr><tr><td>RingHash(40个虚拟节点)</td><td>1031</td><td>1.03%</td><td>38.17m s</td><td>中等</td></tr><tr><td>JumpHash</td><td>1034</td><td>1.03%</td><td>2.291µs</td><td>中等</td></tr><tr><td>DxHash</td><td>1297</td><td>1.30%</td><td>5.625µs</td><td>中等</td></tr><tr><td>MaglevHash(65537表长)</td><td>3418</td><td>3.42%</td><td>26.62ms</td><td>较大</td></tr><tr><td>MaglevHash(2039表长)</td><td>3504</td><td>3.50%</td><td>3.21ms</td><td>较大</td></tr></tbody></table><p>可以看出：</p><ul><li>SlotHash 算法可以做到无需重映射，非常适合对重映射非常敏感的场景</li><li>AnchorHash、RingHash、RendezvousHash、JumpHash、DxHash 算法的重映射相对良好</li><li>MaglevHash 算法的重映射比例较高，并且和表长无关。重映射敏感场景慎用。</li></ul><h3 id="_3-查询性能" tabindex="-1"><a class="header-anchor" href="#_3-查询性能"><span>3. 查询性能</span></a></h3><p>查询性能测试衡量的是算法处理单个键查询的速度：</p><ul><li><strong>时间越短</strong>：表示算法查询速度越快，性能越好</li><li><strong>时间越长</strong>：表示算法查询速度越慢，性能越差</li></ul><p>测试方式：1000个节点，执行 100000 次查询操作</p><p>具体测试结果：</p><table><thead><tr><th>算法</th><th>耗时</th><th>查询性能</th></tr></thead><tbody><tr><td>JumpHash</td><td>10.979583ms</td><td>快速</td></tr><tr><td>MaglevHash（2039表长）</td><td>12.585542ms</td><td>快速</td></tr><tr><td>MaglevHash(65537表长)</td><td>13.040875ms</td><td>快速</td></tr><tr><td>SlotHash</td><td>15.797959ms</td><td>快速</td></tr><tr><td>RingHash(40个虚拟节点)</td><td>17.461917ms</td><td>快速</td></tr><tr><td>RingHash(160个虚拟节点)</td><td>20.823416ms</td><td>快速</td></tr><tr><td>DxHash</td><td>42.3815ms</td><td>中等</td></tr><tr><td>AnchorHash</td><td>52.484208ms</td><td>中等</td></tr><tr><td>RendezvousHash</td><td>4.199090375s</td><td>缓慢</td></tr></tbody></table><p>可以看出：</p><ul><li>RendezvousHash 的查询性能非常差，因为要进行大量计算。导致耗时差了一个数量级。</li><li>其他算法的查询性性能适合</li></ul><h3 id="_4-对比" tabindex="-1"><a class="header-anchor" href="#_4-对比"><span>4. 对比</span></a></h3><p>我们与常见哈希算法作特性对比，包括负载均衡，单调性、稳定性(扰动量)、是否有状态、查找复杂度、空间开销等。如表所示：</p><table><thead><tr><th>算法</th><th>负载均衡</th><th>单调性</th><th>稳定性(扰动量)</th><th>是否支持权重</th><th>是否有状态</th><th>查找复杂度</th><th>空间开销</th><th>备注</th></tr></thead><tbody><tr><td>Ring hash</td><td>一般(依赖虚拟节点数)</td><td>良好</td><td>中（约1/N）</td><td>支持</td><td>无状态</td><td>O(logV)</td><td>O(V)（虚拟节点数）</td><td>通过虚拟节点比例实现权重</td></tr><tr><td>Rendezvous (HRW)</td><td>优秀</td><td>良好</td><td>极低（仅影响权重变化节点）</td><td>支持</td><td>无状态</td><td>O(N)</td><td>O(1)</td><td>天然支持权重计算</td></tr><tr><td>Jump Consistent</td><td>接近优秀</td><td>限制（仅支持末尾加删）</td><td>极低，约 1/(N+1)</td><td>不支持</td><td>无状态</td><td>O(log N)</td><td>O(1)</td><td>不支持权重</td></tr><tr><td>MaglevHash</td><td>良好(均匀)</td><td>较差（节点变动需重构）</td><td>中（依赖表大小）</td><td>不支持(原生)</td><td>无状态</td><td>O(1)</td><td>O(M) 其中 M远大于N，高（大查找表）</td><td>原生不支持权重</td></tr><tr><td>AnchorHash</td><td>良好</td><td>完全（记录状态，可任意增删）</td><td>极少（理论最小扰动）</td><td>支持</td><td>有状态（需串行）</td><td>平均O(1)</td><td>O(B) 其中B为最大规划数</td><td>有最大节点数限制，扩展性较差</td></tr><tr><td>DxHash</td><td>良好</td><td>完全（伪随机序列映射）</td><td>高，扩容时约50%</td><td>支持</td><td>无状态</td><td>近似O(1)</td><td>O(S) 其中 <code>S = 2^k &gt;= N</code></td><td>扩容扰动极大</td></tr><tr><td>SlotHash (本算法)</td><td>完美(精确按权重分配)</td><td>完全（仅影响自身槽位）</td><td>可控零扰动</td><td>支持</td><td>有状态（重平衡）</td><td>O(1)</td><td>O(S+N)（固定槽位表）</td><td>工程级灰度控制</td></tr></tbody></table><p>关键特性详解</p><ol><li>负载均衡： <ul><li>SlotHash：唯一实现精确权重映射</li><li>Rendezvous：原生的均衡，对权重敏感</li><li>JumpHash：无权重，但分布均匀</li></ul></li><li>单调性： <ul><li>SlotHash / Anchor / DxHash：支持任意节点增删</li><li>JumpHash：仅支持末尾顺序变更（重大限制）</li><li>Maglev：最差（全局重构破坏单调性）</li></ul></li><li>稳定性（扰动量） <ul><li>SlotHash：唯一实现工程级可控扰动</li><li>AnchorHash：理论最小扰动（但需预设规模上限）</li><li>DxHash：扩容时有 50% 的重映射（不适合敏感场景）</li></ul></li></ol><p>可以看出，自研的 SlotHash 算法，结合工程求解思路，在保留状态的前提下，其他的特性几乎都优胜于常见哈希算法。</p><h3 id="_5-场景" tabindex="-1"><a class="header-anchor" href="#_5-场景"><span>5. 场景</span></a></h3><p>我们根据算法的特性，总结一下不同算法适用的场景。</p><table><thead><tr><th>算法</th><th>优点</th><th>缺点</th><th>适用场景</th></tr></thead><tbody><tr><td>RingHash</td><td>1. 实现简单<br>2. 通过虚拟节点可以调节分布均匀性</td><td>1. 查询性能 O(logN)<br>2. 分布均匀性依赖虚拟节点数</td><td>对性能要求不高、实现简单优先的场景</td></tr><tr><td>JumpHash</td><td>1. 内存占用小，无额外数据结构<br>2. 查询性能、分布均匀性、重映射比例都不错</td><td>1. 只能在尾部增删节点，无法随意增删节点<br>2. 不支持节点权重</td><td>节点变化极少，且主要在尾部操作的场景</td></tr><tr><td>MaglevHash</td><td>1. 查询性能、分布均匀性都不错</td><td>1. 内存占用大，需要预先计算查找表<br>2. 节点变动时，重映射比较较高<br>3. 重建表比较耗时<br>4. 原生不支持权重</td><td>查询频率高，对查询性能要求极高的场景</td></tr><tr><td>RendezvousHash</td><td>1. 分布均匀性、节点重映射都不错<br>2. 可以在任意位置增删节点</td><td>1. 查询性能较差</td><td>节点数量不错，对分布均匀性要求高，查询频率不高的场景</td></tr><tr><td>AnchorHash</td><td>1. 节点重映射比例较小，删除节点时只影响直接映射到该节点的key</td><td>1. 分布均匀性非常差<br>2. 查询性能一般<br>3. 有状态</td><td>对重映射要求高、可以接受分布不均匀的场景</td></tr><tr><td>DxHash</td><td>都一般</td><td>1. 分布均匀性、查询性能、重映射比例都一般<br>2. 扩容扰动非常大</td><td>节点数量确定，不会发生扩容的场景</td></tr><tr><td>SlotHash(本算法)</td><td>1. 查询性能、分布均匀性都不错<br>2. 精确权重映射<br>3. 节点变动时，无需重映射，做到零扰动<br>4. 可以在任意位置增删节点<br>5. 支持工程介入配置，人工可控，可以灵活调优</td><td>1. 有状态<br>2. 需要重平衡</td><td>节点配额精确匹配，节点扩缩容导致的重映射场景要求无扰动、人工可控，可以容忍带状态的场景</td></tr></tbody></table><h2 id="七、结尾" tabindex="-1"><a class="header-anchor" href="#七、结尾"><span>七、结尾</span></a></h2><h3 id="_1-优势与调优" tabindex="-1"><a class="header-anchor" href="#_1-优势与调优"><span>1. 优势与调优</span></a></h3><p>SlotHash在CDN点播场景下的优势体现在：</p><ul><li>完全单调性：任何节点变化只影响自身的槽位分配，不会牵连其他节点的缓存或状态。彻底避免级联缓存失效，是CDN场景防雪崩的关键。</li><li>精确可控最小扰动：节点权重与槽位数量严格线性对应，变更时仅调整必要槽位，扰动范围与预期完全一致，实现零预期扰动；</li><li>高效负载均衡：通过随机评分、配额机制和重平衡机制，实现请求流量与节点能力的精确匹配，大幅降低资源浪费。</li></ul><p>此外，SlotHash 支持灵活调优：</p><ul><li>每日变更上限：可配置每天每台机房最多变更的槽位数，避免频繁大规模迁移。</li><li>重平衡策略：限制时间窗口(如“每天<code>[09:00–17:00]</code>)，频率(每小时一次)，单次迁移量，让灰度过程完全可控。</li><li>槽位数量设置：一般槽位总数根据场景设置为较大基数（如1000）以获得更精细的分割粒度，从而提高缓存命中率。</li></ul><p>通过上述策略，SlotHash既实现了哈希映射的稳定性和可控性，又兼顾了高性能的实际需求，为CDN点播调度提供了工程化的解决方案。</p><h3 id="_2-小结" tabindex="-1"><a class="header-anchor" href="#_2-小结"><span>2. 小结</span></a></h3><p>本文详细介绍了为满足 CDN 点播调度严苛需求而自主研发的 “离散型槽位一致性哈希 (SlotHash)” 算法。SlotHash 通过 <strong>固定槽位 + 随机评分 + 精确配额</strong> 的核心设计，实现了：</p><ol><li>权重到槽位数的精确映射，实现了“严格线性负载分配” 和 “完全单调性” 与 “精确可控的最小扰动”。</li><li>动态扩缩容过程中，节点变更时“只调整自身相关槽位”，彻底避免影响其他节点缓存。</li><li>在查询效率 <code>O(1)</code>、稳定性、空间开销 <code>O(S+N)</code> 方面具有综合优势。</li></ol><p>结合 “每日变更上限、受控重平衡、多节点/空槽位工程策略” 等调优手段，SlotHash 在快手点播 CDN 的落地实践中，成功解决了动态文件比、精确负载、无冲击扩缩容等核心挑战，显著提升了缓存利用率和系统稳定性，成为兼顾强一致性、可控性与高性能的优秀工程解决方案。</p><h2 id="八、引用" tabindex="-1"><a class="header-anchor" href="#八、引用"><span>八、引用</span></a></h2><p>RendezvousHash wiki：<a href="https://en.wikipedia.org/wiki/Rendezvous_hashing" target="_blank" rel="noopener noreferrer">https://en.wikipedia.org/wiki/Rendezvous_hashing</a></p><p>JumpHash论文：<a href="https://arxiv.org/abs/1406.2294" target="_blank" rel="noopener noreferrer">https://arxiv.org/abs/1406.2294</a></p><p>MaglevHash论文：<a href="https://research.google/pubs/maglev-a-fast-and-reliable-software-network-load-balancer/" target="_blank" rel="noopener noreferrer">https://research.google/pubs/maglev-a-fast-and-reliable-software-network-load-balancer/</a></p><p>anchorHash论文：<a href="https://arxiv.org/pdf/1812.09674" target="_blank" rel="noopener noreferrer">https://arxiv.org/pdf/1812.09674</a></p><p>DxHash论文：<a href="https://arxiv.org/pdf/2107.07930" target="_blank" rel="noopener noreferrer">https://arxiv.org/pdf/2107.07930</a></p><p>MementoHash论文： <a href="https://arxiv.org/html/2306.09783v3" target="_blank" rel="noopener noreferrer">https://arxiv.org/html/2306.09783v3</a></p><p>BinomialHash论文：<a href="https://www.semanticscholar.org/reader/e3b51975a2ea5d4a50b3dc621c27a608db0c782c" target="_blank" rel="noopener noreferrer">https://www.semanticscholar.org/reader/e3b51975a2ea5d4a50b3dc621c27a608db0c782c</a></p><p>MCMF wiki：<a href="https://zh.wikipedia.org/wiki/%E6%9C%80%E5%B0%8F%E8%B4%B9%E7%94%A8%E6%9C%80%E5%A4%A7%E6%B5%81%E9%97%AE%E9%A2%98" target="_blank" rel="noopener noreferrer">https://zh.wikipedia.org/wiki/最小费用最大流问题</a></p><p>PID wiki：<a href="https://zh.wikipedia.org/wiki/PID%E6%8E%A7%E5%88%B6%E5%99%A8" target="_blank" rel="noopener noreferrer">https://zh.wikipedia.org/wiki/PID%E6%8E%A7%E5%88%B6%E5%99%A8</a></p>',369)]))}const H=s(f,[["render",C],["__file","1.自研离散型槽位哈希.html.vue"]]),N=JSON.parse('{"path":"/%E6%8A%80%E6%9C%AF%E4%B8%93%E9%A2%98/%E4%B8%80%E8%87%B4%E6%80%A7%E5%93%88%E5%B8%8C/1.%E8%87%AA%E7%A0%94%E7%A6%BB%E6%95%A3%E5%9E%8B%E6%A7%BD%E4%BD%8D%E5%93%88%E5%B8%8C.html","title":"1.自研离散型槽位哈希","lang":"zh-CN","frontmatter":{"title":"1.自研离散型槽位哈希","description":"一致性哈希最早于1997年提出，用于在大规模分布式缓存、CDN和负载均衡系统中，将大量请求或数据均匀分配到一组后端节点，并在节点动态增删时最小化的重映射数据。 我们目前常见的一致性哈希算法，包括：ring hash、jump consistent hash、rendevous hash、maglev hash、Anchor hash等。 本文首先调研了...","head":[["meta",{"property":"og:url","content":"https://noahyz.github.io/%E6%8A%80%E6%9C%AF%E4%B8%93%E9%A2%98/%E4%B8%80%E8%87%B4%E6%80%A7%E5%93%88%E5%B8%8C/1.%E8%87%AA%E7%A0%94%E7%A6%BB%E6%95%A3%E5%9E%8B%E6%A7%BD%E4%BD%8D%E5%93%88%E5%B8%8C.html"}],["meta",{"property":"og:site_name","content":"noahyz的博客"}],["meta",{"property":"og:title","content":"1.自研离散型槽位哈希"}],["meta",{"property":"og:description","content":"一致性哈希最早于1997年提出，用于在大规模分布式缓存、CDN和负载均衡系统中，将大量请求或数据均匀分配到一组后端节点，并在节点动态增删时最小化的重映射数据。 我们目前常见的一致性哈希算法，包括：ring hash、jump consistent hash、rendevous hash、maglev hash、Anchor hash等。 本文首先调研了..."}],["meta",{"property":"og:type","content":"article"}],["meta",{"property":"og:locale","content":"zh-CN"}],["meta",{"property":"article:author","content":"noahyz"}],["script",{"type":"application/ld+json"},"{\\"@context\\":\\"https://schema.org\\",\\"@type\\":\\"Article\\",\\"headline\\":\\"1.自研离散型槽位哈希\\",\\"image\\":[\\"\\"],\\"dateModified\\":null,\\"author\\":[{\\"@type\\":\\"Person\\",\\"name\\":\\"noahyz\\",\\"url\\":\\"/about-the-author/\\"}]}"]]},"headers":[{"level":2,"title":"一、缘起","slug":"一、缘起","link":"#一、缘起","children":[]},{"level":2,"title":"二、调研","slug":"二、调研","link":"#二、调研","children":[{"level":3,"title":"1. 经典一致性哈希","slug":"_1-经典一致性哈希","link":"#_1-经典一致性哈希","children":[]},{"level":3,"title":"2. rendezvous hash","slug":"_2-rendezvous-hash","link":"#_2-rendezvous-hash","children":[]},{"level":3,"title":"3. jump consistent hash","slug":"_3-jump-consistent-hash","link":"#_3-jump-consistent-hash","children":[]},{"level":3,"title":"4. Maglev hash","slug":"_4-maglev-hash","link":"#_4-maglev-hash","children":[]},{"level":3,"title":"5. anchor hash","slug":"_5-anchor-hash","link":"#_5-anchor-hash","children":[]},{"level":3,"title":"6. DxHash","slug":"_6-dxhash","link":"#_6-dxhash","children":[]},{"level":3,"title":"7. 其他算法","slug":"_7-其他算法","link":"#_7-其他算法","children":[]}]},{"level":2,"title":"三、需求","slug":"三、需求","link":"#三、需求","children":[]},{"level":2,"title":"四、自研离散型槽位哈希","slug":"四、自研离散型槽位哈希","link":"#四、自研离散型槽位哈希","children":[{"level":3,"title":"1. 数据结构","slug":"_1-数据结构","link":"#_1-数据结构","children":[]},{"level":3,"title":"2. 节点和槽位的映射","slug":"_2-节点和槽位的映射","link":"#_2-节点和槽位的映射","children":[]},{"level":3,"title":"3. 节点槽位的变化场景","slug":"_3-节点槽位的变化场景","link":"#_3-节点槽位的变化场景","children":[]},{"level":3,"title":"4. 槽位上节点数量","slug":"_4-槽位上节点数量","link":"#_4-槽位上节点数量","children":[]},{"level":3,"title":"5. 槽位重平衡","slug":"_5-槽位重平衡","link":"#_5-槽位重平衡","children":[]}]},{"level":2,"title":"五、 工程化落地","slug":"五、-工程化落地","link":"#五、-工程化落地","children":[{"level":3,"title":"1. CDN点播架构","slug":"_1-cdn点播架构","link":"#_1-cdn点播架构","children":[]},{"level":3,"title":"2. 核心输入","slug":"_2-核心输入","link":"#_2-核心输入","children":[]},{"level":3,"title":"3. 算法落地","slug":"_3-算法落地","link":"#_3-算法落地","children":[]},{"level":3,"title":"4. 场景分析","slug":"_4-场景分析","link":"#_4-场景分析","children":[]}]},{"level":2,"title":"六、测试","slug":"六、测试","link":"#六、测试","children":[{"level":3,"title":"1. 分布均匀性","slug":"_1-分布均匀性","link":"#_1-分布均匀性","children":[]},{"level":3,"title":"2. 重映射比例","slug":"_2-重映射比例","link":"#_2-重映射比例","children":[]},{"level":3,"title":"3. 查询性能","slug":"_3-查询性能","link":"#_3-查询性能","children":[]},{"level":3,"title":"4. 对比","slug":"_4-对比","link":"#_4-对比","children":[]},{"level":3,"title":"5. 场景","slug":"_5-场景","link":"#_5-场景","children":[]}]},{"level":2,"title":"七、结尾","slug":"七、结尾","link":"#七、结尾","children":[{"level":3,"title":"1. 优势与调优","slug":"_1-优势与调优","link":"#_1-优势与调优","children":[]},{"level":3,"title":"2. 小结","slug":"_2-小结","link":"#_2-小结","children":[]}]},{"level":2,"title":"八、引用","slug":"八、引用","link":"#八、引用","children":[]}],"git":{},"readingTime":{"minutes":65.37,"words":19610},"filePathRelative":"技术专题/一致性哈希/1.自研离散型槽位哈希.md","excerpt":"<p>一致性哈希最早于1997年提出，用于在大规模分布式缓存、CDN和负载均衡系统中，将大量请求或数据均匀分配到一组后端节点，并在节点动态增删时最小化的重映射数据。</p>\\n<p>我们目前常见的一致性哈希算法，包括：ring hash、jump consistent hash、rendevous hash、maglev hash、Anchor hash等。</p>\\n<p>本文首先调研了业界主流的一致性哈希算法，并深入抽象CDN节点缓存场景的核心需求，自主研发了“离散型槽位哈希”算法。该算法高度契合CDN点播业务的特定需求，已成功应用于“快手点播CDN节点”的缓存调度场景，覆盖近2500台机器，直接承接并调度近20T带宽流量。</p>","autoDesc":true}');export{H as comp,N as data};

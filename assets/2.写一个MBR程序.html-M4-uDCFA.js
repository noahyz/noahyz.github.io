import{_ as n}from"./plugin-vue_export-helper-DlAUqK2U.js";import{c as a,a as i,o as e}from"./app-D1zlwylF.js";const l="/assets/CPU%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86%E7%A4%BA%E6%84%8F%E5%9B%BE-CM8PzQxn.png",p={};function c(d,s){return e(),a("div",null,s[0]||(s[0]=[i(`<h2 id="写一个-mbr-程序" tabindex="-1"><a class="header-anchor" href="#写一个-mbr-程序"><span>写一个 MBR 程序</span></a></h2><p>我们先来贴出程序，然后再来解释。如下这段代码的功能是在屏幕上打印字符串 &quot;1 MBR&quot;。背景色为黑色，前景色为绿色。</p><div class="language- line-numbers-mode" data-highlighter="shiki" data-ext="" data-title="" style="--shiki-light:#24292e;--shiki-dark:#abb2bf;--shiki-light-bg:#fff;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes github-light one-dark-pro vp-code"><code><span class="line"><span>;主引导程序 </span></span>
<span class="line"><span>;------------------------------------------------------------</span></span>
<span class="line"><span>SECTION MBR vstart=0x7c00         </span></span>
<span class="line"><span>   mov ax,cs      </span></span>
<span class="line"><span>   mov ds,ax</span></span>
<span class="line"><span>   mov es,ax</span></span>
<span class="line"><span>   mov ss,ax</span></span>
<span class="line"><span>   mov fs,ax</span></span>
<span class="line"><span>   mov sp,0x7c00</span></span>
<span class="line"><span></span></span>
<span class="line"><span>; 清屏 利用0x06号功能，上卷全部行，则可清屏。</span></span>
<span class="line"><span>; -----------------------------------------------------------</span></span>
<span class="line"><span>;INT 0x10   功能号:0x06	   功能描述:上卷窗口</span></span>
<span class="line"><span>;------------------------------------------------------</span></span>
<span class="line"><span>;输入：</span></span>
<span class="line"><span>;AH 功能号= 0x06</span></span>
<span class="line"><span>;AL = 上卷的行数(如果为0,表示全部)</span></span>
<span class="line"><span>;BH = 上卷行属性</span></span>
<span class="line"><span>;(CL,CH) = 窗口左上角的(X,Y)位置</span></span>
<span class="line"><span>;(DL,DH) = 窗口右下角的(X,Y)位置</span></span>
<span class="line"><span>;无返回值：</span></span>
<span class="line"><span>   mov     ax, 0x600</span></span>
<span class="line"><span>   mov     bx, 0x700</span></span>
<span class="line"><span>   mov     cx, 0           ; 左上角: (0, 0)</span></span>
<span class="line"><span>   mov     dx, 0x184f	   ; 右下角: (80,25),</span></span>
<span class="line"><span>			   ; VGA文本模式中,一行只能容纳80个字符,共25行。</span></span>
<span class="line"><span>			   ; 下标从0开始,所以0x18=24,0x4f=79</span></span>
<span class="line"><span>   int     0x10            ; int 0x10</span></span>
<span class="line"><span></span></span>
<span class="line"><span>;;;;;;;;;    下面这三行代码是获取光标位置    ;;;;;;;;;</span></span>
<span class="line"><span>;.get_cursor获取当前光标位置,在光标位置处打印字符.</span></span>
<span class="line"><span>   mov ah, 3		; 输入: 3号子功能是获取光标位置,需要存入ah寄存器</span></span>
<span class="line"><span>   mov bh, 0		; bh寄存器存储的是待获取光标的页号</span></span>
<span class="line"><span></span></span>
<span class="line"><span>   int 0x10		; 输出: ch=光标开始行,cl=光标结束行</span></span>
<span class="line"><span>							; dh=光标所在行号,dl=光标所在列号</span></span>
<span class="line"><span></span></span>
<span class="line"><span>;;;;;;;;;    获取光标位置结束    ;;;;;;;;;;;;;;;;</span></span>
<span class="line"><span></span></span>
<span class="line"><span>;;;;;;;;;     打印字符串    ;;;;;;;;;;;</span></span>
<span class="line"><span>   ;还是用10h中断,不过这次是调用13号子功能打印字符串</span></span>
<span class="line"><span>   mov ax, message </span></span>
<span class="line"><span>   mov bp, ax		; es:bp 为串首地址, es此时同cs一致，</span></span>
<span class="line"><span>								; 开头时已经为sreg初始化</span></span>
<span class="line"><span></span></span>
<span class="line"><span>   ; 光标位置要用到dx寄存器中内容,cx中的光标位置可忽略</span></span>
<span class="line"><span>   mov cx, 5			; cx 为串长度,不包括结束符0的字符个数</span></span>
<span class="line"><span>   mov ax, 0x1301	; 子功能号13是显示字符及属性,要存入ah寄存器,</span></span>
<span class="line"><span>									; al设置写字符方式 ah=01: 显示字符串,光标跟随移动</span></span>
<span class="line"><span>   mov bx, 0x2		; bh存储要显示的页号,此处是第0页,</span></span>
<span class="line"><span>									; bl中是字符属性, 属性黑底绿字(bl = 02h)</span></span>
<span class="line"><span>   int 0x10				; 执行BIOS 0x10 号中断</span></span>
<span class="line"><span>;;;;;;;;;      打字字符串结束	 ;;;;;;;;;;;;;;;</span></span>
<span class="line"><span></span></span>
<span class="line"><span>   jmp $		; 使程序悬停在此</span></span>
<span class="line"><span></span></span>
<span class="line"><span>   message db &quot;1 MBR&quot;</span></span>
<span class="line"><span>   times 510-($-$$) db 0</span></span>
<span class="line"><span>   db 0x55,0xaa</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h4 id="_1-section-相关" tabindex="-1"><a class="header-anchor" href="#_1-section-相关"><span>1. section 相关</span></a></h4><p>section 是伪指令，是 nasm 提供的。CPU 运行程序是不需要这个东西的，section 只是用来给程序员规划程序用的，逻辑上划分成段的好处就是方便开发人员梳理代码，方便管理。</p><p>如果没有定义 section，nasm 默认全部代码同为一个 section，起始位置为 0。</p><p><code>$</code> 表示本行代码的地址，<code>$$</code> 表示本 section 的起始地址。这两个都是 nasm 预留的关键字，是编译器安排的。</p><p><code>vstart=0x7c00</code> 表示在编译时，把起始地址编译为 <code>0x7c00</code>。</p><p>使用 nasm 进行编译这个汇编文件：<code>nasm -o mbr.bin mbr.s</code></p><p>使用 <code>bin/bximage</code> 来创建一块虚拟硬盘。然后使用 <code>dd</code> 工具将 <code>mbr.bin</code> 写入这块硬盘中。</p><p>bximage 命令创建硬盘：<code>bximage -hd -mode=&quot;flat&quot; -size=60 -q a.img</code></p><p>如下是 dd 命令的选项</p><div class="language- line-numbers-mode" data-highlighter="shiki" data-ext="" data-title="" style="--shiki-light:#24292e;--shiki-dark:#abb2bf;--shiki-light-bg:#fff;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes github-light one-dark-pro vp-code"><code><span class="line"><span>if=FILE  // 指定要读取的文件</span></span>
<span class="line"><span>of=FILE  // 指定要把数据输出到那个文件</span></span>
<span class="line"><span>bs=BYTES  // 指定块的大小，dd 是以块为单位来进行 IO 操作的。此项是统一配置了输入块大小 ibs 和输出块大小 obs 的值，也可以单独配置</span></span>
<span class="line"><span>count=BLOCKS  // 指定拷贝的块数</span></span>
<span class="line"><span>seek=BLOCKS  // 指定当我们把块输出到文件时想要跳过多少个块</span></span>
<span class="line"><span>conv=CONVS  // 指定如何转换文件，建议在追加数据时，conv 用 notrunc 方式，也就是不打断文件</span></span>
<span class="line"><span></span></span>
<span class="line"><span>dd if=/path/mbr.bin of=/path/a.img bs=512 count=1 conv=notrunc</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p><code>vstart=xxx</code> 和 <code>org xxx</code> 都是告诉编译器将程序编译到 xxx 地址。</p><p>cpu 的工作原理总结如下：</p><p>控制单元要取下一条待运行的指令，该指令的地址在程序计数器 PC 中，在 x86 CPU 上，程序计数器就是 <code>cs:ip</code>。于是读取 ip 寄存器后，将此地址送上地址总线，CPU 根据此地址便得到了指令，并将其存入到指令寄存器 IR 中。这时候轮到指令译码器，根据指令格式检查指令寄存器中的指令，先确定操作码是什么，再检查操作数类型，若是在内存中，就将相应操作数从内存中取回放入自己的存储单元，若操作数是在寄存器中就直接用了。此时，操作码有了，操作数也齐了，操作控制器给运算单元下令，开工，于是运算单元便真正开始执行指令了。ip 寄存器的值被加上当前指令的大小，于是 ip 又指向了下一条指令的地址。接着控制单元又要取下一条指令了，流程回到了本段开头，CPU 便开始了日复一日的循环，由于 CPU 特别不容易坏，所以唯一它停下来的条件就是断电。</p><img src="`+l+'" style="zoom:50%;">',17)]))}const r=n(p,[["render",c],["__file","2.写一个MBR程序.html.vue"]]),m=JSON.parse('{"path":"/%E6%8A%80%E6%9C%AF%E4%B8%93%E9%A2%98/%E6%89%8B%E5%86%99%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/1.boot-loader/2.%E5%86%99%E4%B8%80%E4%B8%AAMBR%E7%A8%8B%E5%BA%8F.html","title":"2.写一个 MBR 程序","lang":"zh-CN","frontmatter":{"title":"2.写一个 MBR 程序","description":"写一个 MBR 程序 我们先来贴出程序，然后再来解释。如下这段代码的功能是在屏幕上打印字符串 \\"1 MBR\\"。背景色为黑色，前景色为绿色。 1. section 相关 section 是伪指令，是 nasm 提供的。CPU 运行程序是不需要这个东西的，section 只是用来给程序员规划程序用的，逻辑上划分成段的好处就是方便开发人员梳理代码，方便管理。...","head":[["meta",{"property":"og:url","content":"https://noahyz.github.io/%E6%8A%80%E6%9C%AF%E4%B8%93%E9%A2%98/%E6%89%8B%E5%86%99%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/1.boot-loader/2.%E5%86%99%E4%B8%80%E4%B8%AAMBR%E7%A8%8B%E5%BA%8F.html"}],["meta",{"property":"og:site_name","content":"noahyz的博客"}],["meta",{"property":"og:title","content":"2.写一个 MBR 程序"}],["meta",{"property":"og:description","content":"写一个 MBR 程序 我们先来贴出程序，然后再来解释。如下这段代码的功能是在屏幕上打印字符串 \\"1 MBR\\"。背景色为黑色，前景色为绿色。 1. section 相关 section 是伪指令，是 nasm 提供的。CPU 运行程序是不需要这个东西的，section 只是用来给程序员规划程序用的，逻辑上划分成段的好处就是方便开发人员梳理代码，方便管理。..."}],["meta",{"property":"og:type","content":"article"}],["meta",{"property":"og:locale","content":"zh-CN"}],["meta",{"property":"article:author","content":"noahyz"}],["script",{"type":"application/ld+json"},"{\\"@context\\":\\"https://schema.org\\",\\"@type\\":\\"Article\\",\\"headline\\":\\"2.写一个 MBR 程序\\",\\"image\\":[\\"\\"],\\"dateModified\\":null,\\"author\\":[{\\"@type\\":\\"Person\\",\\"name\\":\\"noahyz\\",\\"url\\":\\"/about-the-author/\\"}]}"]]},"headers":[{"level":2,"title":"写一个 MBR 程序","slug":"写一个-mbr-程序","link":"#写一个-mbr-程序","children":[]}],"git":{},"readingTime":{"minutes":4.29,"words":1288},"filePathRelative":"技术专题/手写操作系统/1.boot-loader/2.写一个MBR程序.md","excerpt":"<h2>写一个 MBR 程序</h2>\\n<p>我们先来贴出程序，然后再来解释。如下这段代码的功能是在屏幕上打印字符串 \\"1 MBR\\"。背景色为黑色，前景色为绿色。</p>\\n<div class=\\"language- line-numbers-mode\\" data-highlighter=\\"shiki\\" data-ext=\\"\\" data-title=\\"\\" style=\\"--shiki-light:#24292e;--shiki-dark:#abb2bf;--shiki-light-bg:#fff;--shiki-dark-bg:#282c34\\"><pre class=\\"shiki shiki-themes github-light one-dark-pro vp-code\\"><code><span class=\\"line\\"><span>;主引导程序 </span></span>\\n<span class=\\"line\\"><span>;------------------------------------------------------------</span></span>\\n<span class=\\"line\\"><span>SECTION MBR vstart=0x7c00         </span></span>\\n<span class=\\"line\\"><span>   mov ax,cs      </span></span>\\n<span class=\\"line\\"><span>   mov ds,ax</span></span>\\n<span class=\\"line\\"><span>   mov es,ax</span></span>\\n<span class=\\"line\\"><span>   mov ss,ax</span></span>\\n<span class=\\"line\\"><span>   mov fs,ax</span></span>\\n<span class=\\"line\\"><span>   mov sp,0x7c00</span></span>\\n<span class=\\"line\\"><span></span></span>\\n<span class=\\"line\\"><span>; 清屏 利用0x06号功能，上卷全部行，则可清屏。</span></span>\\n<span class=\\"line\\"><span>; -----------------------------------------------------------</span></span>\\n<span class=\\"line\\"><span>;INT 0x10   功能号:0x06\\t   功能描述:上卷窗口</span></span>\\n<span class=\\"line\\"><span>;------------------------------------------------------</span></span>\\n<span class=\\"line\\"><span>;输入：</span></span>\\n<span class=\\"line\\"><span>;AH 功能号= 0x06</span></span>\\n<span class=\\"line\\"><span>;AL = 上卷的行数(如果为0,表示全部)</span></span>\\n<span class=\\"line\\"><span>;BH = 上卷行属性</span></span>\\n<span class=\\"line\\"><span>;(CL,CH) = 窗口左上角的(X,Y)位置</span></span>\\n<span class=\\"line\\"><span>;(DL,DH) = 窗口右下角的(X,Y)位置</span></span>\\n<span class=\\"line\\"><span>;无返回值：</span></span>\\n<span class=\\"line\\"><span>   mov     ax, 0x600</span></span>\\n<span class=\\"line\\"><span>   mov     bx, 0x700</span></span>\\n<span class=\\"line\\"><span>   mov     cx, 0           ; 左上角: (0, 0)</span></span>\\n<span class=\\"line\\"><span>   mov     dx, 0x184f\\t   ; 右下角: (80,25),</span></span>\\n<span class=\\"line\\"><span>\\t\\t\\t   ; VGA文本模式中,一行只能容纳80个字符,共25行。</span></span>\\n<span class=\\"line\\"><span>\\t\\t\\t   ; 下标从0开始,所以0x18=24,0x4f=79</span></span>\\n<span class=\\"line\\"><span>   int     0x10            ; int 0x10</span></span>\\n<span class=\\"line\\"><span></span></span>\\n<span class=\\"line\\"><span>;;;;;;;;;    下面这三行代码是获取光标位置    ;;;;;;;;;</span></span>\\n<span class=\\"line\\"><span>;.get_cursor获取当前光标位置,在光标位置处打印字符.</span></span>\\n<span class=\\"line\\"><span>   mov ah, 3\\t\\t; 输入: 3号子功能是获取光标位置,需要存入ah寄存器</span></span>\\n<span class=\\"line\\"><span>   mov bh, 0\\t\\t; bh寄存器存储的是待获取光标的页号</span></span>\\n<span class=\\"line\\"><span></span></span>\\n<span class=\\"line\\"><span>   int 0x10\\t\\t; 输出: ch=光标开始行,cl=光标结束行</span></span>\\n<span class=\\"line\\"><span>\\t\\t\\t\\t\\t\\t\\t; dh=光标所在行号,dl=光标所在列号</span></span>\\n<span class=\\"line\\"><span></span></span>\\n<span class=\\"line\\"><span>;;;;;;;;;    获取光标位置结束    ;;;;;;;;;;;;;;;;</span></span>\\n<span class=\\"line\\"><span></span></span>\\n<span class=\\"line\\"><span>;;;;;;;;;     打印字符串    ;;;;;;;;;;;</span></span>\\n<span class=\\"line\\"><span>   ;还是用10h中断,不过这次是调用13号子功能打印字符串</span></span>\\n<span class=\\"line\\"><span>   mov ax, message </span></span>\\n<span class=\\"line\\"><span>   mov bp, ax\\t\\t; es:bp 为串首地址, es此时同cs一致，</span></span>\\n<span class=\\"line\\"><span>\\t\\t\\t\\t\\t\\t\\t\\t; 开头时已经为sreg初始化</span></span>\\n<span class=\\"line\\"><span></span></span>\\n<span class=\\"line\\"><span>   ; 光标位置要用到dx寄存器中内容,cx中的光标位置可忽略</span></span>\\n<span class=\\"line\\"><span>   mov cx, 5\\t\\t\\t; cx 为串长度,不包括结束符0的字符个数</span></span>\\n<span class=\\"line\\"><span>   mov ax, 0x1301\\t; 子功能号13是显示字符及属性,要存入ah寄存器,</span></span>\\n<span class=\\"line\\"><span>\\t\\t\\t\\t\\t\\t\\t\\t\\t; al设置写字符方式 ah=01: 显示字符串,光标跟随移动</span></span>\\n<span class=\\"line\\"><span>   mov bx, 0x2\\t\\t; bh存储要显示的页号,此处是第0页,</span></span>\\n<span class=\\"line\\"><span>\\t\\t\\t\\t\\t\\t\\t\\t\\t; bl中是字符属性, 属性黑底绿字(bl = 02h)</span></span>\\n<span class=\\"line\\"><span>   int 0x10\\t\\t\\t\\t; 执行BIOS 0x10 号中断</span></span>\\n<span class=\\"line\\"><span>;;;;;;;;;      打字字符串结束\\t ;;;;;;;;;;;;;;;</span></span>\\n<span class=\\"line\\"><span></span></span>\\n<span class=\\"line\\"><span>   jmp $\\t\\t; 使程序悬停在此</span></span>\\n<span class=\\"line\\"><span></span></span>\\n<span class=\\"line\\"><span>   message db \\"1 MBR\\"</span></span>\\n<span class=\\"line\\"><span>   times 510-($-$$) db 0</span></span>\\n<span class=\\"line\\"><span>   db 0x55,0xaa</span></span></code></pre>\\n<div class=\\"line-numbers\\" aria-hidden=\\"true\\" style=\\"counter-reset:line-number 0\\"><div class=\\"line-number\\"></div><div class=\\"line-number\\"></div><div class=\\"line-number\\"></div><div class=\\"line-number\\"></div><div class=\\"line-number\\"></div><div class=\\"line-number\\"></div><div class=\\"line-number\\"></div><div class=\\"line-number\\"></div><div class=\\"line-number\\"></div><div class=\\"line-number\\"></div><div class=\\"line-number\\"></div><div class=\\"line-number\\"></div><div class=\\"line-number\\"></div><div class=\\"line-number\\"></div><div class=\\"line-number\\"></div><div class=\\"line-number\\"></div><div class=\\"line-number\\"></div><div class=\\"line-number\\"></div><div class=\\"line-number\\"></div><div class=\\"line-number\\"></div><div class=\\"line-number\\"></div><div class=\\"line-number\\"></div><div class=\\"line-number\\"></div><div class=\\"line-number\\"></div><div class=\\"line-number\\"></div><div class=\\"line-number\\"></div><div class=\\"line-number\\"></div><div class=\\"line-number\\"></div><div class=\\"line-number\\"></div><div class=\\"line-number\\"></div><div class=\\"line-number\\"></div><div class=\\"line-number\\"></div><div class=\\"line-number\\"></div><div class=\\"line-number\\"></div><div class=\\"line-number\\"></div><div class=\\"line-number\\"></div><div class=\\"line-number\\"></div><div class=\\"line-number\\"></div><div class=\\"line-number\\"></div><div class=\\"line-number\\"></div><div class=\\"line-number\\"></div><div class=\\"line-number\\"></div><div class=\\"line-number\\"></div><div class=\\"line-number\\"></div><div class=\\"line-number\\"></div><div class=\\"line-number\\"></div><div class=\\"line-number\\"></div><div class=\\"line-number\\"></div><div class=\\"line-number\\"></div><div class=\\"line-number\\"></div><div class=\\"line-number\\"></div><div class=\\"line-number\\"></div><div class=\\"line-number\\"></div><div class=\\"line-number\\"></div><div class=\\"line-number\\"></div><div class=\\"line-number\\"></div><div class=\\"line-number\\"></div><div class=\\"line-number\\"></div><div class=\\"line-number\\"></div></div></div>","autoDesc":true}');export{r as comp,m as data};

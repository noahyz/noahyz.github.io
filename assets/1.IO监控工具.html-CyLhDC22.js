import{_ as a}from"./plugin-vue_export-helper-DlAUqK2U.js";import{c as i,a as t,o as n}from"./app-D1zlwylF.js";const s={};function l(o,e){return n(),i("div",null,e[0]||(e[0]=[t(`<h2 id="监控与分析" tabindex="-1"><a class="header-anchor" href="#监控与分析"><span>监控与分析</span></a></h2><h3 id="一、系统级-io-监控" tabindex="-1"><a class="header-anchor" href="#一、系统级-io-监控"><span>一、系统级 IO 监控</span></a></h3><h4 id="_1-iostat-工具" tabindex="-1"><a class="header-anchor" href="#_1-iostat-工具"><span>1. iostat 工具</span></a></h4><p>统计的是通用块层经过合并后，直接向设备提交的 IO 数据，可以反映系统整体的 IO 状况，但是有如下缺点：</p><ul><li>距离业务层比较遥远，和代码中的 read、write 不对应（由于系统预读、pagecache、IO 调度算法等）</li><li>是系统级，没有办法精确到进程，比如得知磁盘很忙，但是没办法告诉我们谁在忙？忙什么？</li></ul><h3 id="二、进程级别-io-监控" tabindex="-1"><a class="header-anchor" href="#二、进程级别-io-监控"><span>二、进程级别 IO 监控</span></a></h3><h4 id="_1-iotop-和-pidstat-工具" tabindex="-1"><a class="header-anchor" href="#_1-iotop-和-pidstat-工具"><span>1. iotop 和 pidstat 工具</span></a></h4><p>都是依赖 <code>/proc/pid/io</code> 文件导出的统计信息。可以得知：</p><ul><li>当前系统哪些进程在占用 IO，百分比是多少？</li><li>占用 IO 的进程是在读？还是在写？读写量是多少</li></ul><p>但是这两个工具统计的粒度较粗，没有办法得知当前进程读写了哪些文件？耗时以及大小？</p><h3 id="三、业务级-io-监控" tabindex="-1"><a class="header-anchor" href="#三、业务级-io-监控"><span>三、业务级 IO 监控</span></a></h3><h4 id="_1-ioprofile-工具" tabindex="-1"><a class="header-anchor" href="#_1-ioprofile-工具"><span>1. ioprofile 工具</span></a></h4><p>本质上是 lsof 和 strace 的组合。可以解决这几个问题：</p><ul><li>当前进程某时间内，在业务层面读写了哪些文件？</li><li>读写次数是多少？（read、write 的调用次数）</li><li>读写数据量多少？（read、write 的 byte 数）</li></ul><p><a href="https://blog.yufeng.info/archives/995" target="_blank" rel="noopener noreferrer">https://blog.yufeng.info/archives/995</a></p><h3 id="四、文件级-io-监控" tabindex="-1"><a class="header-anchor" href="#四、文件级-io-监控"><span>四、文件级 IO 监控</span></a></h3><p>主要针对单个文件，查看当前那些进程正在对某个文件进行读写操作</p><ul><li>lsof 或者 <code>/proc/pid/fd</code></li></ul><h4 id="_1-lsof-工具" tabindex="-1"><a class="header-anchor" href="#_1-lsof-工具"><span>1. lsof 工具</span></a></h4><p>查看当前目录有哪些进程打开：</p><div class="language- line-numbers-mode" data-highlighter="shiki" data-ext="" data-title="" style="--shiki-light:#24292e;--shiki-dark:#abb2bf;--shiki-light-bg:#fff;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes github-light one-dark-pro vp-code"><code><span class="line"><span># /tmp 目录，查看当前打开 tmp 目录的进程</span></span>
<span class="line"><span># lsof /tmp</span></span>
<span class="line"><span>COMMAND  PID      USER   FD   TYPE DEVICE SIZE/OFF     NODE NAME</span></span>
<span class="line"><span>zsh     6607 zhangyi83  cwd    DIR  259,2    12288 14942209 /tmp</span></span>
<span class="line"><span>lsof    7370 zhangyi83  cwd    DIR  259,2    12288 14942209 /tmp</span></span>
<span class="line"><span>lsof    7371 zhangyi83  cwd    DIR  259,2    12288 14942209 /tmp</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>lsof 命令只能查看静态信息，并且打开并不代表一定读取了，对于 cat、echo 这种转瞬即逝的操作，lsof 捕捉不到</p>`,22)]))}const h=a(s,[["render",l],["__file","1.IO监控工具.html.vue"]]),c=JSON.parse('{"path":"/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E6%96%87%E4%BB%B6%E7%AE%A1%E7%90%86/%E5%B7%A5%E5%85%B7%E8%BF%90%E7%BB%B4/1.IO%E7%9B%91%E6%8E%A7%E5%B7%A5%E5%85%B7.html","title":"1.IO监控工具","lang":"zh-CN","frontmatter":{"title":"1.IO监控工具","description":"监控与分析 一、系统级 IO 监控 1. iostat 工具 统计的是通用块层经过合并后，直接向设备提交的 IO 数据，可以反映系统整体的 IO 状况，但是有如下缺点： 距离业务层比较遥远，和代码中的 read、write 不对应（由于系统预读、pagecache、IO 调度算法等） 是系统级，没有办法精确到进程，比如得知磁盘很忙，但是没办法告诉我们谁...","head":[["meta",{"property":"og:url","content":"https://noahyz.github.io/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E6%96%87%E4%BB%B6%E7%AE%A1%E7%90%86/%E5%B7%A5%E5%85%B7%E8%BF%90%E7%BB%B4/1.IO%E7%9B%91%E6%8E%A7%E5%B7%A5%E5%85%B7.html"}],["meta",{"property":"og:site_name","content":"noahyz的博客"}],["meta",{"property":"og:title","content":"1.IO监控工具"}],["meta",{"property":"og:description","content":"监控与分析 一、系统级 IO 监控 1. iostat 工具 统计的是通用块层经过合并后，直接向设备提交的 IO 数据，可以反映系统整体的 IO 状况，但是有如下缺点： 距离业务层比较遥远，和代码中的 read、write 不对应（由于系统预读、pagecache、IO 调度算法等） 是系统级，没有办法精确到进程，比如得知磁盘很忙，但是没办法告诉我们谁..."}],["meta",{"property":"og:type","content":"article"}],["meta",{"property":"og:locale","content":"zh-CN"}],["meta",{"property":"article:author","content":"noahyz"}],["script",{"type":"application/ld+json"},"{\\"@context\\":\\"https://schema.org\\",\\"@type\\":\\"Article\\",\\"headline\\":\\"1.IO监控工具\\",\\"image\\":[\\"\\"],\\"dateModified\\":null,\\"author\\":[{\\"@type\\":\\"Person\\",\\"name\\":\\"noahyz\\",\\"url\\":\\"/about-the-author/\\"}]}"]]},"headers":[{"level":2,"title":"监控与分析","slug":"监控与分析","link":"#监控与分析","children":[{"level":3,"title":"一、系统级 IO 监控","slug":"一、系统级-io-监控","link":"#一、系统级-io-监控","children":[]},{"level":3,"title":"二、进程级别 IO 监控","slug":"二、进程级别-io-监控","link":"#二、进程级别-io-监控","children":[]},{"level":3,"title":"三、业务级 IO 监控","slug":"三、业务级-io-监控","link":"#三、业务级-io-监控","children":[]},{"level":3,"title":"四、文件级 IO 监控","slug":"四、文件级-io-监控","link":"#四、文件级-io-监控","children":[]}]}],"git":{},"readingTime":{"minutes":1.57,"words":472},"filePathRelative":"操作系统/文件管理/工具运维/1.IO监控工具.md","excerpt":"<h2>监控与分析</h2>\\n<h3>一、系统级 IO 监控</h3>\\n<h4>1. iostat 工具</h4>\\n<p>统计的是通用块层经过合并后，直接向设备提交的 IO 数据，可以反映系统整体的 IO 状况，但是有如下缺点：</p>\\n<ul>\\n<li>距离业务层比较遥远，和代码中的 read、write 不对应（由于系统预读、pagecache、IO 调度算法等）</li>\\n<li>是系统级，没有办法精确到进程，比如得知磁盘很忙，但是没办法告诉我们谁在忙？忙什么？</li>\\n</ul>\\n<h3>二、进程级别 IO 监控</h3>\\n<h4>1. iotop 和 pidstat 工具</h4>","autoDesc":true}');export{h as comp,c as data};

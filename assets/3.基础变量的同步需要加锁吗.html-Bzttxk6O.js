import{_ as a}from"./plugin-vue_export-helper-DlAUqK2U.js";import{c as t,a as i,o as l}from"./app-D1zlwylF.js";const n={};function p(o,e){return l(),t("div",null,e[0]||(e[0]=[i(`<h2 id="基础变量的同步需要加锁吗" tabindex="-1"><a class="header-anchor" href="#基础变量的同步需要加锁吗"><span>基础变量的同步需要加锁吗</span></a></h2><p>我们在加锁时，可能会遇到这种问题，基础变量的同步是否需要加锁？</p><p>这个问题我们需要对齐到具体的场景，才能针对具体问题具体化。</p><h3 id="一、前置条件" tabindex="-1"><a class="header-anchor" href="#一、前置条件"><span>一、前置条件</span></a></h3><p>在针对此类问题时，我们先明确一下我们要思考那些方向。</p><ul><li>我们的机器是 64位还是 32位？</li><li>我们对临界区做的操作是否为原子操作？</li></ul><p>因为内存对齐，CPU 的一个读周期或者是一个写周期仅需要一个总线周期，在这个总线周期内就可以处理一个原子操作。一个总线周期结束前 CPU 不会被抢占，就是中断发生也不会导致一个总线周期执行一半时 CPU 被抢占。</p><p>比如 <code>a = 10</code> 这句代码：</p><ul><li>在 64 位机器上，假设变量 a 的类型是小于等于 8 字节的。那么 <code>a=10</code> 我们就可以认为是原子操作。</li><li>但是在 32 位机器上，如果变量 a 的类型是 8 字节的。那么 <code>a=10</code> 可能就需要 CPU 操作两次，每次操作 4 字节。</li></ul><p>我们明白这些之后，再来探讨不同的场景</p><h3 id="二、对齐场景" tabindex="-1"><a class="header-anchor" href="#二、对齐场景"><span>二、对齐场景</span></a></h3><p>我们举例一个场景：64位机器上，有一个 8 字节的全局变量。线程 A 仅对这个全局变量进行读操作；线程 B 仅对这个全局变量进行写操作。那么这两个线程在操作这个全局变量时需要加锁吗？</p><p>乍一看，好像不需要加锁。那产生一个问题，那要原子变量 atomic 是用来干嘛的？原因是我们的操作不一定是原子的，比如说线程写操作。<code>a=10</code> 和 <code>a+=10</code> 这两句代码，区别就很大。<code>a+=10</code> 不是原子操作，可以拆分成三条语句：</p><ol><li>把 a 读到寄存器中</li><li>将寄存器中的值加 10</li><li>把寄存器中的值写到 a 中</li></ol><p>如果写线程执行的操作不是原子操作，那可能又需要加锁了。</p><p>我举一个需要加锁的场景：假设 a 起始为 0，线程 A 的操作为：</p><div class="language- line-numbers-mode" data-highlighter="shiki" data-ext="" data-title="" style="--shiki-light:#24292e;--shiki-dark:#abb2bf;--shiki-light-bg:#fff;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes github-light one-dark-pro vp-code"><code><span class="line"><span>if (a == 0) {</span></span>
<span class="line"><span>	b = a + 1;</span></span>
<span class="line"><span>}</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>那么就有可能出现，刚开始线程 B 执行 <code>a+=10</code>，执行了两步之后，线程 A 抢到了 CPU，此时 a 仍然为 0，那么线程 A 读取到 a 为 0 了；然后线程 A 认为 <code>b=a+1</code> 的结果应该是 1；但是紧接着线程 B 又抢到了 CPU，执行了第三步，此时 a 为 10 了。然后线程 A 抢到 CPU 执行 <code>b=a+1</code> 的结果为 11 了。</p><p>这就导致出现了幻读。有点像数据库的隔离级别。这种场景读线程需要使用临界区元素的值，那么就一定需要加锁。</p><p>我再举一个不需要加锁的场景：线程 A 获取到 a 的值后，只是做了打印，没有其余操作。那么就不用加锁了，因为线程 A 不管在什么时间，读取到的 a 都是一个完整值。</p><h3 id="三、小总结" tabindex="-1"><a class="header-anchor" href="#三、小总结"><span>三、小总结</span></a></h3><p>加锁的目的是保护数据的一致性。也就是说，在加锁临界区内，不同线程看到的数据变化是一致的。</p><p>如果在不需要保护的情况下，数据本身就可以一致，那也就不用加锁了。</p>`,23)]))}const c=a(n,[["render",p],["__file","3.基础变量的同步需要加锁吗.html.vue"]]),d=JSON.parse('{"path":"/%E6%8A%80%E6%9C%AF%E4%B8%93%E9%A2%98/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/3.%E5%9F%BA%E7%A1%80%E5%8F%98%E9%87%8F%E7%9A%84%E5%90%8C%E6%AD%A5%E9%9C%80%E8%A6%81%E5%8A%A0%E9%94%81%E5%90%97.html","title":"3. 基础变量的同步需要加锁吗","lang":"zh-CN","frontmatter":{"title":"3. 基础变量的同步需要加锁吗","date":"2023-01-19T11:11:41.000Z","tags":["linux"],"description":"基础变量的同步需要加锁吗 我们在加锁时，可能会遇到这种问题，基础变量的同步是否需要加锁？ 这个问题我们需要对齐到具体的场景，才能针对具体问题具体化。 一、前置条件 在针对此类问题时，我们先明确一下我们要思考那些方向。 我们的机器是 64位还是 32位？ 我们对临界区做的操作是否为原子操作？ 因为内存对齐，CPU 的一个读周期或者是一个写周期仅需要一个总...","head":[["meta",{"property":"og:url","content":"https://noahyz.github.io/%E6%8A%80%E6%9C%AF%E4%B8%93%E9%A2%98/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/3.%E5%9F%BA%E7%A1%80%E5%8F%98%E9%87%8F%E7%9A%84%E5%90%8C%E6%AD%A5%E9%9C%80%E8%A6%81%E5%8A%A0%E9%94%81%E5%90%97.html"}],["meta",{"property":"og:site_name","content":"noahyz的博客"}],["meta",{"property":"og:title","content":"3. 基础变量的同步需要加锁吗"}],["meta",{"property":"og:description","content":"基础变量的同步需要加锁吗 我们在加锁时，可能会遇到这种问题，基础变量的同步是否需要加锁？ 这个问题我们需要对齐到具体的场景，才能针对具体问题具体化。 一、前置条件 在针对此类问题时，我们先明确一下我们要思考那些方向。 我们的机器是 64位还是 32位？ 我们对临界区做的操作是否为原子操作？ 因为内存对齐，CPU 的一个读周期或者是一个写周期仅需要一个总..."}],["meta",{"property":"og:type","content":"article"}],["meta",{"property":"og:locale","content":"zh-CN"}],["meta",{"property":"article:author","content":"noahyz"}],["meta",{"property":"article:tag","content":"linux"}],["meta",{"property":"article:published_time","content":"2023-01-19T11:11:41.000Z"}],["script",{"type":"application/ld+json"},"{\\"@context\\":\\"https://schema.org\\",\\"@type\\":\\"Article\\",\\"headline\\":\\"3. 基础变量的同步需要加锁吗\\",\\"image\\":[\\"\\"],\\"datePublished\\":\\"2023-01-19T11:11:41.000Z\\",\\"dateModified\\":null,\\"author\\":[{\\"@type\\":\\"Person\\",\\"name\\":\\"noahyz\\",\\"url\\":\\"/about-the-author/\\"}]}"]]},"headers":[{"level":2,"title":"基础变量的同步需要加锁吗","slug":"基础变量的同步需要加锁吗","link":"#基础变量的同步需要加锁吗","children":[{"level":3,"title":"一、前置条件","slug":"一、前置条件","link":"#一、前置条件","children":[]},{"level":3,"title":"二、对齐场景","slug":"二、对齐场景","link":"#二、对齐场景","children":[]},{"level":3,"title":"三、小总结","slug":"三、小总结","link":"#三、小总结","children":[]}]}],"git":{},"readingTime":{"minutes":2.99,"words":898},"filePathRelative":"技术专题/并发编程/3.基础变量的同步需要加锁吗.md","localizedDate":"2023年1月19日","excerpt":"<h2>基础变量的同步需要加锁吗</h2>\\n<p>我们在加锁时，可能会遇到这种问题，基础变量的同步是否需要加锁？</p>\\n<p>这个问题我们需要对齐到具体的场景，才能针对具体问题具体化。</p>\\n<h3>一、前置条件</h3>\\n<p>在针对此类问题时，我们先明确一下我们要思考那些方向。</p>\\n<ul>\\n<li>我们的机器是 64位还是 32位？</li>\\n<li>我们对临界区做的操作是否为原子操作？</li>\\n</ul>\\n<p>因为内存对齐，CPU 的一个读周期或者是一个写周期仅需要一个总线周期，在这个总线周期内就可以处理一个原子操作。一个总线周期结束前 CPU 不会被抢占，就是中断发生也不会导致一个总线周期执行一半时 CPU 被抢占。</p>","autoDesc":true}');export{c as comp,d as data};

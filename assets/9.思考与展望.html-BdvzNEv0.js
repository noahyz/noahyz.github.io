import{_ as t}from"./plugin-vue_export-helper-DlAUqK2U.js";import{c as r,a as p,o}from"./app-D1zlwylF.js";const a={};function n(l,e){return o(),r("div",null,e[0]||(e[0]=[p('<h2 id="思考与展望" tabindex="-1"><a class="header-anchor" href="#思考与展望"><span>思考与展望</span></a></h2><h3 id="一、无锁队列一定优于有锁队列吗" tabindex="-1"><a class="header-anchor" href="#一、无锁队列一定优于有锁队列吗"><span>一、无锁队列一定优于有锁队列吗？</span></a></h3><p>不一定，对于 CAS 实现的硬件级的互斥，其单次操作性能比相同条件下的应用层的较为高效，但当多个线程并发时，硬件级的互斥引入的代价与应用层的锁争用同样令人惋惜。因此如果纯粹希望通过使用 CAS 无锁算法及相关数据结构而带来程序性能的大量提升是不可能的，硬件级原子操作使应用层操作变慢，而且无法再度优化。相反通过对有锁多线程程序的良好设计，可以使程序性能没有任何下降，可以实现高度的并发性。</p><p>但是我们也要看到应用层无锁的好处，比如不需要程序员再去考虑死锁、优先级反转等棘手的问题，因此在对应用程序不太复杂，而对性能要求稍高时，可以采用有锁多线程。而程序较为复杂，性能要求满足使用的情况下，可以使用应用级无锁算法。</p><h3 id="二、推荐读物" tabindex="-1"><a class="header-anchor" href="#二、推荐读物"><span>二、推荐读物</span></a></h3><ul><li><p>推荐 C++ 实现的无锁线程安全队列项目：<a href="https://github.com/cameron314/concurrentqueue" target="_blank" rel="noopener noreferrer">https://github.com/cameron314/concurrentqueue</a></p><p>此项目是比较优秀的多生产者、多消费者的无锁并发队列的工业级别的实现。</p></li><li><p>推荐文章：<a href="https://coolshell.cn/articles/8239.html" target="_blank" rel="noopener noreferrer">https://coolshell.cn/articles/8239.html</a></p><p>陈皓大佬无锁队列的说明与实现</p></li><li><p>推荐文章：<a href="https://paul.pub/cpp-memory-model/#id-fence" target="_blank" rel="noopener noreferrer">https://paul.pub/cpp-memory-model/#id-fence</a></p><p>对于内存模型讲的特别清楚，本小节关于内存模型的部分大部分参考这篇文章</p></li><li><p>推荐文章：<a href="https://en.cppreference.com/w/cpp/atomic/memory_order" target="_blank" rel="noopener noreferrer">https://en.cppreference.com/w/cpp/atomic/memory_order</a></p><p>官方对于 memory order 的定义</p></li><li><p>推荐书籍：《C++ 并发编程实战》</p><p>详细说明了 C++ 并发编程中几乎所有技巧</p></li><li><p>推荐文章：<a href="https://people.cs.pitt.edu/~xianeizhang/notes/cpp11_mem.html" target="_blank" rel="noopener noreferrer">https://people.cs.pitt.edu/~xianeizhang/notes/cpp11_mem.html</a></p><p>C++11 对于内存模型的说明</p></li><li><p>推荐文章：<a href="https://citeseerx.ist.psu.edu/viewdoc/download?doi=10.1.1.152.5245&amp;rep=rep1&amp;type=pdf" target="_blank" rel="noopener noreferrer">https://citeseerx.ist.psu.edu/viewdoc/download?doi=10.1.1.152.5245&amp;rep=rep1&amp;type=pdf</a></p><p>对于内存屏障的详细说明</p></li></ul>',6)]))}const h=t(a,[["render",n],["__file","9.思考与展望.html.vue"]]),s=JSON.parse('{"path":"/%E6%8A%80%E6%9C%AF%E4%B8%93%E9%A2%98/9%E5%A4%A9%E5%B8%A6%E4%BD%A0%E8%B5%B0%E8%BF%9B%E6%97%A0%E9%94%81%E5%8C%96%E7%BC%96%E7%A8%8B/9.%E6%80%9D%E8%80%83%E4%B8%8E%E5%B1%95%E6%9C%9B.html","title":"9. 思考与展望","lang":"zh-CN","frontmatter":{"title":"9. 思考与展望","description":"思考与展望 一、无锁队列一定优于有锁队列吗？ 不一定，对于 CAS 实现的硬件级的互斥，其单次操作性能比相同条件下的应用层的较为高效，但当多个线程并发时，硬件级的互斥引入的代价与应用层的锁争用同样令人惋惜。因此如果纯粹希望通过使用 CAS 无锁算法及相关数据结构而带来程序性能的大量提升是不可能的，硬件级原子操作使应用层操作变慢，而且无法再度优化。相反通...","head":[["meta",{"property":"og:url","content":"https://noahyz.github.io/%E6%8A%80%E6%9C%AF%E4%B8%93%E9%A2%98/9%E5%A4%A9%E5%B8%A6%E4%BD%A0%E8%B5%B0%E8%BF%9B%E6%97%A0%E9%94%81%E5%8C%96%E7%BC%96%E7%A8%8B/9.%E6%80%9D%E8%80%83%E4%B8%8E%E5%B1%95%E6%9C%9B.html"}],["meta",{"property":"og:site_name","content":"noahyz的博客"}],["meta",{"property":"og:title","content":"9. 思考与展望"}],["meta",{"property":"og:description","content":"思考与展望 一、无锁队列一定优于有锁队列吗？ 不一定，对于 CAS 实现的硬件级的互斥，其单次操作性能比相同条件下的应用层的较为高效，但当多个线程并发时，硬件级的互斥引入的代价与应用层的锁争用同样令人惋惜。因此如果纯粹希望通过使用 CAS 无锁算法及相关数据结构而带来程序性能的大量提升是不可能的，硬件级原子操作使应用层操作变慢，而且无法再度优化。相反通..."}],["meta",{"property":"og:type","content":"article"}],["meta",{"property":"og:locale","content":"zh-CN"}],["meta",{"property":"article:author","content":"noahyz"}],["script",{"type":"application/ld+json"},"{\\"@context\\":\\"https://schema.org\\",\\"@type\\":\\"Article\\",\\"headline\\":\\"9. 思考与展望\\",\\"image\\":[\\"\\"],\\"dateModified\\":null,\\"author\\":[{\\"@type\\":\\"Person\\",\\"name\\":\\"noahyz\\",\\"url\\":\\"/about-the-author/\\"}]}"]]},"headers":[{"level":2,"title":"思考与展望","slug":"思考与展望","link":"#思考与展望","children":[{"level":3,"title":"一、无锁队列一定优于有锁队列吗？","slug":"一、无锁队列一定优于有锁队列吗","link":"#一、无锁队列一定优于有锁队列吗","children":[]},{"level":3,"title":"二、推荐读物","slug":"二、推荐读物","link":"#二、推荐读物","children":[]}]}],"git":{},"readingTime":{"minutes":1.68,"words":504},"filePathRelative":"技术专题/9天带你走进无锁化编程/9.思考与展望.md","excerpt":"<h2>思考与展望</h2>\\n<h3>一、无锁队列一定优于有锁队列吗？</h3>\\n<p>不一定，对于 CAS 实现的硬件级的互斥，其单次操作性能比相同条件下的应用层的较为高效，但当多个线程并发时，硬件级的互斥引入的代价与应用层的锁争用同样令人惋惜。因此如果纯粹希望通过使用 CAS 无锁算法及相关数据结构而带来程序性能的大量提升是不可能的，硬件级原子操作使应用层操作变慢，而且无法再度优化。相反通过对有锁多线程程序的良好设计，可以使程序性能没有任何下降，可以实现高度的并发性。</p>\\n<p>但是我们也要看到应用层无锁的好处，比如不需要程序员再去考虑死锁、优先级反转等棘手的问题，因此在对应用程序不太复杂，而对性能要求稍高时，可以采用有锁多线程。而程序较为复杂，性能要求满足使用的情况下，可以使用应用级无锁算法。</p>","autoDesc":true}');export{h as comp,s as data};

import{_ as n}from"./plugin-vue_export-helper-DlAUqK2U.js";import{c as a,a as s,o as i}from"./app-D1zlwylF.js";const t={};function l(p,e){return i(),a("div",null,e[0]||(e[0]=[s(`<h2 id="c-符号的编解码" tabindex="-1"><a class="header-anchor" href="#c-符号的编解码"><span>c++ 符号的编解码</span></a></h2><p>C++ 语言在编译的时候，符号会被编译器修改，转换成 C++ ABI 标识符，正向的过程称为 mangle，反向的过程称为为 demangle。</p><h3 id="一、abi-说明" tabindex="-1"><a class="header-anchor" href="#一、abi-说明"><span>一、ABI 说明</span></a></h3><p>ABI 全称为：Application Binary Interface 。 C/C++发展的过程中，二进制兼容一直是个问题。不同编译器厂商编译的二进制代码之间兼容性不好，甚至同一个编译器的不同版本之间兼容性也不好。之后 C 语言首先拥有了统一的 ABI，而 C++ 由于其特性的复杂性和 ABI 标准推进缓慢，一直没有自己的 ABI。</p><p>这就造成的不同的编译器或者不同的编译器版本，编译后的名称可能有所不同。</p><p>每个编译器都有一套自己内部的符号编译规则，比如对于 Linux 下 G++ 而言，如下的简单的规则：</p><p>每个方法都是以 <code>_Z</code> 开头，对于嵌套的名字（比如命名空间中的名字或者类中间的名字，比如 <code>Class::Func</code>）后面紧跟 N。然后是各个命名空间和类的名字，每个名字前都是各自字符的长度，再以 E 结尾。（如果不是嵌套名字则不需要以 E 结尾）。</p><p>比如对于 <code>_Z3foov</code> 就是的函数 <code>foo()</code>，v 表示参数类型为 void。再比如：<code>N::C::Func</code> 经过修饰后为 <code>_ZN1N1C4FuncE</code>，这个函数名后面跟参数类型。</p><h3 id="二、rtti-和-type-info" tabindex="-1"><a class="header-anchor" href="#二、rtti-和-type-info"><span>二、RTTI 和 type_info</span></a></h3><p>C++ 在编译时开启 RTTI（Run-Time Type Identification，运行时类型识别）特性时，可以在代码中使用 typeid 操作符，此操作符可以对一个变量或者一个类名使用，返回一个 type_info 对象的引用。编译时会为每种使用到 RTTI 的特性的 C++ 类都建立一个唯一的 type_info 对象，并且会包含继承关系，dynamic_cast 便是根据这个对象来判断某个基类对象的指针能否向下转换成子类对象的指针。如下：</p><div class="language- line-numbers-mode" data-highlighter="shiki" data-ext="" data-title="" style="--shiki-light:#24292e;--shiki-dark:#abb2bf;--shiki-light-bg:#fff;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes github-light one-dark-pro vp-code"><code><span class="line"><span>    std::string str;</span></span>
<span class="line"><span>    if (typeid(str) == typeid(std::string)) {</span></span>
<span class="line"><span>        std::cout &lt;&lt; &quot;same type&quot; &lt;&lt; std::endl;</span></span>
<span class="line"><span>    } else {</span></span>
<span class="line"><span>        std::cout &lt;&lt; &quot;different type&quot; &lt;&lt; std::endl;</span></span>
<span class="line"><span>    }</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3 id="三、mangle-和-demangle" tabindex="-1"><a class="header-anchor" href="#三、mangle-和-demangle"><span>三、mangle 和 demangle</span></a></h3><p>typeinfo 中有一个 name 的方法，可以返回一个符号被 mangle 后的名字。</p><div class="language- line-numbers-mode" data-highlighter="shiki" data-ext="" data-title="" style="--shiki-light:#24292e;--shiki-dark:#abb2bf;--shiki-light-bg:#fff;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes github-light one-dark-pro vp-code"><code><span class="line"><span>std::cout &lt;&lt; typeid(std::string).name() &lt;&lt; std::endl;</span></span>
<span class="line"><span>// 打印出：NSt7__cxx1112basic_stringIcSt11char_traitsIcESaIcEEE</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div></div></div><p>关于 demangle，C++ 提供了一个函数 <code>abi::__cxa_demangle</code> 用于解析符号。还有比如 <code>c++filt</code> 这些工具都可以用来解析符号。</p><div class="language- line-numbers-mode" data-highlighter="shiki" data-ext="" data-title="" style="--shiki-light:#24292e;--shiki-dark:#abb2bf;--shiki-light-bg:#fff;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes github-light one-dark-pro vp-code"><code><span class="line"><span>    </span></span>
<span class="line"><span>struct empty {</span></span>
<span class="line"><span>};</span></span>
<span class="line"><span></span></span>
<span class="line"><span>template &lt;typename T, int N&gt;</span></span>
<span class="line"><span>struct bar {</span></span>
<span class="line"><span></span></span>
<span class="line"><span>};</span></span>
<span class="line"><span>    </span></span>
<span class="line"><span>    bar&lt;empty, 17&gt; u;</span></span>
<span class="line"><span>    const std::type_info&amp; ti = typeid(u);</span></span>
<span class="line"><span>    realname = abi::__cxa_demangle(ti.name(), 0, 0, &amp;status);</span></span>
<span class="line"><span>    if (realname != nullptr) {</span></span>
<span class="line"><span>        std::cout &lt;&lt; ti.name() &lt;&lt; &quot;\\t =&gt; &quot; &lt;&lt; realname &lt;&lt; &quot;\\t : &quot; &lt;&lt; status &lt;&lt; std::endl;</span></span>
<span class="line"><span>        free(realname);</span></span>
<span class="line"><span>    }</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div>`,16)]))}const r=n(t,[["render",l],["__file","1.C__符号的编解码.html.vue"]]),o=JSON.parse('{"path":"/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/c__%E8%AF%AD%E8%A8%80/%E5%BA%95%E5%B1%82%E5%86%85%E6%A0%B8/1.C__%E7%AC%A6%E5%8F%B7%E7%9A%84%E7%BC%96%E8%A7%A3%E7%A0%81.html","title":"1.C++符号的编解码","lang":"zh-CN","frontmatter":{"title":"1.C++符号的编解码","description":"c++ 符号的编解码 C++ 语言在编译的时候，符号会被编译器修改，转换成 C++ ABI 标识符，正向的过程称为 mangle，反向的过程称为为 demangle。 一、ABI 说明 ABI 全称为：Application Binary Interface 。 C/C++发展的过程中，二进制兼容一直是个问题。不同编译器厂商编译的二进制代码之间兼容性不...","head":[["meta",{"property":"og:url","content":"https://noahyz.github.io/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/c__%E8%AF%AD%E8%A8%80/%E5%BA%95%E5%B1%82%E5%86%85%E6%A0%B8/1.C__%E7%AC%A6%E5%8F%B7%E7%9A%84%E7%BC%96%E8%A7%A3%E7%A0%81.html"}],["meta",{"property":"og:site_name","content":"noahyz的博客"}],["meta",{"property":"og:title","content":"1.C++符号的编解码"}],["meta",{"property":"og:description","content":"c++ 符号的编解码 C++ 语言在编译的时候，符号会被编译器修改，转换成 C++ ABI 标识符，正向的过程称为 mangle，反向的过程称为为 demangle。 一、ABI 说明 ABI 全称为：Application Binary Interface 。 C/C++发展的过程中，二进制兼容一直是个问题。不同编译器厂商编译的二进制代码之间兼容性不..."}],["meta",{"property":"og:type","content":"article"}],["meta",{"property":"og:locale","content":"zh-CN"}],["meta",{"property":"article:author","content":"noahyz"}],["script",{"type":"application/ld+json"},"{\\"@context\\":\\"https://schema.org\\",\\"@type\\":\\"Article\\",\\"headline\\":\\"1.C++符号的编解码\\",\\"image\\":[\\"\\"],\\"dateModified\\":null,\\"author\\":[{\\"@type\\":\\"Person\\",\\"name\\":\\"noahyz\\",\\"url\\":\\"/about-the-author/\\"}]}"]]},"headers":[{"level":2,"title":"c++ 符号的编解码","slug":"c-符号的编解码","link":"#c-符号的编解码","children":[{"level":3,"title":"一、ABI 说明","slug":"一、abi-说明","link":"#一、abi-说明","children":[]},{"level":3,"title":"二、RTTI 和 type_info","slug":"二、rtti-和-type-info","link":"#二、rtti-和-type-info","children":[]},{"level":3,"title":"三、mangle 和 demangle","slug":"三、mangle-和-demangle","link":"#三、mangle-和-demangle","children":[]}]}],"git":{},"readingTime":{"minutes":2.2,"words":660},"filePathRelative":"编程语言/c++语言/底层内核/1.C++符号的编解码.md","excerpt":"<h2>c++ 符号的编解码</h2>\\n<p>C++ 语言在编译的时候，符号会被编译器修改，转换成 C++ ABI 标识符，正向的过程称为 mangle，反向的过程称为为 demangle。</p>\\n<h3>一、ABI 说明</h3>\\n<p>ABI 全称为：Application Binary Interface 。 C/C++发展的过程中，二进制兼容一直是个问题。不同编译器厂商编译的二进制代码之间兼容性不好，甚至同一个编译器的不同版本之间兼容性也不好。之后 C 语言首先拥有了统一的 ABI，而 C++ 由于其特性的复杂性和 ABI 标准推进缓慢，一直没有自己的 ABI。</p>\\n<p>这就造成的不同的编译器或者不同的编译器版本，编译后的名称可能有所不同。</p>","autoDesc":true}');export{r as comp,o as data};

import{_ as n}from"./plugin-vue_export-helper-DlAUqK2U.js";import{c as a,a as i,o as e}from"./app-D1zlwylF.js";const l="/assets/%E7%BA%BF%E7%A8%8BPCB-1Q9imQjl.png",p={};function t(c,s){return e(),a("div",null,s[0]||(s[0]=[i(`<h3 id="一、线程的实现" tabindex="-1"><a class="header-anchor" href="#一、线程的实现"><span>一、线程的实现</span></a></h3><p>先在内核空间中申请一页内存（4KB），用线程 PCB 结构的指针，指向这块内存。</p><p>我们先来看看 PCB 结构都有哪些字段：</p><div class="language- line-numbers-mode" data-highlighter="shiki" data-ext="" data-title="" style="--shiki-light:#24292e;--shiki-dark:#abb2bf;--shiki-light-bg:#fff;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes github-light one-dark-pro vp-code"><code><span class="line"><span>struct task_struct {</span></span>
<span class="line"><span>    // 内核线程所用的内核栈</span></span>
<span class="line"><span>    uint32_t* self_kernel_stack;</span></span>
<span class="line"><span>    pid_t pid;</span></span>
<span class="line"><span>    // 状态</span></span>
<span class="line"><span>    enum task_status status;</span></span>
<span class="line"><span>    char name[TASK_NAME_LEN];</span></span>
<span class="line"><span>    // 优先级</span></span>
<span class="line"><span>    uint8_t priority;</span></span>
<span class="line"><span>    // 每次在处理器上执行的时钟滴答数</span></span>
<span class="line"><span>    uint8_t ticks;</span></span>
<span class="line"><span>    // 此任务自从上 CPU 运行后至今占用了多少 cpu 滴答数</span></span>
<span class="line"><span>    // 任务运行了多久</span></span>
<span class="line"><span>    uint32_t elapsed_ticks;</span></span>
<span class="line"><span>    // 用于线程在一般队列中的节点（比如：就绪队列或者其他队列）</span></span>
<span class="line"><span>    struct list_elem general_tag;</span></span>
<span class="line"><span>    // 用于线程队列 thread_all_list 中的节点</span></span>
<span class="line"><span>    struct list_elem all_list_tag;</span></span>
<span class="line"><span>    // 进程自己页表的虚拟地址</span></span>
<span class="line"><span>    // 如果是线程，则此字段为 NULL</span></span>
<span class="line"><span>    uint32_t* pg_dir;</span></span>
<span class="line"><span>    // 用户进程的虚拟地址</span></span>
<span class="line"><span>    struct virtual_addr user_process_vaddr;</span></span>
<span class="line"><span>    // 用户进程内存块描述符</span></span>
<span class="line"><span>    struct mem_block_desc u_block_desc[DESC_CNT];</span></span>
<span class="line"><span>    // 已打开文件数组</span></span>
<span class="line"><span>    int32_t fd_table[MAX_FILES_OPEN_PER_PROC];</span></span>
<span class="line"><span>    // 进程所在的工作目录的 inode 编号</span></span>
<span class="line"><span>    uint32_t cwd_inode_nr;</span></span>
<span class="line"><span>    // 父进程 pid</span></span>
<span class="line"><span>    int16_t parent_pid;</span></span>
<span class="line"><span>    // 栈的边界标记，用于检测栈的溢出</span></span>
<span class="line"><span>    // 这个字段因为要作为边界标记，所以必须放在结构体的末尾</span></span>
<span class="line"><span>    // 我们的 PCB 和 0 级栈是在同一页中，栈位于页的顶端并向下发展</span></span>
<span class="line"><span>    // 因此担心压栈过程中会把 PCB 中的信息给覆盖，所以每次在线程或进程调度时要判断是否触及到了进程信息的边界</span></span>
<span class="line"><span>    // 也就是判断 stack_magic 的值是否为初始化的内容。其实 stack_magic 是一个魔数</span></span>
<span class="line"><span>    uint32_t stack_magic;</span></span>
<span class="line"><span>};</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>然后初始化 PCB，包括：</p><ul><li>给线程设置一个 pid 或者 tid、设置线程名字、将线程的状态设置为运行状态</li><li>设置线程的优先级（用于线程在 CPU 上执行的时间片长度，优先级越高，执行的时间片越长）</li><li>设置线程的时间片，目前线程的优先级就是时间片</li><li>初始化线程在 0 特权级下所用的栈（在线程创建时，他被初始化为线程 PCB 的最顶端），将来线程在内核态下的任何栈操作都是用此 PCB 中的栈。操作为：<code>thread-&gt;self_kernel_stack = (uint32_t*)((uint32_t)pthread + PAGE_SIZE);</code></li><li>初始化线程的标签，其实就是双向链表的节点。线程要被调度，就需要放到就绪队列（双向链表实现）中。还有一个全部线程队列（双向链表实现），存储所有线程（包括就绪的、阻塞的、正在执行的）。所以线程有两个标签。</li><li>设置页表，如果是线程，此值为空；如果是进程，此值是页表的虚拟地址。线程和进程最大的区别就是进程独享自己的地址空间，即进程有自己的页表，而线程共享所在进程的地址空间，即线程无页表。</li><li>设置魔数，魔数的位置在线程 PCB 信息的最边缘。如果出现 0 级特权栈溢出了，第一个被覆盖的就是这个魔数。因此用它来检测是否出现 0 特权级下的栈是否溢出</li></ul><p>然后开始创建线程，我们需要初始化线程栈，将待执行的函数和参数放到线程栈中相应的位置。</p><ul><li><p>预留线程所使用的中断栈。中断栈有两个作用：1. 线程进入中断后，中断代码会通过此栈来保存上下文；2. 用户进程的初始信息会放在中断栈。</p><p>操作：<code>pthread-&gt;self_kernel_stack -= sizeof(struct intr_stack);</code>。操作完之后 self_kernel_stack 指针指向 PCB 中的中断栈下面的地址</p></li><li><p>预留线程栈，操作：<code>pthread-&gt;self_kernel_stack -= sizeof(struct thread_stack);</code></p><p>然后初始化线程栈结构中的内容。</p><p>线程栈结构中 eip 指针指向一个函数 kernel_thread，内部做两件事情，开中断和执行用户线程函数。然后分别填充用户线程函数和函数参数。最后将 ebp、ebx、esi、edi 这 4 个寄存器初始化为 0，因为线程中函数尚未执行，在执行过程中才会有值。</p></li></ul><p>最后开启线程，将 <code>thread-&gt;self_kernel_stack</code> 的值作为栈顶，此时 <code>thread-&gt;self_kernel_stack</code> 指向线程栈的最低处。接下来，使用 pop 指令将栈中数值弹入填充 ebp、ebx、edi、esi 四个寄存器。最后使用 ret 指令把栈顶的数据作为返回地址送上处理器的 EIP 寄存器。那么此时 EIP 寄存器指向的就是我们之前填充的 kernel_thread 函数，处理器就会去执行用户线程函数。</p><p>结构如下图：</p><img src="`+l+'" style="zoom:67%;">',11)]))}const v=n(p,[["render",t],["__file","4.线程实现.html.vue"]]),u=JSON.parse('{"path":"/%E6%8A%80%E6%9C%AF%E4%B8%93%E9%A2%98/%E6%89%8B%E5%86%99%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/5.%E8%BF%9B%E7%A8%8B%E5%92%8C%E7%BA%BF%E7%A8%8B/4.%E7%BA%BF%E7%A8%8B%E5%AE%9E%E7%8E%B0.html","title":"线程的实现","lang":"zh-CN","frontmatter":{"title":"线程的实现","description":"一、线程的实现 先在内核空间中申请一页内存（4KB），用线程 PCB 结构的指针，指向这块内存。 我们先来看看 PCB 结构都有哪些字段： 然后初始化 PCB，包括： 给线程设置一个 pid 或者 tid、设置线程名字、将线程的状态设置为运行状态 设置线程的优先级（用于线程在 CPU 上执行的时间片长度，优先级越高，执行的时间片越长） 设置线程的时间片...","head":[["meta",{"property":"og:url","content":"https://noahyz.github.io/%E6%8A%80%E6%9C%AF%E4%B8%93%E9%A2%98/%E6%89%8B%E5%86%99%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/5.%E8%BF%9B%E7%A8%8B%E5%92%8C%E7%BA%BF%E7%A8%8B/4.%E7%BA%BF%E7%A8%8B%E5%AE%9E%E7%8E%B0.html"}],["meta",{"property":"og:site_name","content":"noahyz的博客"}],["meta",{"property":"og:title","content":"线程的实现"}],["meta",{"property":"og:description","content":"一、线程的实现 先在内核空间中申请一页内存（4KB），用线程 PCB 结构的指针，指向这块内存。 我们先来看看 PCB 结构都有哪些字段： 然后初始化 PCB，包括： 给线程设置一个 pid 或者 tid、设置线程名字、将线程的状态设置为运行状态 设置线程的优先级（用于线程在 CPU 上执行的时间片长度，优先级越高，执行的时间片越长） 设置线程的时间片..."}],["meta",{"property":"og:type","content":"article"}],["meta",{"property":"og:locale","content":"zh-CN"}],["meta",{"property":"article:author","content":"noahyz"}],["script",{"type":"application/ld+json"},"{\\"@context\\":\\"https://schema.org\\",\\"@type\\":\\"Article\\",\\"headline\\":\\"线程的实现\\",\\"image\\":[\\"\\"],\\"dateModified\\":null,\\"author\\":[{\\"@type\\":\\"Person\\",\\"name\\":\\"noahyz\\",\\"url\\":\\"/about-the-author/\\"}]}"]]},"headers":[{"level":3,"title":"一、线程的实现","slug":"一、线程的实现","link":"#一、线程的实现","children":[]}],"git":{},"readingTime":{"minutes":3.95,"words":1184},"filePathRelative":"技术专题/手写操作系统/5.进程和线程/4.线程实现.md","excerpt":"<h3>一、线程的实现</h3>\\n<p>先在内核空间中申请一页内存（4KB），用线程 PCB 结构的指针，指向这块内存。</p>\\n<p>我们先来看看 PCB 结构都有哪些字段：</p>\\n<div class=\\"language- line-numbers-mode\\" data-highlighter=\\"shiki\\" data-ext=\\"\\" data-title=\\"\\" style=\\"--shiki-light:#24292e;--shiki-dark:#abb2bf;--shiki-light-bg:#fff;--shiki-dark-bg:#282c34\\"><pre class=\\"shiki shiki-themes github-light one-dark-pro vp-code\\"><code><span class=\\"line\\"><span>struct task_struct {</span></span>\\n<span class=\\"line\\"><span>    // 内核线程所用的内核栈</span></span>\\n<span class=\\"line\\"><span>    uint32_t* self_kernel_stack;</span></span>\\n<span class=\\"line\\"><span>    pid_t pid;</span></span>\\n<span class=\\"line\\"><span>    // 状态</span></span>\\n<span class=\\"line\\"><span>    enum task_status status;</span></span>\\n<span class=\\"line\\"><span>    char name[TASK_NAME_LEN];</span></span>\\n<span class=\\"line\\"><span>    // 优先级</span></span>\\n<span class=\\"line\\"><span>    uint8_t priority;</span></span>\\n<span class=\\"line\\"><span>    // 每次在处理器上执行的时钟滴答数</span></span>\\n<span class=\\"line\\"><span>    uint8_t ticks;</span></span>\\n<span class=\\"line\\"><span>    // 此任务自从上 CPU 运行后至今占用了多少 cpu 滴答数</span></span>\\n<span class=\\"line\\"><span>    // 任务运行了多久</span></span>\\n<span class=\\"line\\"><span>    uint32_t elapsed_ticks;</span></span>\\n<span class=\\"line\\"><span>    // 用于线程在一般队列中的节点（比如：就绪队列或者其他队列）</span></span>\\n<span class=\\"line\\"><span>    struct list_elem general_tag;</span></span>\\n<span class=\\"line\\"><span>    // 用于线程队列 thread_all_list 中的节点</span></span>\\n<span class=\\"line\\"><span>    struct list_elem all_list_tag;</span></span>\\n<span class=\\"line\\"><span>    // 进程自己页表的虚拟地址</span></span>\\n<span class=\\"line\\"><span>    // 如果是线程，则此字段为 NULL</span></span>\\n<span class=\\"line\\"><span>    uint32_t* pg_dir;</span></span>\\n<span class=\\"line\\"><span>    // 用户进程的虚拟地址</span></span>\\n<span class=\\"line\\"><span>    struct virtual_addr user_process_vaddr;</span></span>\\n<span class=\\"line\\"><span>    // 用户进程内存块描述符</span></span>\\n<span class=\\"line\\"><span>    struct mem_block_desc u_block_desc[DESC_CNT];</span></span>\\n<span class=\\"line\\"><span>    // 已打开文件数组</span></span>\\n<span class=\\"line\\"><span>    int32_t fd_table[MAX_FILES_OPEN_PER_PROC];</span></span>\\n<span class=\\"line\\"><span>    // 进程所在的工作目录的 inode 编号</span></span>\\n<span class=\\"line\\"><span>    uint32_t cwd_inode_nr;</span></span>\\n<span class=\\"line\\"><span>    // 父进程 pid</span></span>\\n<span class=\\"line\\"><span>    int16_t parent_pid;</span></span>\\n<span class=\\"line\\"><span>    // 栈的边界标记，用于检测栈的溢出</span></span>\\n<span class=\\"line\\"><span>    // 这个字段因为要作为边界标记，所以必须放在结构体的末尾</span></span>\\n<span class=\\"line\\"><span>    // 我们的 PCB 和 0 级栈是在同一页中，栈位于页的顶端并向下发展</span></span>\\n<span class=\\"line\\"><span>    // 因此担心压栈过程中会把 PCB 中的信息给覆盖，所以每次在线程或进程调度时要判断是否触及到了进程信息的边界</span></span>\\n<span class=\\"line\\"><span>    // 也就是判断 stack_magic 的值是否为初始化的内容。其实 stack_magic 是一个魔数</span></span>\\n<span class=\\"line\\"><span>    uint32_t stack_magic;</span></span>\\n<span class=\\"line\\"><span>};</span></span></code></pre>\\n<div class=\\"line-numbers\\" aria-hidden=\\"true\\" style=\\"counter-reset:line-number 0\\"><div class=\\"line-number\\"></div><div class=\\"line-number\\"></div><div class=\\"line-number\\"></div><div class=\\"line-number\\"></div><div class=\\"line-number\\"></div><div class=\\"line-number\\"></div><div class=\\"line-number\\"></div><div class=\\"line-number\\"></div><div class=\\"line-number\\"></div><div class=\\"line-number\\"></div><div class=\\"line-number\\"></div><div class=\\"line-number\\"></div><div class=\\"line-number\\"></div><div class=\\"line-number\\"></div><div class=\\"line-number\\"></div><div class=\\"line-number\\"></div><div class=\\"line-number\\"></div><div class=\\"line-number\\"></div><div class=\\"line-number\\"></div><div class=\\"line-number\\"></div><div class=\\"line-number\\"></div><div class=\\"line-number\\"></div><div class=\\"line-number\\"></div><div class=\\"line-number\\"></div><div class=\\"line-number\\"></div><div class=\\"line-number\\"></div><div class=\\"line-number\\"></div><div class=\\"line-number\\"></div><div class=\\"line-number\\"></div><div class=\\"line-number\\"></div><div class=\\"line-number\\"></div><div class=\\"line-number\\"></div><div class=\\"line-number\\"></div><div class=\\"line-number\\"></div><div class=\\"line-number\\"></div><div class=\\"line-number\\"></div><div class=\\"line-number\\"></div><div class=\\"line-number\\"></div></div></div>","autoDesc":true}');export{v as comp,u as data};

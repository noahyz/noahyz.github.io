import{_ as t}from"./plugin-vue_export-helper-DlAUqK2U.js";import{c as i,a as l,o as d}from"./app-D1zlwylF.js";const o="/assets/0xE820%E8%AF%B4%E6%98%8E%E4%B8%80-BuJWPr9Q.png",a="/assets/0xE820%E8%AF%B4%E6%98%8E%E4%BA%8C-C4dxTJKQ.png",n="/assets/0x801-QXlvW9_T.png",r="/assets/0x88-D4aUNTEv.png",c={};function p(B,e){return d(),i("div",null,e[0]||(e[0]=[l('<h2 id="获取物理内存容量" tabindex="-1"><a class="header-anchor" href="#获取物理内存容量"><span>获取物理内存容量</span></a></h2><p>linux 中获取物理内存容量是通过 BIOS 中断 0x15 实现，分别是 BIOS 中断 0x15 的 3 个子功能，子功能号要存放到寄存器 EAX 或 AX 中。如下：</p><ul><li><code>EAX=0xE820</code> ：遍历主机上全部内存</li><li><code>AX=0xE801</code>：分别检测低 15MB 和 16MB - 4GB 的内存，最大支持 4GB</li><li><code>AH=0x88</code>：最多检测出 64MB 内存，实际内存超过此容量也按照 64MB 返回</li></ul><h3 id="一、利用-0xe820-获取内存" tabindex="-1"><a class="header-anchor" href="#一、利用-0xe820-获取内存"><span>一、利用 <code>0xE820</code> 获取内存</span></a></h3><p>BIOS 中断 0x15 的子功能 0xE820 能够获取系统的内存布局。返回的内存信息比较丰富，包括多个属性字段，使用“地址范围描述符（Address Range Descriptor Structure，ARDS）”这种结构来存储。如下：</p><table><thead><tr><th>字节偏移量</th><th>属性名称</th><th>描述</th></tr></thead><tbody><tr><td>0</td><td>BaseAddrLow</td><td>基地址的低 32 位</td></tr><tr><td>4</td><td>BaseAddrHigh</td><td>基地址的高 32 位</td></tr><tr><td>8</td><td>LengthLow</td><td>内存长度的低 32 位，以字节为单位</td></tr><tr><td>12</td><td>LengthHigh</td><td>内存长度的高 32 位，以字节为单位</td></tr><tr><td>16</td><td>Type</td><td>本段内存的类型</td></tr></tbody></table><p>可以看出，使用 8 字节来描述这段内存基地址，这段内存的长度也是 8 字节。而 type 是 4 字节，用来说明这段内存的用途，即其是可以被操作系统使用，还是保留起来不能用。type 有如下的意义：</p><ul><li>Type 值为 1，称为：AddressRangeMemory。说明这段内存可以被操作系统使用</li><li>Type 值为 2，称为：AddressRangeReserved，说明内存使用中，或者被系统保留，操作系统不可以用此内存</li><li>Type 值为其他，未定义，保留，需要操作系统一样将其视为 ARR（AddressRangeMemory）</li></ul><p>为什么 BIOS 会按类型来返回内存信息呢？原因是这段内存可能是：</p><ul><li>系统的 ROM</li><li>ROM 用到了这部分内存</li><li>设备内存映射到了这部分内存</li><li>由于某些原因，这段内存不适合标准设备使用</li></ul><p>BIOS 中断只是一段函数例程，调用 BIOS 中断 0x15 的 0xE820 子功能需要为其提供参数。</p><figure><img src="'+o+'" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure><figure><img src="'+a+'" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure><p>此中断的调用步骤如下：</p><ul><li>填写好“调用前输入”中列出的寄存器</li><li>执行中断调用 <code>int 0x15</code></li><li>在 CF 位为 0 的情况下，“返回后输出” 中对应的寄存器便会有对应的结果</li></ul><h3 id="二、利用-0xe801-获取内存" tabindex="-1"><a class="header-anchor" href="#二、利用-0xe801-获取内存"><span>二、利用 <code>0xE801</code> 获取内存</span></a></h3><p>最大只能识别 4GB 内存，此方法检测到的内存分别存放到两组寄存器中。</p><ul><li>低于 15MB 的内存以 1KB 为单位大小来记录，单位数量在寄存器 AX 和 CX 中记录，其中 AX 和 CX 的值是一样的，所以在 15MB 空间以下的实际内存容量 = <code>AX * 1024</code>。AX、CX 最大值为 <code>0x3c00</code>，即 <code>0x3c00 * 1024 = 15MB</code></li><li><code>16MB - 4GB</code> 是以 64 KB 为单位大小来记录，单位数量在寄存器 BX 和 DX 中记录，其中 BX 和 DX 的值是一样的，所以 16MB 以上空间的内存实际大小 = <code>BX * 64 * 1024</code>，不用在意 BX X 和 DX 最大值是多少，反正只支持 4GB 空间</li></ul><figure><img src="'+n+'" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure><p>注意，中断返回后，AX 和 CX 中，其值的单位是 1KB，而 BX 和 DX 的单位是 64KB。</p><p>还有一点，由于兼容问题（80286 拥有 24 位地址线，其寻址空间是 16MB，当时有一些 ISA 设备要用到地址 15MB 以上的内存作为缓冲区，也就是此缓冲区为 1MB 大小。后续就沿用了这种做法）， 这种方法检测出来的物理内存会小 1MB，因此我们在最终的结果中应该加上 1MB。</p><p>此中断的调用步骤如下：</p><ul><li>将 AX 寄存器写入 0xE801</li><li>执行中断调用 <code>int 0x15</code></li><li>在 CF 为 0 的情况下，“返回后输出” 中对应的寄存器便会有对应的结果</li></ul><h3 id="三、利用-0x88-获取内存" tabindex="-1"><a class="header-anchor" href="#三、利用-0x88-获取内存"><span>三、利用 <code>0x88</code> 获取内存</span></a></h3><p>只能识别最大 64MB 的内存。即使内容容量大于 64MB，也只会显示 63MB，因为此中断只会显示 1MB 之上的内存，不包括这 1MB。我们在使用的时候记得加上 1MB。</p><figure><img src="'+r+'" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure><p>中断返回后，AX 寄存器中的值，其单位是 1KB。此中断的调用步骤如下：</p><ul><li>将 AX 寄存器写入 0x88</li><li>执行中断调用 <code>int 0x15</code></li><li>在 CF 位为 0 的情况下，“返回后输出” 中对应的寄存器便会有对应的结果</li></ul>',28)]))}const x=t(c,[["render",p],["__file","1.获取物理内存容量.html.vue"]]),h=JSON.parse('{"path":"/%E6%8A%80%E6%9C%AF%E4%B8%93%E9%A2%98/%E6%89%8B%E5%86%99%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/4.%E5%86%85%E5%AD%98/1.%E8%8E%B7%E5%8F%96%E7%89%A9%E7%90%86%E5%86%85%E5%AD%98%E5%AE%B9%E9%87%8F.html","title":"7.获取物理内存容量","lang":"zh-CN","frontmatter":{"title":"7.获取物理内存容量","description":"获取物理内存容量 linux 中获取物理内存容量是通过 BIOS 中断 0x15 实现，分别是 BIOS 中断 0x15 的 3 个子功能，子功能号要存放到寄存器 EAX 或 AX 中。如下： EAX=0xE820 ：遍历主机上全部内存 AX=0xE801：分别检测低 15MB 和 16MB - 4GB 的内存，最大支持 4GB AH=0x88：最多检...","head":[["meta",{"property":"og:url","content":"https://noahyz.github.io/%E6%8A%80%E6%9C%AF%E4%B8%93%E9%A2%98/%E6%89%8B%E5%86%99%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/4.%E5%86%85%E5%AD%98/1.%E8%8E%B7%E5%8F%96%E7%89%A9%E7%90%86%E5%86%85%E5%AD%98%E5%AE%B9%E9%87%8F.html"}],["meta",{"property":"og:site_name","content":"noahyz的博客"}],["meta",{"property":"og:title","content":"7.获取物理内存容量"}],["meta",{"property":"og:description","content":"获取物理内存容量 linux 中获取物理内存容量是通过 BIOS 中断 0x15 实现，分别是 BIOS 中断 0x15 的 3 个子功能，子功能号要存放到寄存器 EAX 或 AX 中。如下： EAX=0xE820 ：遍历主机上全部内存 AX=0xE801：分别检测低 15MB 和 16MB - 4GB 的内存，最大支持 4GB AH=0x88：最多检..."}],["meta",{"property":"og:type","content":"article"}],["meta",{"property":"og:locale","content":"zh-CN"}],["meta",{"property":"article:author","content":"noahyz"}],["script",{"type":"application/ld+json"},"{\\"@context\\":\\"https://schema.org\\",\\"@type\\":\\"Article\\",\\"headline\\":\\"7.获取物理内存容量\\",\\"image\\":[\\"\\"],\\"dateModified\\":null,\\"author\\":[{\\"@type\\":\\"Person\\",\\"name\\":\\"noahyz\\",\\"url\\":\\"/about-the-author/\\"}]}"]]},"headers":[{"level":2,"title":"获取物理内存容量","slug":"获取物理内存容量","link":"#获取物理内存容量","children":[{"level":3,"title":"一、利用 0xE820 获取内存","slug":"一、利用-0xe820-获取内存","link":"#一、利用-0xe820-获取内存","children":[]},{"level":3,"title":"二、利用 0xE801 获取内存","slug":"二、利用-0xe801-获取内存","link":"#二、利用-0xe801-获取内存","children":[]},{"level":3,"title":"三、利用 0x88 获取内存","slug":"三、利用-0x88-获取内存","link":"#三、利用-0x88-获取内存","children":[]}]}],"git":{},"readingTime":{"minutes":3.65,"words":1096},"filePathRelative":"技术专题/手写操作系统/4.内存/1.获取物理内存容量.md","excerpt":"<h2>获取物理内存容量</h2>\\n<p>linux 中获取物理内存容量是通过 BIOS 中断 0x15 实现，分别是 BIOS 中断 0x15 的 3 个子功能，子功能号要存放到寄存器 EAX 或 AX 中。如下：</p>\\n<ul>\\n<li><code>EAX=0xE820</code> ：遍历主机上全部内存</li>\\n<li><code>AX=0xE801</code>：分别检测低 15MB 和 16MB - 4GB 的内存，最大支持 4GB</li>\\n<li><code>AH=0x88</code>：最多检测出 64MB 内存，实际内存超过此容量也按照 64MB 返回</li>\\n</ul>","autoDesc":true}');export{x as comp,h as data};

import{_ as o}from"./plugin-vue_export-helper-DlAUqK2U.js";import{c as t,a as c,o as p}from"./app-D1zlwylF.js";const a="/assets/%E5%AE%9E%E6%A8%A1%E5%BC%8F%E7%9A%84%E5%86%85%E5%AD%98%E5%B8%83%E5%B1%80-DQqUKyRu.png",d={};function r(B,e){return p(),t("div",null,e[0]||(e[0]=[c('<h2 id="计算机的启动" tabindex="-1"><a class="header-anchor" href="#计算机的启动"><span>计算机的启动</span></a></h2><p>在开机的一瞬间，也就是接电的一瞬间，CPU 的 <code>cs:ip</code> 寄存器被强制初始化为 <code>OxF000:0xFFF0</code>。由于开机的时候处于实模式，在实模式下的段基址要乘以 16，也就是左移 4 位，于是 <code>0xF000:0xFFF0</code> 的等效地址将是 <code>0xFFFF0</code>。这个地址就是 BIOS 的入口地址。</p><h3 id="一、bios" tabindex="-1"><a class="header-anchor" href="#一、bios"><span>一、BIOS</span></a></h3><p>BIOS 的全称 <code>Base Input &amp; Output System</code>，即基本输入输出系统。</p><p>实模式下的内存布局如下：</p><img src="'+a+'" style="zoom:50%;"><p>Intel 8086 有 20 条地址线，故其可以访问 1MB 的内存空间（2 的 20 次方），地址范围：<code>0x00000 - 0xFFFFF</code>。如上图，</p><ul><li>其中内存地址 <code>0 - 0x9FFFF</code> 的空间范围是 640KB，这片地址对应到了 DRAM（Dynamic Random Access Memory，动态随机访问内存），也就是插在主板上的内存条。</li><li>其中内存地址 <code>0xF0000 - 0xFFFFF</code> 这 64KB 的内存是 ROM。这里面存的是 BIOS 的代码。</li></ul><p>BIOS 的主要工作是检测、初始化硬件。硬件自己提供了一些初始化的功能调用，BIOS 直接调用就好了。BIOS 还会建立中断向量表，这样就可以通过 &quot;int 中断号&quot; 来实现相关的硬件调用，当然 BIOS 建立的这些功能就是对硬件的 IO 操作，也就是输入输出，但由于就只有 64 KB 大小的空间，而且是在实模式下，不可能把所有硬件的 IO 操作实现的面面俱到，所以挑一些重要的、保证计算机能够运行的那些硬件的基本 IO 操作就可以了，这也是 BIOS 称为“基本输入输出系统”的原因。</p><p>BIOS 的入口地址处只有 16 字节，这里只是存储一个跳转指令：<code>jmp far F000:E05B</code>。即跳转到 <code>0xFE05B</code> 这个地址，这个位置才是 BIOS 代码真正开始的地方。接下来 BIOS 开始检测内存、显卡等外设信息，当检测通过，并初始化好硬件后，开始在内存中 <code>0x000 - 0x3FF</code> 处建立数据结构，中断向量表 IVT（Interrupt Vector Table） 并填写中断例程。</p><h3 id="二、mbr" tabindex="-1"><a class="header-anchor" href="#二、mbr"><span>二、MBR</span></a></h3><p>BIOS 的最后一项工作是校验启动盘中位于 0 盘 0 道 1 扇区的内容。</p><blockquote><p>0 盘 0 道 1 扇区其实也是 0 盘 0 道 0 扇区。这是硬盘扇区表示方法 CHS 的方法，即柱面 Cylinder、磁头 Header、扇区 Sector。在 CHS 方式中扇区的编号是从 1 开始的，不是 0。</p></blockquote><p>如果此扇区末尾的两个字节分别是魔数 0x55 和 0xaa，BIOS 便认为这个扇区中确实存在可执行的程序，这个可执行程序便是“主引导记录 MBR”，于是便把这个程序加载到物理地址：<code>0x7c00</code> 处，随后跳转到此地址，继续执行。</p><p>MBR 的全称为：<code>Master Boot Record</code>，即硬盘的主引导记录，又叫主引导扇区。</p><blockquote><p>问题：为什么要把 MBR 程序加载到物理地址 <code>0x7c00</code> 处？</p><p>早期的个人计算机 DOS 1.0 操作系统，此系统要求的最小内存为 32KB，所以此版本 BIOS 是按照最小内存 32KB 研发的。其中 8086 CPU 要求物理地址 <code>0x0 - 0x3FF</code> 存放中断向量表，所以这个地方不能动。</p><p>MBR 首先不能覆盖已有的数据，其次不能过早的被其他数据覆盖。通常 MBR 的任务是加载某个程序（这个程序一般是内核加载器，很少有直接加载内核的）到指定位置，并将控制权交给他。所谓的交控制权就是 jmp 过去而已。之后 MBR 就没用了，被覆盖也没关系。过早的覆盖指的是不能让 MBR 破坏自己，比如被加载的程序，如内核加载器，其放置的内存位置若是 MBR 自己所在的范围，就会破坏自己，所以需要等 MBR 执行完才行。</p><p>MBR 本身也是程序，是程序就需要用到栈，栈也是在内存中，MBR 虽然本身只有 512 字节，但还需要为他所用的栈分配点空间。所以实际所需的空间要大于 512 字节的，估计 1MB 内存够用了。</p><p>因此结合以上三点，选择 32 KB 中的最后 1KB 最为合适，32KB 换算为地址是：<code>0x8000</code>，减去 1KB（<code>0x400</code>）的话，等于 <code>0x7c00</code>。这就是 <code>0x7c00</code> 的由来。</p></blockquote><p>接下来我们来写一个 MBR 程序。</p>',17)]))}const l=o(d,[["render",r],["__file","1.计算机的启动.html.vue"]]),i=JSON.parse('{"path":"/%E6%8A%80%E6%9C%AF%E4%B8%93%E9%A2%98/%E6%89%8B%E5%86%99%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/1.boot-loader/1.%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%9A%84%E5%90%AF%E5%8A%A8.html","title":"1.计算机的启动","lang":"zh-CN","frontmatter":{"title":"1.计算机的启动","description":"计算机的启动 在开机的一瞬间，也就是接电的一瞬间，CPU 的 cs:ip 寄存器被强制初始化为 OxF000:0xFFF0。由于开机的时候处于实模式，在实模式下的段基址要乘以 16，也就是左移 4 位，于是 0xF000:0xFFF0 的等效地址将是 0xFFFF0。这个地址就是 BIOS 的入口地址。 一、BIOS BIOS 的全称 Base Inp...","head":[["meta",{"property":"og:url","content":"https://noahyz.github.io/%E6%8A%80%E6%9C%AF%E4%B8%93%E9%A2%98/%E6%89%8B%E5%86%99%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/1.boot-loader/1.%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%9A%84%E5%90%AF%E5%8A%A8.html"}],["meta",{"property":"og:site_name","content":"noahyz的博客"}],["meta",{"property":"og:title","content":"1.计算机的启动"}],["meta",{"property":"og:description","content":"计算机的启动 在开机的一瞬间，也就是接电的一瞬间，CPU 的 cs:ip 寄存器被强制初始化为 OxF000:0xFFF0。由于开机的时候处于实模式，在实模式下的段基址要乘以 16，也就是左移 4 位，于是 0xF000:0xFFF0 的等效地址将是 0xFFFF0。这个地址就是 BIOS 的入口地址。 一、BIOS BIOS 的全称 Base Inp..."}],["meta",{"property":"og:type","content":"article"}],["meta",{"property":"og:locale","content":"zh-CN"}],["meta",{"property":"article:author","content":"noahyz"}],["script",{"type":"application/ld+json"},"{\\"@context\\":\\"https://schema.org\\",\\"@type\\":\\"Article\\",\\"headline\\":\\"1.计算机的启动\\",\\"image\\":[\\"\\"],\\"dateModified\\":null,\\"author\\":[{\\"@type\\":\\"Person\\",\\"name\\":\\"noahyz\\",\\"url\\":\\"/about-the-author/\\"}]}"]]},"headers":[{"level":2,"title":"计算机的启动","slug":"计算机的启动","link":"#计算机的启动","children":[{"level":3,"title":"一、BIOS","slug":"一、bios","link":"#一、bios","children":[]},{"level":3,"title":"二、MBR","slug":"二、mbr","link":"#二、mbr","children":[]}]}],"git":{},"readingTime":{"minutes":3.79,"words":1137},"filePathRelative":"技术专题/手写操作系统/1.boot-loader/1.计算机的启动.md","excerpt":"<h2>计算机的启动</h2>\\n<p>在开机的一瞬间，也就是接电的一瞬间，CPU 的 <code>cs:ip</code> 寄存器被强制初始化为 <code>OxF000:0xFFF0</code>。由于开机的时候处于实模式，在实模式下的段基址要乘以 16，也就是左移 4 位，于是 <code>0xF000:0xFFF0</code> 的等效地址将是 <code>0xFFFF0</code>。这个地址就是 BIOS 的入口地址。</p>\\n<h3>一、BIOS</h3>\\n<p>BIOS 的全称 <code>Base Input &amp; Output System</code>，即基本输入输出系统。</p>","autoDesc":true}');export{l as comp,i as data};

import{_ as o}from"./plugin-vue_export-helper-DlAUqK2U.js";import{c as t,a as i,o as a}from"./app-D1zlwylF.js";const n={};function d(c,e){return a(),t("div",null,e[0]||(e[0]=[i('<h2 id="加载内核" tabindex="-1"><a class="header-anchor" href="#加载内核"><span>加载内核</span></a></h2><p>程序猿实现的一段代码，比如下：</p><div class="language- line-numbers-mode" data-highlighter="shiki" data-ext="" data-title="" style="--shiki-light:#24292e;--shiki-dark:#abb2bf;--shiki-light-bg:#fff;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes github-light one-dark-pro vp-code"><code><span class="line"><span>int main(void) { while(1); }</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div></div></div><p>我们首先将他编译成一个可重定位文件，也就是 <code>.o</code> 文件。使用：<code>gcc -c -o main.o main.c</code></p><p>此时，目标文件（可重定位文件）中的符号（变量、函数名）的地址没有确定（可以使用 nm 查看）。我们使用 ld 进行链接，可以使用参数：<code>-Ttext</code> 来指定最终生成的可执行文件的起始虚拟地址。如：<code>ld main.o -Ttext 0xc0001500 -e main -o kernel.bin</code></p><p>其中 <code>-e</code> 参数用于指定程序的起始地址，不仅可以是数字形式的地址，也可以是符号名。如果不加 <code>-e</code> 参数，默认以 <code>_start</code> 作为入口符号，默认地址为：<code>0xc0001500</code></p><h4 id="_1-方式一-在-loader-中解析-elf-格式的-kernel-bin-生成内核映像" tabindex="-1"><a class="header-anchor" href="#_1-方式一-在-loader-中解析-elf-格式的-kernel-bin-生成内核映像"><span>1. 方式一：在 loader 中解析 ELF 格式的 kernel.bin，生成内核映像</span></a></h4><p>内核被加载到内存后，loader 要通过分析其 ELF 结构将其展开到新的位置。因此，内核在内存中有两份拷贝，一份是 ELF 格式的原文件：kernel.bin，另一份是 loader 解析 ELF 格式的 kernel.bin 后在内存中生成的内核映像（也就是程序中的各种段 segment 复制到内存后的程序体），这个映像才是真正运行的内核。</p><p>内核文件经过 loader 解析后就没用了，这样内核映像将来往高地址处扩展时，也可以覆盖原来的内核文件 kernel.bin。所以可以在 <code>0x7E00 - 0x9FBFF</code> 这片区域的高地址中找一块地址存储 kernel.bin。目前选用的是 <code>0x70000</code>，也就是：<code>0x70000 - 0x9fbff</code> 一共有 190KB 的空间。</p><p>物理内存中 <code>0x900</code> 是 <code>loader.bin</code> 加载的地址，在 <code>loader.bin</code> 的开始部分是 GDT，他必须保留，不能覆盖。预计 <code>loader.bin</code> 不会超过 2000 字节，所以 <code>0x900 + 2000 = 0x10d0</code>，我们凑个整数，使用 0x1500 作为内核映像的入口地址。根据页表，低端 1MB 的虚拟内存与物理内存是一一对应的，所以物理地址是 <code>0x1500</code> 对应的虚拟地址是 <code>0xc0001500</code>。</p><p>此方式的缺点：</p><ul><li>需要通过在 loader 中使用汇编编码实现，解析 ELF 格式的 kernel.bin，生成内核映像</li><li>kernel.bin 本身可能很大，写到磁盘占用大量磁盘资源，并且全部加载到内存在解析，也要占用大量内存资源</li></ul><h4 id="_2-方式二-使用-objcopy-直接生成内核映像" tabindex="-1"><a class="header-anchor" href="#_2-方式二-使用-objcopy-直接生成内核映像"><span>2. 方式二：使用 objcopy 直接生成内核映像</span></a></h4><p>通过 gcc 编译的 ELF 格式 kernel.bin，可以使用 objcopy 将需要的段拷贝出来，比如称为：kernel_text.bin。那就只需要将 <code>kernel_text.bin</code> 写入磁盘，并且加载到指定内存即可。不需要进行解析 ELF 文件了。</p>',14)]))}const s=o(n,[["render",d],["__file","3.加载内核.html.vue"]]),p=JSON.parse('{"path":"/%E6%8A%80%E6%9C%AF%E4%B8%93%E9%A2%98/%E6%89%8B%E5%86%99%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/1.boot-loader/3.%E5%8A%A0%E8%BD%BD%E5%86%85%E6%A0%B8.html","title":"9.加载内核","lang":"zh-CN","frontmatter":{"title":"9.加载内核","description":"加载内核 程序猿实现的一段代码，比如下： 我们首先将他编译成一个可重定位文件，也就是 .o 文件。使用：gcc -c -o main.o main.c 此时，目标文件（可重定位文件）中的符号（变量、函数名）的地址没有确定（可以使用 nm 查看）。我们使用 ld 进行链接，可以使用参数：-Ttext 来指定最终生成的可执行文件的起始虚拟地址。如：ld m...","head":[["meta",{"property":"og:url","content":"https://noahyz.github.io/%E6%8A%80%E6%9C%AF%E4%B8%93%E9%A2%98/%E6%89%8B%E5%86%99%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/1.boot-loader/3.%E5%8A%A0%E8%BD%BD%E5%86%85%E6%A0%B8.html"}],["meta",{"property":"og:site_name","content":"noahyz的博客"}],["meta",{"property":"og:title","content":"9.加载内核"}],["meta",{"property":"og:description","content":"加载内核 程序猿实现的一段代码，比如下： 我们首先将他编译成一个可重定位文件，也就是 .o 文件。使用：gcc -c -o main.o main.c 此时，目标文件（可重定位文件）中的符号（变量、函数名）的地址没有确定（可以使用 nm 查看）。我们使用 ld 进行链接，可以使用参数：-Ttext 来指定最终生成的可执行文件的起始虚拟地址。如：ld m..."}],["meta",{"property":"og:type","content":"article"}],["meta",{"property":"og:locale","content":"zh-CN"}],["meta",{"property":"article:author","content":"noahyz"}],["script",{"type":"application/ld+json"},"{\\"@context\\":\\"https://schema.org\\",\\"@type\\":\\"Article\\",\\"headline\\":\\"9.加载内核\\",\\"image\\":[\\"\\"],\\"dateModified\\":null,\\"author\\":[{\\"@type\\":\\"Person\\",\\"name\\":\\"noahyz\\",\\"url\\":\\"/about-the-author/\\"}]}"]]},"headers":[{"level":2,"title":"加载内核","slug":"加载内核","link":"#加载内核","children":[]}],"git":{},"readingTime":{"minutes":2.23,"words":670},"filePathRelative":"技术专题/手写操作系统/1.boot-loader/3.加载内核.md","excerpt":"<h2>加载内核</h2>\\n<p>程序猿实现的一段代码，比如下：</p>\\n<div class=\\"language- line-numbers-mode\\" data-highlighter=\\"shiki\\" data-ext=\\"\\" data-title=\\"\\" style=\\"--shiki-light:#24292e;--shiki-dark:#abb2bf;--shiki-light-bg:#fff;--shiki-dark-bg:#282c34\\"><pre class=\\"shiki shiki-themes github-light one-dark-pro vp-code\\"><code><span class=\\"line\\"><span>int main(void) { while(1); }</span></span></code></pre>\\n<div class=\\"line-numbers\\" aria-hidden=\\"true\\" style=\\"counter-reset:line-number 0\\"><div class=\\"line-number\\"></div></div></div>","autoDesc":true}');export{s as comp,p as data};

import{_ as e}from"./plugin-vue_export-helper-DlAUqK2U.js";import{c as n,a as l,o as a}from"./app-D1zlwylF.js";const s="/assets/%E6%96%87%E4%BB%B6%E6%8F%8F%E8%BF%B0%E7%AC%A6%E4%B8%8Einode%E5%85%B3%E7%B3%BB-D1bD5diT.png",t={};function p(o,i){return a(),n("div",null,i[0]||(i[0]=[l(`<h4 id="_1-文件表-文件结构" tabindex="-1"><a class="header-anchor" href="#_1-文件表-文件结构"><span>1. 文件表（文件结构）</span></a></h4><p>为什么要有文件表（文件结构）？</p><ul><li>操作系统应该允许一个进程同时、多次、打开同一个文件（并不关闭）</li><li>同样的，该文件应该被允许被多个不同的进程同时打开</li><li>那么，我们需要实现文件任意位置的读写，执行读写操作时，需要指定偏移量作为该文件内的起始地址。也就是说，该文件每被打开一次，文件读写的偏移量都可以任意指定。</li><li>注意，文件内的偏移量是互不影响的；但文件内容是共享的，对文件内容的修改是互相影响的。</li><li>通常情况下，对文件的操作涉及到多次读写，下一次读写的位置必须以上一次的读写位置为起始，因此文件系统需要把任意时刻的偏移量记录下来</li><li>那么，偏移量不应该记录在 inode 中，inode 不应该记录这些与文件操作相关的数据。</li></ul><p>因此，Linux 提供了称为&quot;文件结构&quot;的数据结构，专门用于记录与文件操作相关的信息。每打开文件（可以是相同文件）就产生一个文件结构。从而实现了“即使同一个文件被同时多次打开，各自操作的偏移量也互不影响”。</p><p>Linux 把所有的“文件结构”组织到一起形成数组统一管理，该数组称为“文件表”。</p><p>我们的文件结构如下：</p><div class="language- line-numbers-mode" data-highlighter="shiki" data-ext="" data-title="" style="--shiki-light:#24292e;--shiki-dark:#abb2bf;--shiki-light-bg:#fff;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes github-light one-dark-pro vp-code"><code><span class="line"><span>struct file {</span></span>
<span class="line"><span>    // 记录当前文件操作的偏移地址, 以 0 为起始, 最大为文件大小减1</span></span>
<span class="line"><span>    uint32_t fd_pos;</span></span>
<span class="line"><span>    // 文件打开的标识位，如 O_CREAT</span></span>
<span class="line"><span>    uint32_t fd_flag;</span></span>
<span class="line"><span>    // inode 指针</span></span>
<span class="line"><span>    struct inode* fd_inode;</span></span>
<span class="line"><span>};</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>因此，总结一下。inode 用于描述文件存储相关信息，文件结构用于描述 “文件打开” 后，文件读写偏移量等信息。文件和 inode 之间一一对应，一个文件可以被多次打开，因此多个文件结构可以对应同一个 inode。</p><h4 id="_2-文件描述符" tabindex="-1"><a class="header-anchor" href="#_2-文件描述符"><span>2. 文件描述符</span></a></h4><p>进程的 PCB 中有一个字段</p><div class="language- line-numbers-mode" data-highlighter="shiki" data-ext="" data-title="" style="--shiki-light:#24292e;--shiki-dark:#abb2bf;--shiki-light-bg:#fff;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes github-light one-dark-pro vp-code"><code><span class="line"><span>int32_t fd_table[MAX_FILES_OPEN_PER_PROC];</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div></div></div><p>文件描述符数组，这个数组的下标即是文件描述符，数组的内容即是 文件表中 “文件结构的下标”。通过文件描述符数组，即可找到对应的文件结构。通过文件结构即可找到对应 inode，通过 inode 即可找到对应的文件。</p><p>文件结构需要占用内存，因此一般进程可打开的文件数有限制。</p><p>为什么文件描述符是数字，而不像其他描述符那样，是个具有多个成员属性的复合数据结构？</p><ul><li>为了一视同仁，使各进程可打开的文件数是一样的，各进程必须有独立的、大小完全一样的一套文件描述符数组，而不能所有进程都共享同一套文件描述符数组</li><li>文件结构中包含进程执行文件操作的偏移量，它属于与各个任务单独绑定的资源，因此最好放在 PCB 中管理。但当进程打开的文件数增多的时候，文件表占用的空间较大，而 PCB 占用的内存通常就是几个页。</li></ul><p>文件描述符和 inode 之间的关联关系</p><img src="`+s+'" style="zoom:50%;"><p>因此，Linux 中通过文件描述符查找文件数据块的过程，涉及如下三个数据结构：</p><ul><li>PCB 中的文件描述符数组</li><li>存储所有文件结构的文件表</li><li>inode 队列，也就是 inode 缓存</li></ul><p>因此，过程一般如下：</p><ul><li>一个进程将文件描述符作为参数提交给文件系统时，文件系统用此文件描述符在该进程的 PCB 中的文件描述符数组索引对应的元素</li><li>从该元素中获取对应的文件结构的下标，用该下标在文件表中索引相应的文件结构。</li><li>从该文件结构中获取文件的 inode，最终找到文件的数据块</li><li>如果该 inode 在 inode 队列中不存在，此时：文件系统会从硬盘上将该 inode 加载到 inode 队列中，并使文件结构中的 fd_inode 指向它</li></ul><p>那么 open 操作的本质是创建相应文件描述符的过程：</p><ul><li>在全局的 inode 队列中新建一个 inode，返回该 inode 地址</li><li>在全局的文件表中找一空位，在该位置填充文件结构，使其 <code>fd_inode</code> 指向上一步中返回的 inode 地址，然后返回本文件结构在文件表中的下标值</li><li>在 PCB 中的文件描述符数组中找一空位，使该位置的值指向上一步中返回的文件结构下标，并返回本文件描述符在文件描述符数组中的下标值</li></ul>',23)]))}const c=e(t,[["render",p],["__file","3.文件系统原理2.html.vue"]]),h=JSON.parse('{"path":"/%E6%8A%80%E6%9C%AF%E4%B8%93%E9%A2%98/%E6%89%8B%E5%86%99%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/6.%E7%A1%AC%E7%9B%98/3.%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F%E5%8E%9F%E7%90%862.html","title":"文件系统原理2","lang":"zh-CN","frontmatter":{"title":"文件系统原理2","description":"1. 文件表（文件结构） 为什么要有文件表（文件结构）？ 操作系统应该允许一个进程同时、多次、打开同一个文件（并不关闭） 同样的，该文件应该被允许被多个不同的进程同时打开 那么，我们需要实现文件任意位置的读写，执行读写操作时，需要指定偏移量作为该文件内的起始地址。也就是说，该文件每被打开一次，文件读写的偏移量都可以任意指定。 注意，文件内的偏移量是互不...","head":[["meta",{"property":"og:url","content":"https://noahyz.github.io/%E6%8A%80%E6%9C%AF%E4%B8%93%E9%A2%98/%E6%89%8B%E5%86%99%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/6.%E7%A1%AC%E7%9B%98/3.%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F%E5%8E%9F%E7%90%862.html"}],["meta",{"property":"og:site_name","content":"noahyz的博客"}],["meta",{"property":"og:title","content":"文件系统原理2"}],["meta",{"property":"og:description","content":"1. 文件表（文件结构） 为什么要有文件表（文件结构）？ 操作系统应该允许一个进程同时、多次、打开同一个文件（并不关闭） 同样的，该文件应该被允许被多个不同的进程同时打开 那么，我们需要实现文件任意位置的读写，执行读写操作时，需要指定偏移量作为该文件内的起始地址。也就是说，该文件每被打开一次，文件读写的偏移量都可以任意指定。 注意，文件内的偏移量是互不..."}],["meta",{"property":"og:type","content":"article"}],["meta",{"property":"og:locale","content":"zh-CN"}],["meta",{"property":"article:author","content":"noahyz"}],["script",{"type":"application/ld+json"},"{\\"@context\\":\\"https://schema.org\\",\\"@type\\":\\"Article\\",\\"headline\\":\\"文件系统原理2\\",\\"image\\":[\\"\\"],\\"dateModified\\":null,\\"author\\":[{\\"@type\\":\\"Person\\",\\"name\\":\\"noahyz\\",\\"url\\":\\"/about-the-author/\\"}]}"]]},"headers":[],"git":{},"readingTime":{"minutes":4.21,"words":1263},"filePathRelative":"技术专题/手写操作系统/6.硬盘/3.文件系统原理2.md","excerpt":"<h4>1. 文件表（文件结构）</h4>\\n<p>为什么要有文件表（文件结构）？</p>\\n<ul>\\n<li>操作系统应该允许一个进程同时、多次、打开同一个文件（并不关闭）</li>\\n<li>同样的，该文件应该被允许被多个不同的进程同时打开</li>\\n<li>那么，我们需要实现文件任意位置的读写，执行读写操作时，需要指定偏移量作为该文件内的起始地址。也就是说，该文件每被打开一次，文件读写的偏移量都可以任意指定。</li>\\n<li>注意，文件内的偏移量是互不影响的；但文件内容是共享的，对文件内容的修改是互相影响的。</li>\\n<li>通常情况下，对文件的操作涉及到多次读写，下一次读写的位置必须以上一次的读写位置为起始，因此文件系统需要把任意时刻的偏移量记录下来</li>\\n<li>那么，偏移量不应该记录在 inode 中，inode 不应该记录这些与文件操作相关的数据。</li>\\n</ul>","autoDesc":true}');export{c as comp,h as data};

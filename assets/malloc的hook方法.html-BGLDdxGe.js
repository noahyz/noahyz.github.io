import{_ as s}from"./plugin-vue_export-helper-DlAUqK2U.js";import{c as e,a,o as l}from"./app-D1zlwylF.js";const t={};function n(o,i){return l(),e("div",null,i[0]||(i[0]=[a(`<p>malloc_hook 方法：</p><div class="language- line-numbers-mode" data-highlighter="shiki" data-ext="" data-title="" style="--shiki-light:#24292e;--shiki-dark:#abb2bf;--shiki-light-bg:#fff;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes github-light one-dark-pro vp-code"><code><span class="line"><span>https://stackoverflow.com/questions/17803456/an-alternative-for-the-deprecated-malloc-hook-functionality-of-glibc/17850402#17850402</span></span>
<span class="line"><span></span></span>
<span class="line"><span>https://stackoverflow.com/questions/71882426/how-to-correctly-interpose-malloc-allowing-for-ld-preload-chaining</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>获取函数的返回地址或帧地址：<a href="https://gcc.gnu.org/onlinedocs/gcc/Return-Address.html" target="_blank" rel="noopener noreferrer">https://gcc.gnu.org/onlinedocs/gcc/Return-Address.html</a></p><p>MEM_debug：<a href="https://github.com/itaych/MEM_debug" target="_blank" rel="noopener noreferrer">https://github.com/itaych/MEM_debug</a></p><p>firASAN：<a href="https://github.com/gamark/firasan" target="_blank" rel="noopener noreferrer">https://github.com/gamark/firasan</a></p><h3 id="hook-malloc-问题以及方法" tabindex="-1"><a class="header-anchor" href="#hook-malloc-问题以及方法"><span>hook malloc 问题以及方法</span></a></h3><p>背景：希望 hook malloc/free 等函数，做一些业务操作。</p><ul><li>glibc 的 __malloc_hook和__free_hook等钩子，因为每次要调用原生malloc/free之前必须先把钩子置空，等分配完成后再把钩子改回去，这不能保证线程安全。</li><li>pre_load方式的，要通过在main之前调用dlopen来加载原生函数指针，问题是dlopen里面也调用malloc分配了内存，而此时malloc已经被覆盖，所以在dlopen中就无限递归了</li></ul><p>无奈的办法，在 hook 的 malloc 中，调用 memalign 或者 mmap 来申请内存</p><p>方案：</p><ul><li><p>直接写一个 malloc 同签名的函数即可，至于如何调用原函数，可以通过符号 <code>__libc_malloc</code>，这个符号直接指向 malloc 的实现部分，通过这个符号调用就不会产生递归调用</p><div class="language-c++ line-numbers-mode" data-highlighter="shiki" data-ext="c++" data-title="c++" style="--shiki-light:#24292e;--shiki-dark:#abb2bf;--shiki-light-bg:#fff;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes github-light one-dark-pro vp-code"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#C678DD;">extern</span><span style="--shiki-light:#D73A49;--shiki-dark:#C678DD;"> void</span><span style="--shiki-light:#D73A49;--shiki-dark:#C678DD;"> *</span><span style="--shiki-light:#6F42C1;--shiki-dark:#61AFEF;">__libc_malloc</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">(</span><span style="--shiki-light:#D73A49;--shiki-dark:#C678DD;">size_t</span><span style="--shiki-light:#E36209;--shiki-dark:#E06C75;--shiki-light-font-style:inherit;--shiki-dark-font-style:italic;"> size</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">);</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#C678DD;">void*</span><span style="--shiki-light:#6F42C1;--shiki-dark:#61AFEF;"> malloc</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;"> (</span><span style="--shiki-light:#D73A49;--shiki-dark:#C678DD;">size_t</span><span style="--shiki-light:#E36209;--shiki-dark:#E06C75;--shiki-light-font-style:inherit;--shiki-dark-font-style:italic;"> size</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">)</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">{</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#7F848E;--shiki-light-font-style:inherit;--shiki-dark-font-style:italic;">  // do your stuff</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">  {</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">  }</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#7F848E;--shiki-light-font-style:inherit;--shiki-dark-font-style:italic;">  // call the original malloc</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#C678DD;">  return</span><span style="--shiki-light:#6F42C1;--shiki-dark:#61AFEF;"> __libc_malloc</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">(size);</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">}</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div></li><li><p>使用 inline hook，汇编指令级别，只要替换目标函数入口处的指令为跳转指令即可</p></li><li><p>C 语言可以用宏替换 malloc。<code>#define malloc my_malloc</code>。但是 c++ 不适用，重写全局 new 带来很多问题。而且这种方法一点都不优雅</p></li><li><p>Gcc wrap，ld 中有一个选项 <code>-wrap</code>，当查找某个符号时，它优先解析 <code>__wrap_symbol</code>，解析不到才去解析 symbol。但对于 c++ 的 new 不起作用</p></li><li></li></ul>`,11)]))}const c=s(t,[["render",n],["__file","malloc的hook方法.html.vue"]]),p=JSON.parse('{"path":"/%E6%8A%80%E6%9C%AF%E4%B8%93%E9%A2%98/hook/malloc%E7%9A%84hook%E6%96%B9%E6%B3%95.html","title":"undefined","lang":"zh-CN","frontmatter":{"title":"undefined","date":"2023-01-19T11:11:41.000Z","tags":["linux"],"description":"malloc_hook 方法： 获取函数的返回地址或帧地址：https://gcc.gnu.org/onlinedocs/gcc/Return-Address.html MEM_debug：https://github.com/itaych/MEM_debug firASAN：https://github.com/gamark/firasan hook...","head":[["meta",{"property":"og:url","content":"https://noahyz.github.io/%E6%8A%80%E6%9C%AF%E4%B8%93%E9%A2%98/hook/malloc%E7%9A%84hook%E6%96%B9%E6%B3%95.html"}],["meta",{"property":"og:site_name","content":"noahyz的博客"}],["meta",{"property":"og:title","content":"undefined"}],["meta",{"property":"og:description","content":"malloc_hook 方法： 获取函数的返回地址或帧地址：https://gcc.gnu.org/onlinedocs/gcc/Return-Address.html MEM_debug：https://github.com/itaych/MEM_debug firASAN：https://github.com/gamark/firasan hook..."}],["meta",{"property":"og:type","content":"article"}],["meta",{"property":"og:locale","content":"zh-CN"}],["meta",{"property":"article:author","content":"noahyz"}],["meta",{"property":"article:tag","content":"linux"}],["meta",{"property":"article:published_time","content":"2023-01-19T11:11:41.000Z"}],["script",{"type":"application/ld+json"},"{\\"@context\\":\\"https://schema.org\\",\\"@type\\":\\"Article\\",\\"headline\\":\\"undefined\\",\\"image\\":[\\"\\"],\\"datePublished\\":\\"2023-01-19T11:11:41.000Z\\",\\"dateModified\\":null,\\"author\\":[{\\"@type\\":\\"Person\\",\\"name\\":\\"noahyz\\",\\"url\\":\\"/about-the-author/\\"}]}"]]},"headers":[{"level":3,"title":"hook malloc 问题以及方法","slug":"hook-malloc-问题以及方法","link":"#hook-malloc-问题以及方法","children":[]}],"git":{},"readingTime":{"minutes":1.38,"words":413},"filePathRelative":"技术专题/hook/malloc的hook方法.md","localizedDate":"2023年1月19日","excerpt":"<p>malloc_hook 方法：</p>\\n<div class=\\"language- line-numbers-mode\\" data-highlighter=\\"shiki\\" data-ext=\\"\\" data-title=\\"\\" style=\\"--shiki-light:#24292e;--shiki-dark:#abb2bf;--shiki-light-bg:#fff;--shiki-dark-bg:#282c34\\"><pre class=\\"shiki shiki-themes github-light one-dark-pro vp-code\\"><code><span class=\\"line\\"><span>https://stackoverflow.com/questions/17803456/an-alternative-for-the-deprecated-malloc-hook-functionality-of-glibc/17850402#17850402</span></span>\\n<span class=\\"line\\"><span></span></span>\\n<span class=\\"line\\"><span>https://stackoverflow.com/questions/71882426/how-to-correctly-interpose-malloc-allowing-for-ld-preload-chaining</span></span></code></pre>\\n<div class=\\"line-numbers\\" aria-hidden=\\"true\\" style=\\"counter-reset:line-number 0\\"><div class=\\"line-number\\"></div><div class=\\"line-number\\"></div><div class=\\"line-number\\"></div></div></div>","autoDesc":true}');export{c as comp,p as data};

import{_ as e}from"./plugin-vue_export-helper-DlAUqK2U.js";import{c as o,a as n,o as a}from"./app-D1zlwylF.js";const p={};function r(l,t){return a(),o("div",null,t[0]||(t[0]=[n('<p>异常安全：指当异常发生时，既不会发生资源泄漏，系统也不会处于一个不一致的状态</p><h3 id="异常的问题" tabindex="-1"><a class="header-anchor" href="#异常的问题"><span>异常的问题</span></a></h3><ol><li><p>异常违反了&quot;你不用就不需要付出代价&quot;的C++原则。只要开启了异常，即使不使用异常你编译出的二进制代码通常也会膨胀</p><p>目前主流的异常实现中，都倾向于牺牲可执行文件大小、提供主流程的性能。</p></li><li><p>异常比较隐蔽，不容易看出来哪些地方会发生异常和发生什么异常</p><p>和Java 不同，C++里不会对异常规约进行编译时的检查。从C++17开始，C++甚至完全禁止了以往的动态异常规约，你不再能在函数声明里写你可能抛出某某异常。你唯一能声明的，就是某函数不会抛出异常--noexcept、noexcept(true) 或 throw()。这也是C++的运行时唯一会检查的东西。如果一个函数声明了不会抛出异常、结果却抛出了异常，C++运行时会调用 std::terminate 来终止应用程序</p></li></ol><p>不使用异常是有理由的。特别是在泛型编程的代码中，几乎不可能预知会发生些什么异常。个人建议</p><ol><li>写异常安全的代码，尤其在模板里。可能的话，提供强异常安全保证，在任何第三方代码发生异常的情况下，不改变对象的内容，也不产生任何资源泄漏</li><li>如果你的代码可能抛出异常的话，在文档里明确声明可能发生的异常类型和发生条件。确保使用你的代码的人，能在不检查你的实现的情况，了解需要准备哪些异常</li><li>对于肯定不会抛出异常的代码，将其标为 noexcept。注意类的特殊成员(构造函数、析构函数、赋值函数)会自动成为 noecxept，如果他们调用的代码都是 noexcept 的话。所以，像 swap 这样的成员函数应该尽可能标为 noexcept。</li></ol>',5)]))}const s=e(p,[["render",r],["__file","4.异常.html.vue"]]),h=JSON.parse('{"path":"/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/c__%E8%AF%AD%E8%A8%80/%E7%BC%96%E7%A0%81%E6%8A%80%E5%B7%A7/4.%E5%BC%82%E5%B8%B8.html","title":"4.异常","lang":"zh-CN","frontmatter":{"title":"4.异常","date":"2023-01-19T11:11:41.000Z","tags":["linux"],"description":"异常安全：指当异常发生时，既不会发生资源泄漏，系统也不会处于一个不一致的状态 异常的问题 异常违反了\\"你不用就不需要付出代价\\"的C++原则。只要开启了异常，即使不使用异常你编译出的二进制代码通常也会膨胀 目前主流的异常实现中，都倾向于牺牲可执行文件大小、提供主流程的性能。 异常比较隐蔽，不容易看出来哪些地方会发生异常和发生什么异常 和Java 不同，C...","head":[["meta",{"property":"og:url","content":"https://noahyz.github.io/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/c__%E8%AF%AD%E8%A8%80/%E7%BC%96%E7%A0%81%E6%8A%80%E5%B7%A7/4.%E5%BC%82%E5%B8%B8.html"}],["meta",{"property":"og:site_name","content":"noahyz的博客"}],["meta",{"property":"og:title","content":"4.异常"}],["meta",{"property":"og:description","content":"异常安全：指当异常发生时，既不会发生资源泄漏，系统也不会处于一个不一致的状态 异常的问题 异常违反了\\"你不用就不需要付出代价\\"的C++原则。只要开启了异常，即使不使用异常你编译出的二进制代码通常也会膨胀 目前主流的异常实现中，都倾向于牺牲可执行文件大小、提供主流程的性能。 异常比较隐蔽，不容易看出来哪些地方会发生异常和发生什么异常 和Java 不同，C..."}],["meta",{"property":"og:type","content":"article"}],["meta",{"property":"og:locale","content":"zh-CN"}],["meta",{"property":"article:author","content":"noahyz"}],["meta",{"property":"article:tag","content":"linux"}],["meta",{"property":"article:published_time","content":"2023-01-19T11:11:41.000Z"}],["script",{"type":"application/ld+json"},"{\\"@context\\":\\"https://schema.org\\",\\"@type\\":\\"Article\\",\\"headline\\":\\"4.异常\\",\\"image\\":[\\"\\"],\\"datePublished\\":\\"2023-01-19T11:11:41.000Z\\",\\"dateModified\\":null,\\"author\\":[{\\"@type\\":\\"Person\\",\\"name\\":\\"noahyz\\",\\"url\\":\\"/about-the-author/\\"}]}"]]},"headers":[{"level":3,"title":"异常的问题","slug":"异常的问题","link":"#异常的问题","children":[]}],"git":{},"readingTime":{"minutes":1.85,"words":555},"filePathRelative":"编程语言/c++语言/编码技巧/4.异常.md","localizedDate":"2023年1月19日","excerpt":"<p>异常安全：指当异常发生时，既不会发生资源泄漏，系统也不会处于一个不一致的状态</p>\\n<h3>异常的问题</h3>\\n<ol>\\n<li>\\n<p>异常违反了\\"你不用就不需要付出代价\\"的C++原则。只要开启了异常，即使不使用异常你编译出的二进制代码通常也会膨胀</p>\\n<p>目前主流的异常实现中，都倾向于牺牲可执行文件大小、提供主流程的性能。</p>\\n</li>\\n<li>\\n<p>异常比较隐蔽，不容易看出来哪些地方会发生异常和发生什么异常</p>\\n<p>和Java 不同，C++里不会对异常规约进行编译时的检查。从C++17开始，C++甚至完全禁止了以往的动态异常规约，你不再能在函数声明里写你可能抛出某某异常。你唯一能声明的，就是某函数不会抛出异常--noexcept、noexcept(true) 或 throw()。这也是C++的运行时唯一会检查的东西。如果一个函数声明了不会抛出异常、结果却抛出了异常，C++运行时会调用 std::terminate 来终止应用程序</p>\\n</li>\\n</ol>","autoDesc":true}');export{s as comp,h as data};

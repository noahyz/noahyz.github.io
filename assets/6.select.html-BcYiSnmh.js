import{_ as l}from"./plugin-vue_export-helper-DlAUqK2U.js";import{c as t,a as i,o as s}from"./app-D1zlwylF.js";const a={};function n(c,e){return s(),t("div",null,e[0]||(e[0]=[i(`<h2 id="select" tabindex="-1"><a class="header-anchor" href="#select"><span>select</span></a></h2><ul><li>select 控制结构中包含 default 语句时，能在 channel 上进行非阻塞的收发操作</li><li>select 在遇到多个 channel 同时响应时，会随机执行一种情况。引入随机性就是为了避免饥饿问题发生</li></ul><h3 id="一、实现原理" tabindex="-1"><a class="header-anchor" href="#一、实现原理"><span>一、实现原理</span></a></h3><p>select 语句在编译期间会被转换成 OSELECT 节点。每个 OSELECT 节点都会持有一组 OCASE 节点，每一个 OCASE 节点既包含执行条件，也包含满足条件后执行的代码。如果 OCASE 的执行条件为空，就意味着这是一个 default 节点。</p><p>编译器会根据 select 中的 case 的不同对控制语句进行优化，分为四种情况：</p><h4 id="_1-select-不存在任何-case" tabindex="-1"><a class="header-anchor" href="#_1-select-不存在任何-case"><span>1. select 不存在任何 case</span></a></h4><p>直接将类似 <code>select{}</code> 的语句转换成调用 <code>runtime.block</code> 函数，而 <code>runtime.block</code> 函数会调用 <code>runtime.gopark</code> 让出当前 Goroutine 对处理器的使用权，并传入等待原因 <code>waitReasonSelectNoCases</code>。也就是说，空的 select 语句会阻塞当前 Goroutine，导致 Goroutine 进入无法被唤醒的永久休眠状态</p><h4 id="_2-select-只存在一个-case" tabindex="-1"><a class="header-anchor" href="#_2-select-只存在一个-case"><span>2. select 只存在一个 case</span></a></h4><p>编译器会将 select 改写成 if 条件语句，判断 channel 中是否可发送或可接受。当 case 中的 channel 是空指针时，会直接挂起当前 Goroutine 并陷入永久休眠</p><h4 id="_3-select-存在两个-case-其中一个是-default" tabindex="-1"><a class="header-anchor" href="#_3-select-存在两个-case-其中一个是-default"><span>3. select 存在两个 case，其中一个是 default</span></a></h4><p>有 default 的 case，编译器会认为这是一次非阻塞的收发操作。会先将 case 中所有的 channel 都转换成指向 channel 的地址。</p><ul><li>发送过程：当 case 中表达式的类型是 OSEND 时，编译器会优化成 if 条件语句和 <code>runtime.selectnbsend</code> （not block）函数。而 <code>runtime.selectnbsend</code> 函数会有一个 block 参数，决定此次发送是不是阻塞的，然后再调用 <code>runtime.chansend</code> 发送数据，由于传入的 block 参数为非阻塞，所以在不存在接收方或缓冲区空间不足时，当前 Goroutine 都不会阻塞而会直接返回</li><li>接收过程：由于从 channel 中接收数据可能会返回一个或两个值，返回值数量不同会导致使用函数的不同。分别是 <code>runtime.selectnbrecv</code> 和 <code>runtime.selectnbrecv2</code> 函数。底层都会调用 <code>runtime.chanrecv</code>，也会有一个 block 参数决定此次接收是否非阻塞。</li></ul><h4 id="_4-select-存在多个-case" tabindex="-1"><a class="header-anchor" href="#_4-select-存在多个-case"><span>4. select 存在多个 case</span></a></h4><ul><li><p>将所有 case 转换成包含 channel 以及类型等信息的 <code>runtime.scase</code> 结构体。</p><div class="language-go line-numbers-mode" data-highlighter="shiki" data-ext="go" data-title="go" style="--shiki-light:#24292e;--shiki-dark:#abb2bf;--shiki-light-bg:#fff;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes github-light one-dark-pro vp-code"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#C678DD;">type</span><span style="--shiki-light:#6F42C1;--shiki-dark:#E5C07B;"> scase</span><span style="--shiki-light:#D73A49;--shiki-dark:#C678DD;"> struct</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;"> {</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E06C75;">	c</span><span style="--shiki-light:#D73A49;--shiki-dark:#C678DD;"> *</span><span style="--shiki-light:#6F42C1;--shiki-dark:#E5C07B;">hchan</span><span style="--shiki-light:#6A737D;--shiki-dark:#7F848E;--shiki-light-font-style:inherit;--shiki-dark-font-style:italic;">              // chan</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E06C75;">	elem</span><span style="--shiki-light:#6F42C1;--shiki-dark:#E5C07B;"> unsafe</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#E5C07B;">Pointer</span><span style="--shiki-light:#6A737D;--shiki-dark:#7F848E;--shiki-light-font-style:inherit;--shiki-dark-font-style:italic;">   //data element </span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">}</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div></li><li><p>调用运行时函数 <code>runtime.selectgo</code> 从多个准备就绪的 channel 中选择一个可执行的 <code>runtime.scase</code> 结构体</p></li><li><p>通过 for 循环生成一组 if 语句，在语句中判断自己是不是被选中的 case</p></li></ul><p><code>runtime.selectgo</code> 函数的执行过程</p><ul><li><p>初始化操作，并决定处理 case 的顺序：轮询顺序 pollOrder 和加锁顺序 lockOrder。通过以下方式确定</p><ul><li>轮询顺序：通过 <code>runtime.fastrandn</code> 函数引入随机性。可以避免 channel 的饥饿问题，保证公平性</li><li>加锁顺序：按照 channel 的地址排序后确定加锁顺序。能够避免发生死锁（所有的 goroutine 进入 selectgo 进行 lockOrder 都是相同顺序，防止不同顺序的 case 进来时锁定 channel 导致死锁）</li></ul></li><li><p>当为 select 语句锁定了所有 channel 之后，就会进入 <code>runtime.selectgo</code> 函数的主循环，它会分为 3 个阶段查找或者等待某个 channel 准备就绪</p><ul><li><p>查找是否已经存在准备就绪的 channel，即可以执行收发操作</p><p>循环会遍历所有 case 并找到需要被唤醒的 <code>runtime.sudog</code> 结构。会根据 case 的 4 种类型分别处理：</p><ul><li>当 case 不包含 channel 时：这种 case 会被跳过</li><li>当 case 从 channel 中接收数据时： <ol><li>如果当前 channel 的 sendq 发送队列上有等待的 Goroutine，则可以从休眠的发送方获取数据</li><li>如果当前 channel 的缓冲区不为空，就会从缓冲区获取数据</li><li>如果当前 channel 已经关闭，则从关闭的 channel 读取到 EOF</li></ol></li><li>当 case 向 channel 发送数据时： <ol><li>如果当前 channel 已经关闭，则触发 panic 尝试中止程序</li><li>如果当前 channel 的 recvq 接收队列上有等待的 Goroutine，则可以向休眠的接收方发送数据</li><li>如果当前 channel 的缓冲区存在空闲位置，就会将待发送的数据存入缓冲区</li></ol></li><li>当 select 语句中包含 default 时：当前面的所有 case 都没有被执行，这里会解锁所有 channel 并返回，意味着当前 select 结构中的收发都是非阻塞的</li></ul><p>没有查找到准备就绪的 channel，则进入下一阶段。</p></li><li><p>将当前 Goroutine 加入 channel 对应的收发队列并等待被其他 Goroutine 唤醒。除了将当前 Goroutine 对应的 <code>runtime.sudog</code> 结构体加入队列外，这些结构体都会被串成链表附着在当前 Goroutine 上，并挂起当前 Goroutine 等待调度器唤醒。</p></li><li><p>当前 Goroutine 被唤醒之后找到满足条件的 channel 并进行处理，过程如下</p><ul><li>遍历全部 case，首先获取当前 Goroutine 接收到的参数 sudog 结构，然后依次对比所有 case 对应的 sudog 结构，找到被唤醒的 case，获取该 case 对应的索引并返回。</li><li>剩余 case 中没有用到的 <code>runtime.sudog</code> 就会被忽略并释放。为了不影响 channel 的正常使用，会将这些废弃的 <code>runtime.sudog</code> 从 channel 中出队</li></ul></li></ul></li></ul>`,16)]))}const r=l(a,[["render",n],["__file","6.select.html.vue"]]),d=JSON.parse('{"path":"/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/go%E8%AF%AD%E8%A8%80/%E5%BA%95%E5%B1%82%E5%AE%9E%E7%8E%B0/6.select.html","title":"6.select关键字实现","lang":"zh-CN","frontmatter":{"title":"6.select关键字实现","date":"2023-01-19T11:11:41.000Z","tags":["go"],"description":"select select 控制结构中包含 default 语句时，能在 channel 上进行非阻塞的收发操作 select 在遇到多个 channel 同时响应时，会随机执行一种情况。引入随机性就是为了避免饥饿问题发生 一、实现原理 select 语句在编译期间会被转换成 OSELECT 节点。每个 OSELECT 节点都会持有一组 OCASE 节...","head":[["meta",{"property":"og:url","content":"https://noahyz.github.io/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/go%E8%AF%AD%E8%A8%80/%E5%BA%95%E5%B1%82%E5%AE%9E%E7%8E%B0/6.select.html"}],["meta",{"property":"og:site_name","content":"noahyz的博客"}],["meta",{"property":"og:title","content":"6.select关键字实现"}],["meta",{"property":"og:description","content":"select select 控制结构中包含 default 语句时，能在 channel 上进行非阻塞的收发操作 select 在遇到多个 channel 同时响应时，会随机执行一种情况。引入随机性就是为了避免饥饿问题发生 一、实现原理 select 语句在编译期间会被转换成 OSELECT 节点。每个 OSELECT 节点都会持有一组 OCASE 节..."}],["meta",{"property":"og:type","content":"article"}],["meta",{"property":"og:locale","content":"zh-CN"}],["meta",{"property":"article:author","content":"noahyz"}],["meta",{"property":"article:tag","content":"go"}],["meta",{"property":"article:published_time","content":"2023-01-19T11:11:41.000Z"}],["script",{"type":"application/ld+json"},"{\\"@context\\":\\"https://schema.org\\",\\"@type\\":\\"Article\\",\\"headline\\":\\"6.select关键字实现\\",\\"image\\":[\\"\\"],\\"datePublished\\":\\"2023-01-19T11:11:41.000Z\\",\\"dateModified\\":null,\\"author\\":[{\\"@type\\":\\"Person\\",\\"name\\":\\"noahyz\\",\\"url\\":\\"/about-the-author/\\"}]}"]]},"headers":[{"level":2,"title":"select","slug":"select","link":"#select","children":[{"level":3,"title":"一、实现原理","slug":"一、实现原理","link":"#一、实现原理","children":[]}]}],"git":{},"readingTime":{"minutes":4.54,"words":1362},"filePathRelative":"编程语言/go语言/底层实现/6.select.md","localizedDate":"2023年1月19日","excerpt":"<h2>select</h2>\\n<ul>\\n<li>select 控制结构中包含 default 语句时，能在 channel 上进行非阻塞的收发操作</li>\\n<li>select 在遇到多个 channel 同时响应时，会随机执行一种情况。引入随机性就是为了避免饥饿问题发生</li>\\n</ul>\\n<h3>一、实现原理</h3>\\n<p>select 语句在编译期间会被转换成 OSELECT 节点。每个 OSELECT 节点都会持有一组 OCASE 节点，每一个 OCASE 节点既包含执行条件，也包含满足条件后执行的代码。如果 OCASE 的执行条件为空，就意味着这是一个 default 节点。</p>","autoDesc":true}');export{r as comp,d as data};

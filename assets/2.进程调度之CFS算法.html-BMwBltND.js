import{_ as t}from"./plugin-vue_export-helper-DlAUqK2U.js";import{c as i,a,o as n}from"./app-D1zlwylF.js";const l="/assets/%E8%BF%9B%E7%A8%8B%E8%B0%83%E5%BA%A6%E6%9E%B6%E6%9E%84-DdgRvgML.png",o={};function c(r,e){return n(),i("div",null,e[0]||(e[0]=[a('<p>从 <code>Linux 2.5</code> 开始，内核使用 <code>O(1)</code> 调度算法。在数以十计的多处理器的环境下性能好，可扩展性强。但是对于交互进程，也就是哪些响应时间敏感的程序表现不佳。</p><p>于是，从 <code>linux 2.6</code> 开始，引入了新的进程调度算法，其中最为著名的是 “反转楼梯最后期限调度算法”（<code>Rotating Staircase Deadline scheduler, RSDL</code>），该算法吸取了队列理论，将公平调度的概念引入了 Linux 调度程序，最后称为“完全公平调度算法”，简称 CFS。</p><p>本文基于 <code>Linux 2.6.34</code> 研究一下 CFS。此内核中的调度器的设计是模块化的，这样做的好处是可以有针对性的选择不同的调度算法，其中最基本的调度算法为基于分时（<code>time sharing</code>）的技术。</p><h3 id="一、架构" tabindex="-1"><a class="header-anchor" href="#一、架构"><span>一、架构</span></a></h3><p>调度策略是模式化设计，调度器根据不同的进程依次遍历不同的调度策略，找到进程对应的调度策略，调度的结果即为选出一个可运行的进程指针，并将其加入到进程可运行队列中。</p><img src="'+l+'" style="zoom:50%;"><ul><li>CFS 完全公平调度：CFS 的出发点基于一个简单的理念，即所有进程实际占用 CPU 的时间应该是一致的，目的是确保每个进程公平的 CPU 使用比，即最大的利用了计算资源</li><li>FIFO 先入先出队列：不基于时间片调度，处于可运行状态的 SCHED_FIFO 级别的进程比 SCHED_NORMAL 有更高优先级得到调度，一旦 SCHED_FIFO 级别的进程处于可执行的状态，他就会一直运行，直到进程阻塞或者主动释放</li><li>RR（Round-Robin）：SCHED_RR 级别的进程在耗尽事先分配的时间片之后就不会继续执行。即可以理解为带时间片的 SCHED_FIFO</li></ul><p>FIFO 和 RR 调度算法都为静态优先级。也就是说，内核不为实时进程计算动态优先级，这样保证了优先级高的实时进程总能抢到优先级比他低的进程。</p><h3 id="二、进程调度的实现" tabindex="-1"><a class="header-anchor" href="#二、进程调度的实现"><span>二、进程调度的实现</span></a></h3><p>主要分为 4 个部分：时间记账、进程选择、调度器、睡眠和唤醒</p><h4 id="_1-时间记账" tabindex="-1"><a class="header-anchor" href="#_1-时间记账"><span>1. 时间记账</span></a></h4><p>所有的调度器都必须对进程的运行时间做记账。CFS 不再有时间片的概念，他维护了每个进程运行的时间记账，因为每个进程只在公平分配给他的处理器时间内运行。</p><p>vruntime：进程的虚拟运行时间。和进程的 nice 值有关系。越低的 nice 值，表示越高的优先级，那么可以获得更多的处理器使用权重。同时 vruntime 被定义在 <code>struct sched_entity</code> 结构体中。</p><h4 id="_2-进程选择" tabindex="-1"><a class="header-anchor" href="#_2-进程选择"><span>2. 进程选择</span></a></h4><p>当 CFS 调度器选择下一个要进行调度的进程时，就会选择具有最小 vruntime 的进程。内核使用红黑树，以 vruntime 为排序条件，存储着任务的运行情况。</p><p>当选择最小 vruntime 的进程时，直到取红黑树最左的节点即可。</p><h4 id="_3-调度器" tabindex="-1"><a class="header-anchor" href="#_3-调度器"><span>3. 调度器</span></a></h4><p>进程调度器的总体流程为：选择一个合适的调度策略，通过调度策略选出下一个需要被调度的进程，然后进行一次上下文切换，将进程置为运行态。此时选中的进程要么开始运行，要么在运行队列中等待执行。</p><h4 id="_4-睡眠和唤醒" tabindex="-1"><a class="header-anchor" href="#_4-睡眠和唤醒"><span>4. 睡眠和唤醒</span></a></h4><p>休眠（被唤醒）状态的进程处于不可执行的状态。进程休眠的原因有多种多样，但通常来说都是等待某一事件的发生，例如等待 IO，等待设备输入等等。</p><p>内核对于休眠和唤醒的操作如下：</p><ul><li>休眠：进程首先把自己标记为休眠状态（<code>TASK_INTERRUPTIBLE</code>），然后从可执行红黑树中移除该进程，并将进程放入等待队列</li><li>唤醒：进程被置为可执行状态（<code>TASK_RUNNING</code>），进程从等待队列移入可执行红黑树中</li></ul><p>休眠或者阻塞状态有两种：可中断休眠（<code>TASK_INTERRUPTIBLE</code>）、不可中断休眠（<code>TASK_UNINTERRUPTIBLE</code>）。通常进程的休眠，为可中断休眠，即进程进入休眠，等待某一事件发生，一旦事件发生，或者满足条件，内核将会把进程状态置为运行，并将进程从等待队列中移除。</p><h3 id="三、抢占和上下文切换" tabindex="-1"><a class="header-anchor" href="#三、抢占和上下文切换"><span>三、抢占和上下文切换</span></a></h3><p>上下文切换，也就是 CPU 将一个可执行的进程切换到另一个可执行的进程，其中有两个比较关键的步骤</p><ul><li>switch_mem：把虚拟内存从上一个进程映射切换到新进程中</li><li>switch_to：切换进程的处理器状态信息。包括保护、恢复栈信息和寄存器信息等</li></ul><p>内核会在一定的情况下触发调度，比如：</p><ul><li>用户态抢占（重新调度） <ul><li>从系统调用返回用户空间时，比如 read、write、syscall 等</li><li>从中断处理程序返回用户空间时，比如 硬件中断，时钟中断 等</li></ul></li><li>内核态抢占（重新调度） <ul><li>中断处理程序正在执行，且返回内核空间之前</li><li>内核任务显式的调用 schedule 进行调度</li><li>内核任务阻塞时</li></ul></li></ul><h3 id="四、总结" tabindex="-1"><a class="header-anchor" href="#四、总结"><span>四、总结</span></a></h3><p>简单来说，CFS 是动态计算程序优先级的一种调度算法，其内部算法核心是选取 vruntime 最小的进程进行调度运行，而维护最小 vruntime 的进程，使用了红黑树，而计算 vruntime 使用了 nice 值进行加权。</p><p>Linux 内核的调度程序 CFS，尽可能的满足了各个方面的需求，并找到了一种在调度周期和吞吐量之间的平衡。</p>',31)]))}const s=t(o,[["render",c],["__file","2.进程调度之CFS算法.html.vue"]]),h=JSON.parse('{"path":"/%E6%8A%80%E6%9C%AF%E4%B8%93%E9%A2%98/Linux%E7%A0%94%E7%A9%B6/2.%E8%BF%9B%E7%A8%8B%E8%B0%83%E5%BA%A6%E4%B9%8BCFS%E7%AE%97%E6%B3%95.html","title":"2.进程调度之CFS算法","lang":"zh-CN","frontmatter":{"title":"2.进程调度之CFS算法","description":"从 Linux 2.5 开始，内核使用 O(1) 调度算法。在数以十计的多处理器的环境下性能好，可扩展性强。但是对于交互进程，也就是哪些响应时间敏感的程序表现不佳。 于是，从 linux 2.6 开始，引入了新的进程调度算法，其中最为著名的是 “反转楼梯最后期限调度算法”（Rotating Staircase Deadline scheduler, R...","head":[["meta",{"property":"og:url","content":"https://noahyz.github.io/%E6%8A%80%E6%9C%AF%E4%B8%93%E9%A2%98/Linux%E7%A0%94%E7%A9%B6/2.%E8%BF%9B%E7%A8%8B%E8%B0%83%E5%BA%A6%E4%B9%8BCFS%E7%AE%97%E6%B3%95.html"}],["meta",{"property":"og:site_name","content":"noahyz的博客"}],["meta",{"property":"og:title","content":"2.进程调度之CFS算法"}],["meta",{"property":"og:description","content":"从 Linux 2.5 开始，内核使用 O(1) 调度算法。在数以十计的多处理器的环境下性能好，可扩展性强。但是对于交互进程，也就是哪些响应时间敏感的程序表现不佳。 于是，从 linux 2.6 开始，引入了新的进程调度算法，其中最为著名的是 “反转楼梯最后期限调度算法”（Rotating Staircase Deadline scheduler, R..."}],["meta",{"property":"og:type","content":"article"}],["meta",{"property":"og:locale","content":"zh-CN"}],["meta",{"property":"article:author","content":"noahyz"}],["script",{"type":"application/ld+json"},"{\\"@context\\":\\"https://schema.org\\",\\"@type\\":\\"Article\\",\\"headline\\":\\"2.进程调度之CFS算法\\",\\"image\\":[\\"\\"],\\"dateModified\\":null,\\"author\\":[{\\"@type\\":\\"Person\\",\\"name\\":\\"noahyz\\",\\"url\\":\\"/about-the-author/\\"}]}"]]},"headers":[{"level":3,"title":"一、架构","slug":"一、架构","link":"#一、架构","children":[]},{"level":3,"title":"二、进程调度的实现","slug":"二、进程调度的实现","link":"#二、进程调度的实现","children":[]},{"level":3,"title":"三、抢占和上下文切换","slug":"三、抢占和上下文切换","link":"#三、抢占和上下文切换","children":[]},{"level":3,"title":"四、总结","slug":"四、总结","link":"#四、总结","children":[]}],"git":{},"readingTime":{"minutes":4.92,"words":1477},"filePathRelative":"技术专题/Linux研究/2.进程调度之CFS算法.md","excerpt":"<p>从 <code>Linux 2.5</code> 开始，内核使用 <code>O(1)</code> 调度算法。在数以十计的多处理器的环境下性能好，可扩展性强。但是对于交互进程，也就是哪些响应时间敏感的程序表现不佳。</p>\\n<p>于是，从 <code>linux 2.6</code> 开始，引入了新的进程调度算法，其中最为著名的是 “反转楼梯最后期限调度算法”（<code>Rotating Staircase Deadline scheduler, RSDL</code>），该算法吸取了队列理论，将公平调度的概念引入了 Linux 调度程序，最后称为“完全公平调度算法”，简称 CFS。</p>","autoDesc":true}');export{s as comp,h as data};

import{_ as s}from"./plugin-vue_export-helper-DlAUqK2U.js";import{c as a,a as n,o as e}from"./app-D1zlwylF.js";const l="/assets/ELF%E6%96%87%E4%BB%B6%E6%A0%BC%E5%BC%8F-D7pnPv-w.png",t={};function h(p,i){return e(),a("div",null,i[0]||(i[0]=[n('<h2 id="认识-elf-文件格式-一" tabindex="-1"><a class="header-anchor" href="#认识-elf-文件格式-一"><span>认识 ELF 文件格式（一）</span></a></h2><p>前面用了两篇文章做引子，简单说明了二进制的生成过程，以及二进制的运行过程。我们接下来进行我们的重点话题，即 ELF 文件的格式，接下来我们一起来了解 ELF 文件的内容格式。</p><p>ELF 文件格式不仅针对于可执行文件，还有可重定位文件、共享库、以及核心转储（Core 文件）。</p><p>我们主要分享 64 位 ELF 文件格式，他是 32 位的 ELF 文件格式是比较相似的，主要区别也就是某些头部字段和其他数据结构的大小和顺序。</p><p>ELF 文件格式实际上可以划分为 4 个模块：ELF 头部、多个程序头、多个节、每个节对应的节头。如下：</p><figure><img src="'+l+`" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure><p>接下来我们详细的说明每个部位的组成。</p><h3 id="一、elf-头部" tabindex="-1"><a class="header-anchor" href="#一、elf-头部"><span>一、ELF 头部</span></a></h3><p>每个 ELF 文件都是从 ELF 头部开始，他是一系列结构化的字节。主要告诉我们这是一个什么样的 ELF 文件。我们直接来看他的格式。他的定义在 <code>/usr/include/elf.h</code> 文件中。</p><div class="language-c line-numbers-mode" data-highlighter="shiki" data-ext="c" data-title="c" style="--shiki-light:#24292e;--shiki-dark:#abb2bf;--shiki-light-bg:#fff;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes github-light one-dark-pro vp-code"><code><span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#7F848E;--shiki-light-font-style:inherit;--shiki-dark-font-style:italic;">/* Type for a 16-bit quantity.  */</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#C678DD;">typedef</span><span style="--shiki-light:#D73A49;--shiki-dark:#C678DD;"> uint16_t</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;"> Elf32_Half;</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#C678DD;">typedef</span><span style="--shiki-light:#D73A49;--shiki-dark:#C678DD;"> uint16_t</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;"> Elf64_Half;</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#7F848E;--shiki-light-font-style:inherit;--shiki-dark-font-style:italic;">/* Types for signed and unsigned 32-bit quantities.  */</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#C678DD;">typedef</span><span style="--shiki-light:#D73A49;--shiki-dark:#C678DD;"> uint32_t</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;"> Elf32_Word;</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#C678DD;">typedef</span><span style="--shiki-light:#D73A49;--shiki-dark:#C678DD;">	int32_t</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">  Elf32_Sword;</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#C678DD;">typedef</span><span style="--shiki-light:#D73A49;--shiki-dark:#C678DD;"> uint32_t</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;"> Elf64_Word;</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#C678DD;">typedef</span><span style="--shiki-light:#D73A49;--shiki-dark:#C678DD;">	int32_t</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">  Elf64_Sword;</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#7F848E;--shiki-light-font-style:inherit;--shiki-dark-font-style:italic;">/* Types for signed and unsigned 64-bit quantities.  */</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#C678DD;">typedef</span><span style="--shiki-light:#D73A49;--shiki-dark:#C678DD;"> uint64_t</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;"> Elf32_Xword;</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#C678DD;">typedef</span><span style="--shiki-light:#D73A49;--shiki-dark:#C678DD;">	int64_t</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">  Elf32_Sxword;</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#C678DD;">typedef</span><span style="--shiki-light:#D73A49;--shiki-dark:#C678DD;"> uint64_t</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;"> Elf64_Xword;</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#C678DD;">typedef</span><span style="--shiki-light:#D73A49;--shiki-dark:#C678DD;">	int64_t</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">  Elf64_Sxword;</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#7F848E;--shiki-light-font-style:inherit;--shiki-dark-font-style:italic;">/* Type of addresses.  */</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#C678DD;">typedef</span><span style="--shiki-light:#D73A49;--shiki-dark:#C678DD;"> uint32_t</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;"> Elf32_Addr;</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#C678DD;">typedef</span><span style="--shiki-light:#D73A49;--shiki-dark:#C678DD;"> uint64_t</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;"> Elf64_Addr;</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#7F848E;--shiki-light-font-style:inherit;--shiki-dark-font-style:italic;">/* Type of file offsets.  */</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#C678DD;">typedef</span><span style="--shiki-light:#D73A49;--shiki-dark:#C678DD;"> uint32_t</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;"> Elf32_Off;</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#C678DD;">typedef</span><span style="--shiki-light:#D73A49;--shiki-dark:#C678DD;"> uint64_t</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;"> Elf64_Off;</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#7F848E;--shiki-light-font-style:inherit;--shiki-dark-font-style:italic;">/* Type for section indices, which are 16-bit quantities.  */</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#C678DD;">typedef</span><span style="--shiki-light:#D73A49;--shiki-dark:#C678DD;"> uint16_t</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;"> Elf32_Section;</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#C678DD;">typedef</span><span style="--shiki-light:#D73A49;--shiki-dark:#C678DD;"> uint16_t</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;"> Elf64_Section;</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#7F848E;--shiki-light-font-style:inherit;--shiki-dark-font-style:italic;">/* Type for version symbol information.  */</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#C678DD;">typedef</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;"> Elf32_Half Elf32_Versym;</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#C678DD;">typedef</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;"> Elf64_Half Elf64_Versym;</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#C678DD;">typedef</span><span style="--shiki-light:#D73A49;--shiki-dark:#C678DD;"> struct</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">{</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#C678DD;">  unsigned</span><span style="--shiki-light:#D73A49;--shiki-dark:#C678DD;"> char</span><span style="--shiki-light:#E36209;--shiki-dark:#E06C75;">	e_ident</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">[EI_NIDENT];</span><span style="--shiki-light:#6A737D;--shiki-dark:#7F848E;--shiki-light-font-style:inherit;--shiki-dark-font-style:italic;">	/* Magic number and other info */</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">  Elf64_Half	e_type;</span><span style="--shiki-light:#6A737D;--shiki-dark:#7F848E;--shiki-light-font-style:inherit;--shiki-dark-font-style:italic;">			/* Object file type */</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">  Elf64_Half	e_machine;</span><span style="--shiki-light:#6A737D;--shiki-dark:#7F848E;--shiki-light-font-style:inherit;--shiki-dark-font-style:italic;">		/* Architecture */</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">  Elf64_Word	e_version;</span><span style="--shiki-light:#6A737D;--shiki-dark:#7F848E;--shiki-light-font-style:inherit;--shiki-dark-font-style:italic;">		/* Object file version */</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">  Elf64_Addr	e_entry;</span><span style="--shiki-light:#6A737D;--shiki-dark:#7F848E;--shiki-light-font-style:inherit;--shiki-dark-font-style:italic;">		/* Entry point virtual address */</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">  Elf64_Off	e_phoff;</span><span style="--shiki-light:#6A737D;--shiki-dark:#7F848E;--shiki-light-font-style:inherit;--shiki-dark-font-style:italic;">		/* Program header table file offset */</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">  Elf64_Off	e_shoff;</span><span style="--shiki-light:#6A737D;--shiki-dark:#7F848E;--shiki-light-font-style:inherit;--shiki-dark-font-style:italic;">		/* Section header table file offset */</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">  Elf64_Word	e_flags;</span><span style="--shiki-light:#6A737D;--shiki-dark:#7F848E;--shiki-light-font-style:inherit;--shiki-dark-font-style:italic;">		/* Processor-specific flags */</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">  Elf64_Half	e_ehsize;</span><span style="--shiki-light:#6A737D;--shiki-dark:#7F848E;--shiki-light-font-style:inherit;--shiki-dark-font-style:italic;">		/* ELF header size in bytes */</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">  Elf64_Half	e_phentsize;</span><span style="--shiki-light:#6A737D;--shiki-dark:#7F848E;--shiki-light-font-style:inherit;--shiki-dark-font-style:italic;">		/* Program header table entry size */</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">  Elf64_Half	e_phnum;</span><span style="--shiki-light:#6A737D;--shiki-dark:#7F848E;--shiki-light-font-style:inherit;--shiki-dark-font-style:italic;">		/* Program header table entry count */</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">  Elf64_Half	e_shentsize;</span><span style="--shiki-light:#6A737D;--shiki-dark:#7F848E;--shiki-light-font-style:inherit;--shiki-dark-font-style:italic;">		/* Section header table entry size */</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">  Elf64_Half	e_shnum;</span><span style="--shiki-light:#6A737D;--shiki-dark:#7F848E;--shiki-light-font-style:inherit;--shiki-dark-font-style:italic;">		/* Section header table entry count */</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">  Elf64_Half	e_shstrndx;</span><span style="--shiki-light:#6A737D;--shiki-dark:#7F848E;--shiki-light-font-style:inherit;--shiki-dark-font-style:italic;">		/* Section header string table index */</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">} Elf64_Ehdr;</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>我们来解释一下这个结构，其中这些字段的类型是一个 typedef。可自行查看定义。</p><h4 id="_1-e-ident" tabindex="-1"><a class="header-anchor" href="#_1-e-ident"><span>1. e_ident</span></a></h4><p>他是一个 16 字节的数组。</p><p>这个数组的前 4 个字节为魔数。分别为：0x7F、字母 E、字母 L、字母 F。使用魔数可以快速得知我们处理的是 ELF 文件</p><p>接下来的 12 字节，分别为 <code>EI_CLASS、EI_DATA、EI_VERSION、EI_OSABI、EI_ABIVERSION、EI_PAD</code>。其中 <code>EI_PAD</code> 包含 7 个字节，其他的都只是 1 个字节。</p><ul><li><code>EI_CLASS</code>：表示该 ELF 文件是 32 位还是 64 位的体系结构。如果是 32 位的，会被设置为 1，64 位会被设置为 2。</li><li><code>EI_DATA</code>：表示该 ELF 文件的字节序。值为 1 表示小端字节序，值为 2 表示大端字节序。字节序也就是多字节值在内存中是以最低有效字节优化（小端），还是以最高有效字节优先（大端）。</li><li><code>EI_VERSION</code>：表示 ELF 的规范版本，当前只有一个有效值为 1。</li><li><code>EI_OSABI</code>：表示应用程序二进制接口（Application Binary Interface，ABI）和操纵系统（Operating System，OS）的信息。如果 <code>EI_OSABI</code> 字节设置为非零，则意味着在 ELF 文件中会使用一些 ABI 或者 OS 的具体扩展名。这可能会改变 ELF 文件中某些字段的含义，也可能表示存在非标准节。默认值为零，表示该二进制文件以 <code>UNIX System V ABI</code> 为目标。</li><li><code>EI_ABIVERSION</code>：表示 <code>EI_OSABI</code> 字节指定的 ABI 的具体版本。通常为零。</li><li><code>EI_PAD</code>：有 7 个字节，这些字节作为保留，目前默认填充为零。</li></ul><p>好，我们使用 readelf 工具来看看 ELF 文件的 e_ident 数组。还是我们之前的 “hello world” 程序生成的二进制文件。</p><div class="language-shell line-numbers-mode" data-highlighter="shiki" data-ext="shell" data-title="shell" style="--shiki-light:#24292e;--shiki-dark:#abb2bf;--shiki-light-bg:#fff;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes github-light one-dark-pro vp-code"><code><span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#7F848E;--shiki-light-font-style:inherit;--shiki-dark-font-style:italic;"> # readelf -h a.out</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#61AFEF;">ELF</span><span style="--shiki-light:#032F62;--shiki-dark:#98C379;"> Header:</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#61AFEF;">  Magic:</span><span style="--shiki-light:#032F62;--shiki-dark:#98C379;">   7f</span><span style="--shiki-light:#005CC5;--shiki-dark:#D19A66;"> 45</span><span style="--shiki-light:#032F62;--shiki-dark:#98C379;"> 4c</span><span style="--shiki-light:#005CC5;--shiki-dark:#D19A66;"> 46</span><span style="--shiki-light:#005CC5;--shiki-dark:#D19A66;"> 02</span><span style="--shiki-light:#005CC5;--shiki-dark:#D19A66;"> 01</span><span style="--shiki-light:#005CC5;--shiki-dark:#D19A66;"> 01</span><span style="--shiki-light:#005CC5;--shiki-dark:#D19A66;"> 00</span><span style="--shiki-light:#005CC5;--shiki-dark:#D19A66;"> 00</span><span style="--shiki-light:#005CC5;--shiki-dark:#D19A66;"> 00</span><span style="--shiki-light:#005CC5;--shiki-dark:#D19A66;"> 00</span><span style="--shiki-light:#005CC5;--shiki-dark:#D19A66;"> 00</span><span style="--shiki-light:#005CC5;--shiki-dark:#D19A66;"> 00</span><span style="--shiki-light:#005CC5;--shiki-dark:#D19A66;"> 00</span><span style="--shiki-light:#005CC5;--shiki-dark:#D19A66;"> 00</span><span style="--shiki-light:#005CC5;--shiki-dark:#D19A66;"> 00</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#61AFEF;">  Class:</span><span style="--shiki-light:#032F62;--shiki-dark:#98C379;">                             ELF64</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#61AFEF;">  Data:</span><span style="--shiki-light:#005CC5;--shiki-dark:#D19A66;">                              2</span><span style="--shiki-light:#032F62;--shiki-dark:#98C379;">&#39;s complement, little endian</span></span>
<span class="line"><span style="--shiki-light:#032F62;--shiki-dark:#98C379;">  Version:                           1 (current)</span></span>
<span class="line"><span style="--shiki-light:#032F62;--shiki-dark:#98C379;">  OS/ABI:                            UNIX - System V</span></span>
<span class="line"><span style="--shiki-light:#032F62;--shiki-dark:#98C379;">  ABI Version:                       0</span></span>
<span class="line"><span style="--shiki-light:#032F62;--shiki-dark:#98C379;">  Type:                              EXEC (Executable file)</span></span>
<span class="line"><span style="--shiki-light:#032F62;--shiki-dark:#98C379;">  Machine:                           Advanced Micro Devices X86-64</span></span>
<span class="line"><span style="--shiki-light:#032F62;--shiki-dark:#98C379;">  Version:                           0x1</span></span>
<span class="line"><span style="--shiki-light:#032F62;--shiki-dark:#98C379;">  Entry point address:               0x530</span></span>
<span class="line"><span style="--shiki-light:#032F62;--shiki-dark:#98C379;">  Start of program headers:          64 (bytes into file)</span></span>
<span class="line"><span style="--shiki-light:#032F62;--shiki-dark:#98C379;">  Start of section headers:          6440 (bytes into file)</span></span>
<span class="line"><span style="--shiki-light:#032F62;--shiki-dark:#98C379;">  Flags:                             0x0</span></span>
<span class="line"><span style="--shiki-light:#032F62;--shiki-dark:#98C379;">  Size of this header:               64 (bytes)</span></span>
<span class="line"><span style="--shiki-light:#032F62;--shiki-dark:#98C379;">  Size of program headers:           56 (bytes)</span></span>
<span class="line"><span style="--shiki-light:#032F62;--shiki-dark:#98C379;">  Number of program headers:         9</span></span>
<span class="line"><span style="--shiki-light:#032F62;--shiki-dark:#98C379;">  Size of section headers:           64 (bytes)</span></span>
<span class="line"><span style="--shiki-light:#032F62;--shiki-dark:#98C379;">  Number of section headers:         29</span></span>
<span class="line"><span style="--shiki-light:#032F62;--shiki-dark:#98C379;">  Section header string table index: 28</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><ul><li>我们看到 4 个字节的魔数，包括：<code>0x7f</code>，接下来 <code>0x45</code> 是字母 E 的 ASCII 值，<code>0x4c</code> 是字母 L 的 ASCII 值，<code>0x46</code> 是字母 F 的 ASCII 值。</li><li>接下来的 <code>0x02</code> 表示 <code>EI_CLASS</code> ，代表是 64 位体系结构</li><li>接下来的 <code>0x01</code> 是 <code>EI_DATA</code>，代表是小端字节序</li><li>接下来是 <code>0x01</code> 是 <code>EI_VERSION</code>，代表是 ELF 的版本，默认为 1</li><li><code>EI_OSABI</code> 和 <code>EI_ABIVERSION</code> 使用的默认值，默认都为 0</li><li><code>EI_PAD</code> 这 7 个字节作为保留，填充的都为 0</li></ul><h4 id="_2-e-type" tabindex="-1"><a class="header-anchor" href="#_2-e-type"><span>2. e_type</span></a></h4><p>占 2 个字节，<code>e_type</code> 字段指定了 ELF 文件的类型。有如下几种常见的类型</p><ul><li><code>ET_REL</code>：值为 1，表示可重定位文件</li><li><code>EI_EXEC</code>：值为 2，表示可执行二进制文件</li><li><code>ET_DYN</code>：值为 3，表示动态库，也称为共享库</li></ul><h4 id="_3-e-machine" tabindex="-1"><a class="header-anchor" href="#_3-e-machine"><span>3. e_machine</span></a></h4><p>占 2 个字节，表示机器的体系结构，也是该 ELF 文件的平台属性，比如：<code>Advanced Micro Devices X86-64</code> 表示该 ELF 文件只能在 x86-64 的机器上使用。</p><ul><li><code>EM_X86_64</code>：x86-64 的机器上</li><li><code>EM_386</code>：表示 Intel x86，也就是 32 位的 x86 机器上</li><li><code>EM_ARM</code>：表示 arm 机器</li></ul><h4 id="_4-e-version" tabindex="-1"><a class="header-anchor" href="#_4-e-version"><span>4. e_version</span></a></h4><p>这个字段的作用和 <code>e_ident</code> 数组中的 <code>EI_VERSION</code> 字节的作用相同。他表示创建二进制文件时使用的 ELF 版本规范。占用 4 个字节，但只有一个默认值，且默认值为 1。</p><h4 id="_5-e-entry" tabindex="-1"><a class="header-anchor" href="#_5-e-entry"><span>5. e_entry</span></a></h4><p>这个字段表示二进制文件的入口点，这是一个虚拟地址。这里也是解释器（<code>ld-linux.so</code>）将二进制文件加载到虚拟内存后转移控制权的地方。</p><h4 id="_6-e-phoff" tabindex="-1"><a class="header-anchor" href="#_6-e-phoff"><span>6. e_phoff</span></a></h4><p>这个字段表示<strong>程序头</strong>在 ELF 文件中偏移。我们知道，ELF 文件可能会有多个程序头，这个字段表示第一个程序头相对于 ELF 文件的偏移量。</p><p>这个偏移量可以设置为零，表示该 ELF 文件不包含程序头。</p><h4 id="_7-e-shoff" tabindex="-1"><a class="header-anchor" href="#_7-e-shoff"><span>7. e_shoff</span></a></h4><p>这个字段表示<strong>节头</strong>在 ELF 文件中的偏移。同样的，ELF 文件可能会有多个节头，这个字段表示第一个节头相对于 ELF 文件的偏移量，同样的，这个偏移量可以设置为零，表示该 ELF 文件不包含节头。</p><h4 id="_8-e-flags" tabindex="-1"><a class="header-anchor" href="#_8-e-flags"><span>8. e_flags</span></a></h4><p>这个字段用来标识 ELF 文件的平台属性。对于 x86 平台的 ELF 文件，这个字段通常被设置为零。</p><h4 id="_9-e-ehsize" tabindex="-1"><a class="header-anchor" href="#_9-e-ehsize"><span>9. e_ehsize</span></a></h4><p>这个字段指定 ELF 文件头部的大小，单位是字节。我们从结构体 <code>Elf64_Ehdr</code> 可以看出，对于 64 位的 x86 的 ELF 文件，ELF 头部大小始终为 64 字节。</p><h4 id="_10-e-phentsize-和-e-phnum" tabindex="-1"><a class="header-anchor" href="#_10-e-phentsize-和-e-phnum"><span>10. e_phentsize 和 e_phnum</span></a></h4><p>这两个字段分别表示 ELF 文件中程序头的大小和程序头的个数。前面介绍的 <code>e_phoff</code> 表示程序头在 ELF 文件中的偏移。现在这三个字段，可以让我们确定关于程序头的所有的信息。一个 ELF 文件中每个程序头的大小都是一致的。</p><h4 id="_11-e-shentsize-和-e-shnum" tabindex="-1"><a class="header-anchor" href="#_11-e-shentsize-和-e-shnum"><span>11. e_shentsize 和 e_shnum</span></a></h4><p>这两个字段分别表示 ELF 文件中节头的大小和节头的个数。前面介绍的 <code>e_shoff</code> 表示节头在 ELF 文件中的偏移。现在这三个字段可以让我们确定关于节头的所有信息。同样的，一个 ELF 文件中每个节头的大小都是一致的。</p><h4 id="_12-e-shstrndx" tabindex="-1"><a class="header-anchor" href="#_12-e-shstrndx"><span>12. e_shstrndx</span></a></h4><p>ELF 文件中有一个节是特殊字符串表，这个特殊字符串表中存储的是所有节的名称。特殊字符串表是一个节，这个节有他自己的节头。我们知道，ELF 中多个节头是以数组排列的形式放在 ELF 文件中的。那么 <code>e_shstrndx</code> 表示的是特殊字符串表（节）对应的节头，在所有节头中的位置，或者说索引。</p><p>这个特殊字符串表我们后面会详细说到。</p><h3 id="二、小结" tabindex="-1"><a class="header-anchor" href="#二、小结"><span>二、小结</span></a></h3><p>好！以上我们把 ELF 头部的所有字段说完了。我们在这里声明一下，可能不同的书籍会将以上的一些名词翻译成其他，大家要掌握他的原理即可，不要过分纠结不同的名次。</p><p>比如：Section：在本篇文章我将其翻译成 节。不过他还有段的意思等等。所以我们明白这个意思即可，不要纠结</p><p>可以通过 <code>readelf</code> 工具尝试自己解析一下 Linux 二进制文件、共享库文件。看看有什么不同，以及各个字段表示的含义。</p>`,49)]))}const r=s(t,[["render",h],["__file","3.认识ELF文件格式一.html.vue"]]),c=JSON.parse('{"path":"/%E6%8A%80%E6%9C%AF%E4%B8%93%E9%A2%98/%E9%93%BE%E6%8E%A5%E4%B8%8E%E8%A3%85%E8%BD%BD/3.%E8%AE%A4%E8%AF%86ELF%E6%96%87%E4%BB%B6%E6%A0%BC%E5%BC%8F%E4%B8%80.html","title":"3.认识ELF文件格式（一）","lang":"zh-CN","frontmatter":{"title":"3.认识ELF文件格式（一）","description":"认识 ELF 文件格式（一） 前面用了两篇文章做引子，简单说明了二进制的生成过程，以及二进制的运行过程。我们接下来进行我们的重点话题，即 ELF 文件的格式，接下来我们一起来了解 ELF 文件的内容格式。 ELF 文件格式不仅针对于可执行文件，还有可重定位文件、共享库、以及核心转储（Core 文件）。 我们主要分享 64 位 ELF 文件格式，他是 3...","head":[["meta",{"property":"og:url","content":"https://noahyz.github.io/%E6%8A%80%E6%9C%AF%E4%B8%93%E9%A2%98/%E9%93%BE%E6%8E%A5%E4%B8%8E%E8%A3%85%E8%BD%BD/3.%E8%AE%A4%E8%AF%86ELF%E6%96%87%E4%BB%B6%E6%A0%BC%E5%BC%8F%E4%B8%80.html"}],["meta",{"property":"og:site_name","content":"noahyz的博客"}],["meta",{"property":"og:title","content":"3.认识ELF文件格式（一）"}],["meta",{"property":"og:description","content":"认识 ELF 文件格式（一） 前面用了两篇文章做引子，简单说明了二进制的生成过程，以及二进制的运行过程。我们接下来进行我们的重点话题，即 ELF 文件的格式，接下来我们一起来了解 ELF 文件的内容格式。 ELF 文件格式不仅针对于可执行文件，还有可重定位文件、共享库、以及核心转储（Core 文件）。 我们主要分享 64 位 ELF 文件格式，他是 3..."}],["meta",{"property":"og:type","content":"article"}],["meta",{"property":"og:locale","content":"zh-CN"}],["meta",{"property":"article:author","content":"noahyz"}],["script",{"type":"application/ld+json"},"{\\"@context\\":\\"https://schema.org\\",\\"@type\\":\\"Article\\",\\"headline\\":\\"3.认识ELF文件格式（一）\\",\\"image\\":[\\"\\"],\\"dateModified\\":null,\\"author\\":[{\\"@type\\":\\"Person\\",\\"name\\":\\"noahyz\\",\\"url\\":\\"/about-the-author/\\"}]}"]]},"headers":[{"level":2,"title":"认识 ELF 文件格式（一）","slug":"认识-elf-文件格式-一","link":"#认识-elf-文件格式-一","children":[{"level":3,"title":"一、ELF 头部","slug":"一、elf-头部","link":"#一、elf-头部","children":[]},{"level":3,"title":"二、小结","slug":"二、小结","link":"#二、小结","children":[]}]}],"git":{},"readingTime":{"minutes":7.32,"words":2196},"filePathRelative":"技术专题/链接与装载/3.认识ELF文件格式一.md","excerpt":"<h2>认识 ELF 文件格式（一）</h2>\\n<p>前面用了两篇文章做引子，简单说明了二进制的生成过程，以及二进制的运行过程。我们接下来进行我们的重点话题，即 ELF 文件的格式，接下来我们一起来了解 ELF 文件的内容格式。</p>\\n<p>ELF 文件格式不仅针对于可执行文件，还有可重定位文件、共享库、以及核心转储（Core 文件）。</p>\\n<p>我们主要分享 64 位 ELF 文件格式，他是 32 位的 ELF 文件格式是比较相似的，主要区别也就是某些头部字段和其他数据结构的大小和顺序。</p>\\n<p>ELF 文件格式实际上可以划分为 4 个模块：ELF 头部、多个程序头、多个节、每个节对应的节头。如下：</p>","autoDesc":true}');export{r as comp,c as data};

import{_ as t}from"./plugin-vue_export-helper-DlAUqK2U.js";import{c as n,a as i,o as a}from"./app-D1zlwylF.js";const s="/assets/%E4%BC%98%E5%85%88%E7%BA%A7%E5%8F%8D%E8%BD%AC%E6%A1%88%E4%BE%8B-ajrWui_-.png",p="/assets/%E4%BC%98%E5%85%88%E7%BA%A7%E5%8F%8D%E8%BD%AC2-BGTrBA2h.png",l={};function r(o,e){return a(),n("div",null,e[0]||(e[0]=[i('<p>实时操作系统的一个基本要求就是基于优先级的抢占系统，保证高优先级的线程在 “第一时间” 抢到执行权，是实时系统的第一黄金法则。</p><p>但是基于优先级抢占的系统，有一个著名问题就是：优先级反转。也就是说，有低优先级的线程占据了 CPU，妨碍了高优先级线程的执行。</p><p>有一个比较著名的案例，就是 1997 年美国宇航局的火星探路车，在登陆火星后的一段时间里无法工作，最后查明是因为优先级反转导致探路车的计算机不断重启的问题。</p><h3 id="一、什么是优先级反转" tabindex="-1"><a class="header-anchor" href="#一、什么是优先级反转"><span>一、什么是优先级反转</span></a></h3><p>如下是经典的优先级反转案例</p><img src="'+s+`" style="zoom:50%;"><ul><li>线程 A 优先级为 10（低优先级），在 T1 时刻锁定了一把互斥锁，并开始操作互斥数据</li><li>线程 C 优先级为 20（高优先级），在 T2 时刻被唤醒，他也需要互斥数据，当他加锁时，因为互斥锁在 T1 时刻被线程 A 锁掉了，所以线程 C 放弃了 CPU 进入了阻塞等待状态。</li><li>此时，优先级为 10 的线程 A 看上去 “抢了” 优先级为 20 的线程 C 的时间。但是因为程序逻辑如此，线程 C 确实需要退出 CPU 等待，直到互斥数据操作完成之后，才能获得 CPU。但是，假设有一个优先级为 15 的线程 B，在 T3 时刻醒了，因为线程 B 比线程 A 的优先级高，所以他会立即抢占 CPU。而线程 A 被迫进行 READY 状态等待。</li><li>假设一直到 T4 时刻，线程 B 才放弃 CPU，此时优先级为 10 的线程 A 是唯一的 READY（就绪）线程，他再次占据 CPU 继续执行，最后在 T5 时刻解锁。</li><li>那么在 T5 时刻，优先级最高的线程 C 此时才有机会抢占 CPU，系统才会调用线程 C 执行。</li></ul><p>在这个过程中，线程 B 从 T3 时刻到 T4 时刻占据 CPU 运行的行为，就是优先级反转。一个优先级为 15 的线程 B，通过压制优先级为 10 的线程 A，从而导致优先级最高的线程 C 无法得到 CPU。而且这段时间是不可控的。因为线程 B 可以长时间占据 CPU，即使轮询时间片到达，因为线程 A 和线程 B 都处于就绪状态，但是线程 B 的优先级高，线程 B 依然可以占据 CPU。最终的结果就是高优先级的线程 C 可能长时间无法得到 CPU。</p><p>而 1997 年美国宇航局的火星车，就是因为有高优先级的线程被压制，从而在指定时间内无法获得 CPU，导致“看门狗” 认为系统出了无法恢复的故障，直接重启了系统。重启后系统再次进入相同状态，导致不断重启，无法正常工作。</p><p>下面谈谈解决方案</p><h3 id="二、人工防止优先级反转的方法" tabindex="-1"><a class="header-anchor" href="#二、人工防止优先级反转的方法"><span>二、人工防止优先级反转的方法</span></a></h3><p>低优先级的线程获得互斥锁前，需要先将自己的优先级临时提高，最后处理完后再退回原优先级。如下的逻辑：</p><p>假设还是如刚才的案例，优先级为 10 的线程 A；优先级为 15 的线程 B；优先级为 20 的线程 C。那么在优先级为 10 的线程 A 获取互斥锁之前，先提升优先级到 20，解锁后，又恢复到原优先级。</p><div class="language- line-numbers-mode" data-highlighter="shiki" data-ext="" data-title="" style="--shiki-light:#24292e;--shiki-dark:#abb2bf;--shiki-light-bg:#fff;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes github-light one-dark-pro vp-code"><code><span class="line"><span>set_priority(20);</span></span>
<span class="line"><span>pthread_mutex_lock();</span></span>
<span class="line"><span>...</span></span>
<span class="line"><span>pthread_mutex_unlock();</span></span>
<span class="line"><span>set_priority(10);</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>这样，在 T3 的时刻，线程 B 虽然有 15 的优先级，但是对于已经提升到 20 的线程 A 无法形成压制，线程 A 就会继续执行，直到 T5，线程 A 解锁。优先级为 20 的线程 C 立即获取互斥锁运行，线程 B 因为优先级低，无法抢到线程 C 的 CPU。</p><img src="`+p+'" style="zoom:50%;"><p>当然，这里把优先级提高只是特例。在实际场景中，我们需要评估所有可能上锁的线程，找到最高优先级，然后提高到最高优先级。</p><p>但是这种方式对于程序员来说显然比较复杂。而且，在现代的实时操作系统中，这个事情操作系统已经帮我们完成了。</p><p>还有一点注意，在现代的实时操作系统上，如果需要互斥保护，应该尽量使用互斥锁（mutex）。对于初始值为 1 的信号量，虽然在功能上也能互斥，但信号量一般无法做优先级继承，所以会有优先级反转的隐患。</p><p>引用：<a href="https://zhuanlan.zhihu.com/p/146132061" target="_blank" rel="noopener noreferrer">https://zhuanlan.zhihu.com/p/146132061</a></p>',20)]))}const C=t(l,[["render",r],["__file","4.优先级反转.html.vue"]]),d=JSON.parse('{"path":"/%E6%8A%80%E6%9C%AF%E4%B8%93%E9%A2%98/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/4.%E4%BC%98%E5%85%88%E7%BA%A7%E5%8F%8D%E8%BD%AC.html","title":"4. 优先级反转","lang":"zh-CN","frontmatter":{"title":"4. 优先级反转","description":"实时操作系统的一个基本要求就是基于优先级的抢占系统，保证高优先级的线程在 “第一时间” 抢到执行权，是实时系统的第一黄金法则。 但是基于优先级抢占的系统，有一个著名问题就是：优先级反转。也就是说，有低优先级的线程占据了 CPU，妨碍了高优先级线程的执行。 有一个比较著名的案例，就是 1997 年美国宇航局的火星探路车，在登陆火星后的一段时间里无法工作，...","head":[["meta",{"property":"og:url","content":"https://noahyz.github.io/%E6%8A%80%E6%9C%AF%E4%B8%93%E9%A2%98/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/4.%E4%BC%98%E5%85%88%E7%BA%A7%E5%8F%8D%E8%BD%AC.html"}],["meta",{"property":"og:site_name","content":"noahyz的博客"}],["meta",{"property":"og:title","content":"4. 优先级反转"}],["meta",{"property":"og:description","content":"实时操作系统的一个基本要求就是基于优先级的抢占系统，保证高优先级的线程在 “第一时间” 抢到执行权，是实时系统的第一黄金法则。 但是基于优先级抢占的系统，有一个著名问题就是：优先级反转。也就是说，有低优先级的线程占据了 CPU，妨碍了高优先级线程的执行。 有一个比较著名的案例，就是 1997 年美国宇航局的火星探路车，在登陆火星后的一段时间里无法工作，..."}],["meta",{"property":"og:type","content":"article"}],["meta",{"property":"og:locale","content":"zh-CN"}],["meta",{"property":"article:author","content":"noahyz"}],["script",{"type":"application/ld+json"},"{\\"@context\\":\\"https://schema.org\\",\\"@type\\":\\"Article\\",\\"headline\\":\\"4. 优先级反转\\",\\"image\\":[\\"\\"],\\"dateModified\\":null,\\"author\\":[{\\"@type\\":\\"Person\\",\\"name\\":\\"noahyz\\",\\"url\\":\\"/about-the-author/\\"}]}"]]},"headers":[{"level":3,"title":"一、什么是优先级反转","slug":"一、什么是优先级反转","link":"#一、什么是优先级反转","children":[]},{"level":3,"title":"二、人工防止优先级反转的方法","slug":"二、人工防止优先级反转的方法","link":"#二、人工防止优先级反转的方法","children":[]}],"git":{},"readingTime":{"minutes":4.1,"words":1231},"filePathRelative":"技术专题/并发编程/4.优先级反转.md","excerpt":"<p>实时操作系统的一个基本要求就是基于优先级的抢占系统，保证高优先级的线程在 “第一时间” 抢到执行权，是实时系统的第一黄金法则。</p>\\n<p>但是基于优先级抢占的系统，有一个著名问题就是：优先级反转。也就是说，有低优先级的线程占据了 CPU，妨碍了高优先级线程的执行。</p>\\n<p>有一个比较著名的案例，就是 1997 年美国宇航局的火星探路车，在登陆火星后的一段时间里无法工作，最后查明是因为优先级反转导致探路车的计算机不断重启的问题。</p>\\n<h3>一、什么是优先级反转</h3>\\n<p>如下是经典的优先级反转案例</p>\\n\\n<ul>\\n<li>线程 A 优先级为 10（低优先级），在 T1 时刻锁定了一把互斥锁，并开始操作互斥数据</li>\\n<li>线程 C 优先级为 20（高优先级），在 T2 时刻被唤醒，他也需要互斥数据，当他加锁时，因为互斥锁在 T1 时刻被线程 A 锁掉了，所以线程 C 放弃了 CPU 进入了阻塞等待状态。</li>\\n<li>此时，优先级为 10 的线程 A 看上去 “抢了” 优先级为 20 的线程 C 的时间。但是因为程序逻辑如此，线程 C 确实需要退出 CPU 等待，直到互斥数据操作完成之后，才能获得 CPU。但是，假设有一个优先级为 15 的线程 B，在 T3 时刻醒了，因为线程 B 比线程 A 的优先级高，所以他会立即抢占 CPU。而线程 A 被迫进行 READY 状态等待。</li>\\n<li>假设一直到 T4 时刻，线程 B 才放弃 CPU，此时优先级为 10 的线程 A 是唯一的 READY（就绪）线程，他再次占据 CPU 继续执行，最后在 T5 时刻解锁。</li>\\n<li>那么在 T5 时刻，优先级最高的线程 C 此时才有机会抢占 CPU，系统才会调用线程 C 执行。</li>\\n</ul>","autoDesc":true}');export{C as comp,d as data};

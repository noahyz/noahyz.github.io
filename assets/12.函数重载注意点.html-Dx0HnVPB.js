import{_ as s}from"./plugin-vue_export-helper-DlAUqK2U.js";import{c as e,a as n,o as i}from"./app-D1zlwylF.js";const l={};function t(p,a){return i(),e("div",null,a[0]||(a[0]=[n(`<h4 id="一、为什么不要重载-和-操作符" tabindex="-1"><a class="header-anchor" href="#一、为什么不要重载-和-操作符"><span>一、为什么不要重载 &amp;&amp; 和 || 操作符</span></a></h4><div class="language- line-numbers-mode" data-highlighter="shiki" data-ext="" data-title="" style="--shiki-light:#24292e;--shiki-dark:#abb2bf;--shiki-light-bg:#fff;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes github-light one-dark-pro vp-code"><code><span class="line"><span>int a1 = 1;</span></span>
<span class="line"><span>int a2 = 0;</span></span>
<span class="line"><span>if (a1 || a2++) </span></span>
<span class="line"><span>if (a2 &amp;&amp; a1++)</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><ul><li>如上，第一个 if 判断条件因为 a1 为真，所以整个逻辑或就是真，不再执行 <code>a2++</code></li><li>第二个 if 判断条件因为 a2 为假，导致整个逻辑与为假，不再执行 <code>a1++</code></li></ul><p>如果重载 || 或 &amp;&amp; 会是什么情况呢？</p><ul><li>首先理论上，操作符重载是靠函数重载来完成。操作数作为函数参数传递。C++ 的函数参数都会被求值，因此可能会造成语义错误</li></ul><div class="language- line-numbers-mode" data-highlighter="shiki" data-ext="" data-title="" style="--shiki-light:#24292e;--shiki-dark:#abb2bf;--shiki-light-bg:#fff;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes github-light one-dark-pro vp-code"><code><span class="line"><span>class Test {</span></span>
<span class="line"><span>private:</span></span>
<span class="line"><span>    int val;</span></span>
<span class="line"><span>public:</span></span>
<span class="line"><span>    explicit Test(int val) : val(val) {}</span></span>
<span class="line"><span>    bool operator||(const Test&amp; obj) const {</span></span>
<span class="line"><span>        return val || obj.val;</span></span>
<span class="line"><span>    }</span></span>
<span class="line"><span>    bool operator&amp;&amp;(const Test&amp; obj) const {</span></span>
<span class="line"><span>        return val &amp;&amp; obj.val;</span></span>
<span class="line"><span>    }</span></span>
<span class="line"><span>};</span></span>
<span class="line"><span>t1 &amp;&amp; (t1+t2) 这个代码的调用本质是: t1.operator&amp;&amp;( t1.operator+(t2) )</span></span>
<span class="line"><span>其中 t1.operator+(t2) 是作为函数参数传递的，因为这个表达式不管 t1 是否是真假，都会计算求值。</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><ul><li>因此重载之后可能会造成语义错误</li></ul><h4 id="二、为什么不要重载逗号表达式" tabindex="-1"><a class="header-anchor" href="#二、为什么不要重载逗号表达式"><span>二、为什么不要重载逗号表达式</span></a></h4><ul><li>对于逗号表达式，逗号左侧会先被评估，然后逗号的右侧再被评估；最后，整个表达式的结果以逗号右侧的值为代表。</li><li>如果重载了逗号表达式，就无法保证左侧表达式会比右侧表达式先被评估，编译器无法作出保证</li></ul><h4 id="三、哪些操作符不可以重载" tabindex="-1"><a class="header-anchor" href="#三、哪些操作符不可以重载"><span>三、哪些操作符不可以重载</span></a></h4><p>如下的操作符都不建议重载</p><div class="language- line-numbers-mode" data-highlighter="shiki" data-ext="" data-title="" style="--shiki-light:#24292e;--shiki-dark:#abb2bf;--shiki-light-bg:#fff;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes github-light one-dark-pro vp-code"><code><span class="line"><span>.、.*、 ::、 ?:、 new、 delete、 sizeof、 typeif</span></span>
<span class="line"><span>static_cast、dynamic_cast、const_cast、reinterpret_cast</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div></div></div><p>重载的目的就是为了让程序更容易被阅读、被修改、被理解。如果没有好的理由重载某个操作符，就不要重载。</p>`,13)]))}const c=s(l,[["render",t],["__file","12.函数重载注意点.html.vue"]]),o=JSON.parse('{"path":"/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/c__%E8%AF%AD%E8%A8%80/%E7%BC%96%E7%A0%81%E6%8A%80%E5%B7%A7/12.%E5%87%BD%E6%95%B0%E9%87%8D%E8%BD%BD%E6%B3%A8%E6%84%8F%E7%82%B9.html","title":"12.函数重载注意点","lang":"zh-CN","frontmatter":{"title":"12.函数重载注意点","date":"2023-01-19T11:11:41.000Z","tags":["linux"],"description":"一、为什么不要重载 && 和 || 操作符 如上，第一个 if 判断条件因为 a1 为真，所以整个逻辑或就是真，不再执行 a2++ 第二个 if 判断条件因为 a2 为假，导致整个逻辑与为假，不再执行 a1++ 如果重载 || 或 && 会是什么情况呢？ 首先理论上，操作符重载是靠函数重载来完成。操作数作为函数参数传递。C++ 的函数参数都会被求值，因...","head":[["meta",{"property":"og:url","content":"https://noahyz.github.io/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/c__%E8%AF%AD%E8%A8%80/%E7%BC%96%E7%A0%81%E6%8A%80%E5%B7%A7/12.%E5%87%BD%E6%95%B0%E9%87%8D%E8%BD%BD%E6%B3%A8%E6%84%8F%E7%82%B9.html"}],["meta",{"property":"og:site_name","content":"noahyz的博客"}],["meta",{"property":"og:title","content":"12.函数重载注意点"}],["meta",{"property":"og:description","content":"一、为什么不要重载 && 和 || 操作符 如上，第一个 if 判断条件因为 a1 为真，所以整个逻辑或就是真，不再执行 a2++ 第二个 if 判断条件因为 a2 为假，导致整个逻辑与为假，不再执行 a1++ 如果重载 || 或 && 会是什么情况呢？ 首先理论上，操作符重载是靠函数重载来完成。操作数作为函数参数传递。C++ 的函数参数都会被求值，因..."}],["meta",{"property":"og:type","content":"article"}],["meta",{"property":"og:locale","content":"zh-CN"}],["meta",{"property":"article:author","content":"noahyz"}],["meta",{"property":"article:tag","content":"linux"}],["meta",{"property":"article:published_time","content":"2023-01-19T11:11:41.000Z"}],["script",{"type":"application/ld+json"},"{\\"@context\\":\\"https://schema.org\\",\\"@type\\":\\"Article\\",\\"headline\\":\\"12.函数重载注意点\\",\\"image\\":[\\"\\"],\\"datePublished\\":\\"2023-01-19T11:11:41.000Z\\",\\"dateModified\\":null,\\"author\\":[{\\"@type\\":\\"Person\\",\\"name\\":\\"noahyz\\",\\"url\\":\\"/about-the-author/\\"}]}"]]},"headers":[],"git":{},"readingTime":{"minutes":1.45,"words":436},"filePathRelative":"编程语言/c++语言/编码技巧/12.函数重载注意点.md","localizedDate":"2023年1月19日","excerpt":"<h4>一、为什么不要重载 &amp;&amp; 和 || 操作符</h4>\\n<div class=\\"language- line-numbers-mode\\" data-highlighter=\\"shiki\\" data-ext=\\"\\" data-title=\\"\\" style=\\"--shiki-light:#24292e;--shiki-dark:#abb2bf;--shiki-light-bg:#fff;--shiki-dark-bg:#282c34\\"><pre class=\\"shiki shiki-themes github-light one-dark-pro vp-code\\"><code><span class=\\"line\\"><span>int a1 = 1;</span></span>\\n<span class=\\"line\\"><span>int a2 = 0;</span></span>\\n<span class=\\"line\\"><span>if (a1 || a2++) </span></span>\\n<span class=\\"line\\"><span>if (a2 &amp;&amp; a1++)</span></span></code></pre>\\n<div class=\\"line-numbers\\" aria-hidden=\\"true\\" style=\\"counter-reset:line-number 0\\"><div class=\\"line-number\\"></div><div class=\\"line-number\\"></div><div class=\\"line-number\\"></div><div class=\\"line-number\\"></div></div></div>","autoDesc":true}');export{c as comp,o as data};

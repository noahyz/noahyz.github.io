import{_ as t}from"./plugin-vue_export-helper-DlAUqK2U.js";import{c as a,a as n,o as p}from"./app-D1zlwylF.js";const l={};function r(i,e){return p(),a("div",null,e[0]||(e[0]=[n('<h2 id="保护模式二" tabindex="-1"><a class="header-anchor" href="#保护模式二"><span>保护模式二</span></a></h2><p>保护模式的保护主要体现在段描述符的属性字段中，这些属性只是用来描述一块内存的性质，是用来给 CPU 做参考的，当有实际行动在这片内存上发生时，CPU 用这些属性来检查动作的合法性，从而起到保护的作用。</p><h3 id="一、向段寄存器加载选择子时的保护" tabindex="-1"><a class="header-anchor" href="#一、向段寄存器加载选择子时的保护"><span>一、向段寄存器加载选择子时的保护</span></a></h3><p>当引用一个内存段时，就是往段寄存器中加载个选择子，为了避免出现非法引用内存段的情况，CPU 会做如下检查：</p><h4 id="_1-首先根据选择子的值验证段描述符是否超越界限" tabindex="-1"><a class="header-anchor" href="#_1-首先根据选择子的值验证段描述符是否超越界限"><span>1. 首先根据选择子的值验证段描述符是否超越界限</span></a></h4><p>处理器先检查选择子 TI 位的值，如果为 0，则从全局描述符表寄存器 gdtr 中拿到 GDT 基地址和 GDT 界限值。如果 TI 为 1，则从局部描述符表寄存器 ldtr 获取。</p><p>CPU 需要保证选择子是正确的，判断的标准是选择子的索引值一定要小于等于描述符表（GDT 或 LDT）中描述符的个数。段描述符（8字节）的最后 1 字节一定要在描述符表的界限地址之内，因此索引值要满足表达式：<code>描述符表基地址 + 选择子中的索引值 * 8 + 7 &lt;= 描述符表基地址 + 描述符表界限值</code></p><p>GDT 的第 0 个描述符是空描述符。虽然可以往寄存器中加载值为 0 的选择子，但在使用时 CPU 将抛出异常。</p><h4 id="_2-段描述符中有个-type-字段-主要时检查段寄存器的用途和段类型是否匹配。" tabindex="-1"><a class="header-anchor" href="#_2-段描述符中有个-type-字段-主要时检查段寄存器的用途和段类型是否匹配。"><span>2. 段描述符中有个 type 字段，主要时检查段寄存器的用途和段类型是否匹配。</span></a></h4><ul><li>只有具有可执行属性的段（代码段）才能加载到 CS 段寄存器中</li><li>只具备执行属性的段（代码段）不允许加载到初 CS 外的段寄存器中</li><li>只有具备可写属性的段（数据段）才能加载到 SS 栈段寄存器中</li><li>至少具备可读属性的段才能加载到 DS、ES、FS、GS 段寄存器中</li></ul><h4 id="_3-还需要检查段是否存在。cpu-通过段描述符中的-p-位来确认内存段是否存在。" tabindex="-1"><a class="header-anchor" href="#_3-还需要检查段是否存在。cpu-通过段描述符中的-p-位来确认内存段是否存在。"><span>3. 还需要检查段是否存在。CPU 通过段描述符中的 P 位来确认内存段是否存在。</span></a></h4><ul><li>如果 P 位为 1，则表示存在，这时候就可以将选择子载入段寄存器了，同时段描述符缓冲寄存器也会更新为选择子对应的段描述符的内容，随后 CPU 将段描述符中 type 字段的 A 位置为 1，表示 CPU 已经访问过了。</li><li>如果 P 位为 0，则表示该内存段不存在，不存在的原因可能是由于内存不足，操作系统将该段移出内存转储到硬盘上了，这时候 CPU 会抛出异常，自动转去执行相应的异常处理程序，异常处理程序将段从硬盘加载到内存后并将 P 位置为 1，随后返回。CPU 继续执行刚才的操作，判断 P 位。</li></ul><p>总结来说，P 位是由操作系统来设置，由 CPU 来检查。A 位由 CPU 来设置。</p><h3 id="二、代码段和数据段的保护" tabindex="-1"><a class="header-anchor" href="#二、代码段和数据段的保护"><span>二、代码段和数据段的保护</span></a></h3><p>CPU 每访问一个地址，都要确认该地址不能超过其所在内存段的范围。</p><p>对于数据段和代码段，访问内存都需要用分段策略，即“段基址：段内偏移地址” 的形式，在 32 位保护模式下，段基址放在 CS 寄存器中，段内偏移地址，即有效地址，存放在 EIP 寄存器中。</p><p><code>CS:EIP</code> 只是指令的起始地址，指令本身也有长度，因此指令也应该完整的落在段中；当然数据也是有长度的，CPU 也要保证操作数要完整的落在数据段中。否则 CPU 会抛出异常。</p><h3 id="三、栈段的保护" tabindex="-1"><a class="header-anchor" href="#三、栈段的保护"><span>三、栈段的保护</span></a></h3><p>段描述符 type 中的 E 位用来表示段的扩展方向。这也就引出了栈段，他是向下扩展，即地址越来越小。</p><ul><li>对于向上扩展的段，实际的段界限是段内可以访问的最后一字节</li><li>对于向下扩展的段，实际的段界限是段内不可以访问的第一个字节</li></ul><p>栈的段界限是以栈段的基址为基准的，并不是以栈底，因此栈的段界限肯定是位于栈顶之下。地址本身由低向高发展，段界限也是个地址，而栈的扩展方向是由高地址向低地址，与段界限有个碰撞的趋势。为了避免碰撞，将段界限地址 +1 视为栈可以访问的下限。也就是说，段界限+1，才是栈指针可达的下边界。</p>',21)]))}const s=t(l,[["render",r],["__file","2.保护模式2.html.vue"]]),c=JSON.parse('{"path":"/%E6%8A%80%E6%9C%AF%E4%B8%93%E9%A2%98/%E6%89%8B%E5%86%99%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/2.%E4%BF%9D%E6%8A%A4%E6%A8%A1%E5%BC%8F/2.%E4%BF%9D%E6%8A%A4%E6%A8%A1%E5%BC%8F2.html","title":"6.保护模式2","lang":"zh-CN","frontmatter":{"title":"6.保护模式2","description":"保护模式二 保护模式的保护主要体现在段描述符的属性字段中，这些属性只是用来描述一块内存的性质，是用来给 CPU 做参考的，当有实际行动在这片内存上发生时，CPU 用这些属性来检查动作的合法性，从而起到保护的作用。 一、向段寄存器加载选择子时的保护 当引用一个内存段时，就是往段寄存器中加载个选择子，为了避免出现非法引用内存段的情况，CPU 会做如下检查：...","head":[["meta",{"property":"og:url","content":"https://noahyz.github.io/%E6%8A%80%E6%9C%AF%E4%B8%93%E9%A2%98/%E6%89%8B%E5%86%99%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/2.%E4%BF%9D%E6%8A%A4%E6%A8%A1%E5%BC%8F/2.%E4%BF%9D%E6%8A%A4%E6%A8%A1%E5%BC%8F2.html"}],["meta",{"property":"og:site_name","content":"noahyz的博客"}],["meta",{"property":"og:title","content":"6.保护模式2"}],["meta",{"property":"og:description","content":"保护模式二 保护模式的保护主要体现在段描述符的属性字段中，这些属性只是用来描述一块内存的性质，是用来给 CPU 做参考的，当有实际行动在这片内存上发生时，CPU 用这些属性来检查动作的合法性，从而起到保护的作用。 一、向段寄存器加载选择子时的保护 当引用一个内存段时，就是往段寄存器中加载个选择子，为了避免出现非法引用内存段的情况，CPU 会做如下检查：..."}],["meta",{"property":"og:type","content":"article"}],["meta",{"property":"og:locale","content":"zh-CN"}],["meta",{"property":"article:author","content":"noahyz"}],["script",{"type":"application/ld+json"},"{\\"@context\\":\\"https://schema.org\\",\\"@type\\":\\"Article\\",\\"headline\\":\\"6.保护模式2\\",\\"image\\":[\\"\\"],\\"dateModified\\":null,\\"author\\":[{\\"@type\\":\\"Person\\",\\"name\\":\\"noahyz\\",\\"url\\":\\"/about-the-author/\\"}]}"]]},"headers":[{"level":2,"title":"保护模式二","slug":"保护模式二","link":"#保护模式二","children":[{"level":3,"title":"一、向段寄存器加载选择子时的保护","slug":"一、向段寄存器加载选择子时的保护","link":"#一、向段寄存器加载选择子时的保护","children":[]},{"level":3,"title":"二、代码段和数据段的保护","slug":"二、代码段和数据段的保护","link":"#二、代码段和数据段的保护","children":[]},{"level":3,"title":"三、栈段的保护","slug":"三、栈段的保护","link":"#三、栈段的保护","children":[]}]}],"git":{},"readingTime":{"minutes":3.98,"words":1195},"filePathRelative":"技术专题/手写操作系统/2.保护模式/2.保护模式2.md","excerpt":"<h2>保护模式二</h2>\\n<p>保护模式的保护主要体现在段描述符的属性字段中，这些属性只是用来描述一块内存的性质，是用来给 CPU 做参考的，当有实际行动在这片内存上发生时，CPU 用这些属性来检查动作的合法性，从而起到保护的作用。</p>\\n<h3>一、向段寄存器加载选择子时的保护</h3>\\n<p>当引用一个内存段时，就是往段寄存器中加载个选择子，为了避免出现非法引用内存段的情况，CPU 会做如下检查：</p>\\n<h4>1. 首先根据选择子的值验证段描述符是否超越界限</h4>\\n<p>处理器先检查选择子 TI 位的值，如果为 0，则从全局描述符表寄存器 gdtr 中拿到 GDT 基地址和 GDT 界限值。如果 TI 为 1，则从局部描述符表寄存器 ldtr 获取。</p>","autoDesc":true}');export{s as comp,c as data};

import{_ as n}from"./plugin-vue_export-helper-DlAUqK2U.js";import{c as e,a,o as i}from"./app-D1zlwylF.js";const l="/assets/%E5%87%BD%E6%95%B0%E7%9A%84%E6%A0%88%E5%B8%A7-CJnDsrxj.png",p={};function t(d,s){return i(),e("div",null,s[0]||(s[0]=[a('<h2 id="一、栈介绍" tabindex="-1"><a class="header-anchor" href="#一、栈介绍"><span>一、栈介绍</span></a></h2><p>栈保存了一个函数调用所需要的维护信息，常被称为：堆栈帧（<code>Stack Frame</code>）或活动记录。堆栈帧一般包括如下内容：</p><ul><li>函数的返回地址和参数</li><li>临时变量：包括函数的非静态局部变量以及编译器自动生成的其他临时变量</li><li>保存的上下文：包括在函数调用前后需要保持不变的寄存器</li></ul><p>esp 寄存器始终指向栈的顶部，随着函数的执行而不断变化。</p><p>ebp 寄存器指向了函数栈帧的一个固定位置。不随这个函数的执行而变化。固定不变的 ebp 可以用来定位函数活动记录中的各个数据。在 ebp 之前首先是这个函数的返回地址，他的地址是 <code>ebp-4</code>；再往前是压入栈中的参数，他们的地址视参数数量和大小而定。ebp 所直接指向的数据是调用该函数前 ebp 的值，这样在函数返回的时候，ebp 可以通过读取这个值恢复到调用前的值。</p><img src="'+l+`" style="zoom:50%;"><p>一个 <code>i386</code> 下的函数总是这样调用的：</p><ul><li>把所有或一部分参数压入栈中，如果有其他参数没有入栈，那么使用某些特定的寄存器传递</li><li>把当前指令的下一条指令的地址压入栈中</li><li>跳转到函数体执行</li></ul><h2 id="二、函数体结构" tabindex="-1"><a class="header-anchor" href="#二、函数体结构"><span>二、函数体结构</span></a></h2><p><code>i386</code> 函数体的标准开头如下：</p><ul><li><code>push ebp</code>：把 ebp 压入栈中（old ebp），为了在函数返回的时候便于恢复以前的 ebp 值</li><li><code>mov ebp, esp</code>：此时 ebp 指向栈顶，而此时栈顶就是 <code>old ebp</code></li><li>【可选】<code>sub esp, xxx</code>：在栈上分配 xxx 字节的临时空间</li><li>【可选】<code>push xxx</code>：如有必要，保存名为 xxx 寄存器（可重复多个）。之所以可能要保存一些寄存器，在于编译器可能要求某些寄存器在调用前后保持不变，那么函数就可以在调用开始时将这些寄存器的值压入栈中，在结束后再取出。</li></ul><p><code>i386</code> 函数体的结尾如下：</p><ul><li>【可选】<code>pop xxx</code>：如有必要，恢复保存过的寄存器（可重复多个）</li><li><code>mov esp, ebp</code>：恢复 esp 同时回收局部变量空间</li><li><code>pop ebp</code>：从栈中恢复保存的 ebp 的值</li><li><code>ret</code>：从栈中取得返回地址，并跳转到该位置</li></ul><p>反汇编一个函数实际看下：</p><div class="language- line-numbers-mode" data-highlighter="shiki" data-ext="" data-title="" style="--shiki-light:#24292e;--shiki-dark:#abb2bf;--shiki-light-bg:#fff;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes github-light one-dark-pro vp-code"><code><span class="line"><span>int foo() {</span></span>
<span class="line"><span>    return 123;</span></span>
<span class="line"><span>}</span></span>
<span class="line"><span></span></span>
<span class="line"><span>int main() {</span></span>
<span class="line"><span>    int n = foo();</span></span>
<span class="line"><span>    return 0;</span></span>
<span class="line"><span>}</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>进行编译并且反汇编</p><div class="language- line-numbers-mode" data-highlighter="shiki" data-ext="" data-title="" style="--shiki-light:#24292e;--shiki-dark:#abb2bf;--shiki-light-bg:#fff;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes github-light one-dark-pro vp-code"><code><span class="line"><span>gcc main.c  -m32 -O0 -o main</span></span>
<span class="line"><span>objdump -D -M intel  main &gt; main_out.s</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div></div></div><p>我们来看对应的反汇编</p><div class="language- line-numbers-mode" data-highlighter="shiki" data-ext="" data-title="" style="--shiki-light:#24292e;--shiki-dark:#abb2bf;--shiki-light-bg:#fff;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes github-light one-dark-pro vp-code"><code><span class="line"><span>0000118d &lt;foo&gt;:</span></span>
<span class="line"><span>    118d:	55                   	push   ebp</span></span>
<span class="line"><span>    118e:	89 e5                	mov    ebp,esp</span></span>
<span class="line"><span>    1190:	e8 2b 00 00 00       	call   11c0 &lt;__x86.get_pc_thunk.ax&gt;</span></span>
<span class="line"><span>    1195:	05 47 2e 00 00       	add    eax,0x2e47</span></span>
<span class="line"><span>    119a:	b8 7b 00 00 00       	mov    eax,0x7b</span></span>
<span class="line"><span>    119f:	5d                   	pop    ebp</span></span>
<span class="line"><span>    11a0:	c3                   	ret    </span></span>
<span class="line"><span></span></span>
<span class="line"><span>000011a1 &lt;main&gt;:</span></span>
<span class="line"><span>    11a1:	55                   	push   ebp</span></span>
<span class="line"><span>    11a2:	89 e5                	mov    ebp,esp</span></span>
<span class="line"><span>    11a4:	83 ec 10             	sub    esp,0x10</span></span>
<span class="line"><span>    11a7:	e8 14 00 00 00       	call   11c0 &lt;__x86.get_pc_thunk.ax&gt;</span></span>
<span class="line"><span>    11ac:	05 30 2e 00 00       	add    eax,0x2e30</span></span>
<span class="line"><span>    11b1:	e8 d7 ff ff ff       	call   118d &lt;foo&gt;</span></span>
<span class="line"><span>    11b6:	89 45 fc             	mov    DWORD PTR [ebp-0x4],eax</span></span>
<span class="line"><span>    11b9:	b8 00 00 00 00       	mov    eax,0x0</span></span>
<span class="line"><span>    11be:	c9                   	leave  </span></span>
<span class="line"><span>    11bf:	c3                   	ret    </span></span>
<span class="line"><span></span></span>
<span class="line"><span>000011c0 &lt;__x86.get_pc_thunk.ax&gt;:</span></span>
<span class="line"><span>    11c0:	8b 04 24             	mov    eax,DWORD PTR [esp]</span></span>
<span class="line"><span>    11c3:	c3                   	ret</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>在 foo 的反汇编中，我们看到</p><ul><li><code>push ebp; mov ebp, esp;</code> 这两行语句保存了旧的 ebp，并且让 ebp 指向当前的栈顶。</li><li><code>call 11c0 &lt;__x86.get_pc_thunk.ax&gt;; add eax,0x2e47</code> 这两行，call 之前会把下一条指令压栈，所以 eax 其实是拿到了 1195 这个值。所以 <code>&lt;__x86.get_pc_thunk.ax&gt;</code> 他的作用其实是获取到当前的指令位置，存储在 eax 寄存器中。</li><li>最后，<code>pop ebp; ret;</code> 这两句指令，从栈上恢复 ebp 寄存器，然后使用 ret 指令返回。</li></ul><h2 id="三、调用惯例" tabindex="-1"><a class="header-anchor" href="#三、调用惯例"><span>三、调用惯例</span></a></h2><p>函数的调用方和被调用方对于函数如何调用需要一个明确的约定，只有双方都遵守同样的约定，函数才能被正确的调用，这样的约定就称为 “调用惯例”。包括：</p><ul><li>函数参数的传递顺序和方式。调用惯例规定函数调用方将参数压栈的顺序，是从左至右，还是从右至左。有些调用惯例还允许使用寄存器传递参数，以提高性能。</li><li>栈的维护方式。在函数将参数压栈之后，函数体会被调用，此后需要被压入栈中的参数全部弹出，以使得栈在函数调用前后保持一致。这个弹出的工作可以由函数的调用方来完成，也可以由函数本身来完成。</li><li>名字修饰的策略。为了链接的时候对调用惯例进行区分，调用惯例要对函数本身的名字进行修饰。不同的调用惯例有不同的名字修饰策略。</li></ul><p><code>cdecl</code> 这个调用惯例是 C 语言默认的调用惯例。他的规则如下：</p><ul><li>参数传递：从右至左的顺序压参数入栈</li><li>出栈方：函数调用方</li><li>名字修饰：直接在函数名称前加一个下划线</li></ul><h2 id="四、函数返回值传递" tabindex="-1"><a class="header-anchor" href="#四、函数返回值传递"><span>四、函数返回值传递</span></a></h2><p>函数和调用方的交互可以使用参数传递，也可以使用返回值。如上例子中他就是使用 eax 寄存器来传递返回值。</p><ul><li>对于 4 字节的返回值，使用 eax 寄存器</li><li>对于 <code>5-8</code> 字节的返回值，一般采用 eax 和 edx 联合返回的方式，其中 eax 存储返回值的低 4 字节，而 edx 存储返回值的高 4 字节</li></ul><div class="language- line-numbers-mode" data-highlighter="shiki" data-ext="" data-title="" style="--shiki-light:#24292e;--shiki-dark:#abb2bf;--shiki-light-bg:#fff;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes github-light one-dark-pro vp-code"><code><span class="line"><span>long long int foo() {</span></span>
<span class="line"><span>    return 0x1000000020000000;</span></span>
<span class="line"><span>}</span></span>
<span class="line"><span>反汇编后：</span></span>
<span class="line"><span>0000118d &lt;foo&gt;:</span></span>
<span class="line"><span>    118d:	55                   	push   ebp</span></span>
<span class="line"><span>    118e:	89 e5                	mov    ebp,esp</span></span>
<span class="line"><span>    1190:	e8 45 00 00 00       	call   11da &lt;__x86.get_pc_thunk.ax&gt;</span></span>
<span class="line"><span>    1195:	05 47 2e 00 00       	add    eax,0x2e47</span></span>
<span class="line"><span>    119a:	b8 00 00 00 20       	mov    eax,0x20000000</span></span>
<span class="line"><span>    119f:	ba 00 00 00 10       	mov    edx,0x10000000</span></span>
<span class="line"><span>    11a4:	5d                   	pop    ebp</span></span>
<span class="line"><span>    11a5:	c3                   	ret</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><ul><li>对于大于 8 字节的返回值，</li></ul><div class="language- line-numbers-mode" data-highlighter="shiki" data-ext="" data-title="" style="--shiki-light:#24292e;--shiki-dark:#abb2bf;--shiki-light-bg:#fff;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes github-light one-dark-pro vp-code"><code><span class="line"><span>struct big_thing {</span></span>
<span class="line"><span>    char buf[128];</span></span>
<span class="line"><span>};</span></span>
<span class="line"><span></span></span>
<span class="line"><span>struct big_thing foo() {</span></span>
<span class="line"><span>    struct big_thing b;</span></span>
<span class="line"><span>    b.buf[0] = 1;</span></span>
<span class="line"><span>    return b;</span></span>
<span class="line"><span>}</span></span>
<span class="line"><span></span></span>
<span class="line"><span>int main() {</span></span>
<span class="line"><span>    struct big_thing n = foo();</span></span>
<span class="line"><span>    return 0;</span></span>
<span class="line"><span>}</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>首先 main 函数在栈上额外开辟了一片空间，并将这块空间的一部分作为传递返回值的临时对象，这里称为 temp。</p><p>然后将 temp 对象的地址作为隐藏参数传递给 foo 函数。</p><p>foo 函数将数据拷贝给 temp 对象，并将 temp 对象的地址用 eax 传出</p><p>foo 返回之后，main 函数将 eax 指向的 temp 对象的内容拷贝给 n</p><p>因此，我们发现，如果返回值类型的尺寸太大，C 语言在函数返回时会使用一个临时的栈上内存区域作为中转，结果返回值对象会被拷贝两次。因而不到万不得已，不要轻易返回大尺寸的对象。</p>`,37)]))}const o=n(p,[["render",t],["__file","1.栈与调用惯例.html.vue"]]),b=JSON.parse('{"path":"/%E6%8A%80%E6%9C%AF%E4%B8%93%E9%A2%98/%E8%BF%90%E8%A1%8C%E5%BA%93/1.%E6%A0%88%E4%B8%8E%E8%B0%83%E7%94%A8%E6%83%AF%E4%BE%8B.html","title":"1.栈与调用惯例","lang":"zh-CN","frontmatter":{"title":"1.栈与调用惯例","description":"一、栈介绍 栈保存了一个函数调用所需要的维护信息，常被称为：堆栈帧（Stack Frame）或活动记录。堆栈帧一般包括如下内容： 函数的返回地址和参数 临时变量：包括函数的非静态局部变量以及编译器自动生成的其他临时变量 保存的上下文：包括在函数调用前后需要保持不变的寄存器 esp 寄存器始终指向栈的顶部，随着函数的执行而不断变化。 ebp 寄存器指向了...","head":[["meta",{"property":"og:url","content":"https://noahyz.github.io/%E6%8A%80%E6%9C%AF%E4%B8%93%E9%A2%98/%E8%BF%90%E8%A1%8C%E5%BA%93/1.%E6%A0%88%E4%B8%8E%E8%B0%83%E7%94%A8%E6%83%AF%E4%BE%8B.html"}],["meta",{"property":"og:site_name","content":"noahyz的博客"}],["meta",{"property":"og:title","content":"1.栈与调用惯例"}],["meta",{"property":"og:description","content":"一、栈介绍 栈保存了一个函数调用所需要的维护信息，常被称为：堆栈帧（Stack Frame）或活动记录。堆栈帧一般包括如下内容： 函数的返回地址和参数 临时变量：包括函数的非静态局部变量以及编译器自动生成的其他临时变量 保存的上下文：包括在函数调用前后需要保持不变的寄存器 esp 寄存器始终指向栈的顶部，随着函数的执行而不断变化。 ebp 寄存器指向了..."}],["meta",{"property":"og:type","content":"article"}],["meta",{"property":"og:locale","content":"zh-CN"}],["meta",{"property":"article:author","content":"noahyz"}],["script",{"type":"application/ld+json"},"{\\"@context\\":\\"https://schema.org\\",\\"@type\\":\\"Article\\",\\"headline\\":\\"1.栈与调用惯例\\",\\"image\\":[\\"\\"],\\"dateModified\\":null,\\"author\\":[{\\"@type\\":\\"Person\\",\\"name\\":\\"noahyz\\",\\"url\\":\\"/about-the-author/\\"}]}"]]},"headers":[{"level":2,"title":"一、栈介绍","slug":"一、栈介绍","link":"#一、栈介绍","children":[]},{"level":2,"title":"二、函数体结构","slug":"二、函数体结构","link":"#二、函数体结构","children":[]},{"level":2,"title":"三、调用惯例","slug":"三、调用惯例","link":"#三、调用惯例","children":[]},{"level":2,"title":"四、函数返回值传递","slug":"四、函数返回值传递","link":"#四、函数返回值传递","children":[]}],"git":{},"readingTime":{"minutes":5.65,"words":1696},"filePathRelative":"技术专题/运行库/1.栈与调用惯例.md","excerpt":"<h2>一、栈介绍</h2>\\n<p>栈保存了一个函数调用所需要的维护信息，常被称为：堆栈帧（<code>Stack Frame</code>）或活动记录。堆栈帧一般包括如下内容：</p>\\n<ul>\\n<li>函数的返回地址和参数</li>\\n<li>临时变量：包括函数的非静态局部变量以及编译器自动生成的其他临时变量</li>\\n<li>保存的上下文：包括在函数调用前后需要保持不变的寄存器</li>\\n</ul>\\n<p>esp 寄存器始终指向栈的顶部，随着函数的执行而不断变化。</p>\\n<p>ebp 寄存器指向了函数栈帧的一个固定位置。不随这个函数的执行而变化。固定不变的 ebp 可以用来定位函数活动记录中的各个数据。在 ebp 之前首先是这个函数的返回地址，他的地址是 <code>ebp-4</code>；再往前是压入栈中的参数，他们的地址视参数数量和大小而定。ebp 所直接指向的数据是调用该函数前 ebp 的值，这样在函数返回的时候，ebp 可以通过读取这个值恢复到调用前的值。</p>","autoDesc":true}');export{o as comp,b as data};

import{_ as n}from"./plugin-vue_export-helper-DlAUqK2U.js";import{c as s,a as i,o as a}from"./app-D1zlwylF.js";const l={};function o(t,e){return a(),s("div",null,e[0]||(e[0]=[i(`<h2 id="一、浏览器同源政策" tabindex="-1"><a class="header-anchor" href="#一、浏览器同源政策"><span>一、浏览器同源政策</span></a></h2><p>浏览器安全的基石是“同源政策”</p><ul><li>同源是指：A 网页设置的 Cookie，B 网页不能打开，除非这两个网页同源。所谓同源指的是“三个相同“（协议相同、域名相同、端口相同）</li><li>同源的目的是为了保证用户信息的安全，防止恶意的网站窃取数据。比如：A 网站是一家银行，用户登陆以后，又去浏览其他网站。如果其他网络可以读取 A 网站的 Cookie，是一件很危险的操作</li><li>如果非同源，会有三种行为收到限制 <ol><li>Cookie、LacalStorage 和 IndexDB 无法读取</li><li>DOM 无法获得</li><li>AJAX 请求不能发送</li></ol></li></ul><p>对于 AJAX 请求只能发给同源的网址，否则就会报错。除了假设服务器代理（浏览器请求同源服务器，再由后者请求外部服务），还有如下方式避免</p><ul><li>JSONP</li><li>WebSocket</li><li>CORS：跨源资源分享（Cross-Origin Resource Sharing）的缩写。他是 W3C 标准，是跨源 AJAX 请求的根本解决方法。CORS 允许任何类型的请求</li></ul><h2 id="二、跨源资源共享-cors-详解" tabindex="-1"><a class="header-anchor" href="#二、跨源资源共享-cors-详解"><span>二、跨源资源共享 CORS 详解</span></a></h2><p>整个 CORS 通信过程，都是浏览器自动完成，不需要用户参与。对于开发者来说，CORS 通信与同源的 AJAX 通信没有差别，代码完全一样，浏览器一旦发现 AJAX 请求跨源，就会自动添加一些附加的头信息，有时还会多一次附加的请求，但用户不会有感觉。因此，实现 CORS 通信的关键是服务器。只要服务器实现了 CORS 接口，就可以跨源通信了</p><h3 id="_1-简单请求和非简单请求概念" tabindex="-1"><a class="header-anchor" href="#_1-简单请求和非简单请求概念"><span>1. 简单请求和非简单请求概念</span></a></h3><p>满足以下条件，就属于简单请求</p><ul><li>请求方法是这三种方法：HEAD、GET、POST</li><li>HTTP 的头信息不超出以下几种字段 <ul><li>Accept、Accept-Language、Content-language、Last-Event-ID</li><li>Content-Type：只限于三个值<code>application/x-www-form-urlencoded</code>、<code>multipart/form-data</code>、<code>text/plain</code></li></ul></li></ul><p>凡是不同时满足上面两个条件，就属于非简单请求。浏览器对这两种请求的处理，是不一样的</p><h3 id="_2-简单请求规避跨域问题" tabindex="-1"><a class="header-anchor" href="#_2-简单请求规避跨域问题"><span>2. 简单请求规避跨域问题</span></a></h3><p>浏览器直接发出 CORS 请求。具体来说，就是在头信息之中，增加一个 Origin 字段</p><div class="language- line-numbers-mode" data-highlighter="shiki" data-ext="" data-title="" style="--shiki-light:#24292e;--shiki-dark:#abb2bf;--shiki-light-bg:#fff;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes github-light one-dark-pro vp-code"><code><span class="line"><span>GET /cors HTTP/1.1</span></span>
<span class="line"><span>Origin: http://api.bob.com</span></span>
<span class="line"><span>Host: api.alice.com</span></span>
<span class="line"><span>Accept-Language: en-US</span></span>
<span class="line"><span>Connection: keep-alive</span></span>
<span class="line"><span>User-Agent: Mozilla/5.0...</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>上面的头信息中，<code>Origin</code>字段用来说明，本次请求来自哪个源（协议 + 域名 + 端口）。服务器根据这个值，决定是否同意这次请求。</p><p>如果<code>Origin</code>指定的源，不在许可范围内，服务器会返回一个正常的HTTP回应。浏览器发现，这个回应的头信息没有包含<code>Access-Control-Allow-Origin</code>字段，就知道出错了，从而抛出一个错误，被<code>XMLHttpRequest</code>的<code>onerror</code>回调函数捕获。注意，这种错误无法通过状态码识别，因为HTTP回应的状态码有可能是200。</p><p>如果<code>Origin</code>指定的域名在许可范围内，服务器返回的响应，会多出几个头信息字段。</p><div class="language- line-numbers-mode" data-highlighter="shiki" data-ext="" data-title="" style="--shiki-light:#24292e;--shiki-dark:#abb2bf;--shiki-light-bg:#fff;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes github-light one-dark-pro vp-code"><code><span class="line"><span>Access-Control-Allow-Origin: http://api.bob.com</span></span>
<span class="line"><span>Access-Control-Allow-Credentials: true</span></span>
<span class="line"><span>Access-Control-Expose-Headers: FooBar</span></span>
<span class="line"><span>Content-Type: text/html; charset=utf-8</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><ul><li>Access-Control-Allow-Origin：该字段是必须的，他的值要么是请求时 Origin 字段的值，要么是一个 <code>*</code>，表示接受任何域名的请求</li><li>Access-Control-Allow-Credentials：该字段可选，他的值是一个布尔值，表示是否允许发送 Cookie。默认情况下，Cookie不包括在CORS请求之中。设为<code>true</code>，即表示服务器明确许可，Cookie可以包含在请求中，一起发给服务器。这个值也只能设为<code>true</code>，如果服务器不要浏览器发送Cookie，删除该字段即可。</li><li>Access-Control-Expose-Headers：该字段可选。CORS请求时，<code>XMLHttpRequest</code>对象的<code>getResponseHeader()</code>方法只能拿到6个基本字段：<code>Cache-Control</code>、<code>Content-Language</code>、<code>Content-Type</code>、<code>Expires</code>、<code>Last-Modified</code>、<code>Pragma</code>。如果想拿到其他字段，就必须在<code>Access-Control-Expose-Headers</code>里面指定</li></ul><p>关于 Access-Control-Allow-Credentials 的说明：</p><p>要把 Cookie 发到服务器，一方面要服务器同意，指定 <code>Access-Control-Allow-Credentials: true</code> 字段。另一方面，开发者必须在 AJAX 请求中打开 withCredentials 属性，否则，即使服务器同意发送 Cookie，浏览器也不会发送。或者，服务器要求设置 Cookie，浏览器也不会处理。</p><p>需要注意的是，如果要发送Cookie，<code>Access-Control-Allow-Origin</code>就不能设为星号，必须指定明确的、与请求网页一致的域名。同时，Cookie依然遵循同源政策，只有用服务器域名设置的Cookie才会上传，其他域名的Cookie并不会上传，且（跨源）原网页代码中的<code>document.cookie</code>也无法读取服务器域名下的Cookie。</p><h3 id="_3-非简单请求规避跨域问题" tabindex="-1"><a class="header-anchor" href="#_3-非简单请求规避跨域问题"><span>3. 非简单请求规避跨域问题</span></a></h3><p>非简单请求是那种对服务器有特殊要求的请求，比如请求方法是<code>PUT</code>或<code>DELETE</code>，或者<code>Content-Type</code>字段的类型是<code>application/json</code>。非简单请求的CORS请求，会在正式通信之前，增加一次HTTP查询请求，称为&quot;预检&quot;请求（preflight）。浏览器先询问服务器，当前网页所在的域名是否在服务器的许可名单之中，以及可以使用哪些HTTP动词和头信息字段。只有得到肯定答复，浏览器才会发出正式的<code>XMLHttpRequest</code>请求，否则就报错</p><p>当浏览器发现是一个非简单请求时，会自动发出一个“预检”请求，要求服务器确认可以这样请求。如下是这个预检请求的 HTTP 头信息</p><div class="language- line-numbers-mode" data-highlighter="shiki" data-ext="" data-title="" style="--shiki-light:#24292e;--shiki-dark:#abb2bf;--shiki-light-bg:#fff;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes github-light one-dark-pro vp-code"><code><span class="line"><span>OPTIONS /cors HTTP/1.1</span></span>
<span class="line"><span>Origin: http://api.bob.com</span></span>
<span class="line"><span>Access-Control-Request-Method: PUT</span></span>
<span class="line"><span>Access-Control-Request-Headers: X-Custom-Header</span></span>
<span class="line"><span>Host: api.alice.com</span></span>
<span class="line"><span>Accept-Language: en-US</span></span>
<span class="line"><span>Connection: keep-alive</span></span>
<span class="line"><span>User-Agent: Mozilla/5.0...</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>预检请求用的请求方法是 OPTIONS，表示这个请求是用来询问的。关键字段是 Origin，表示请求来自那个源。还有如下两个关键的特殊字段</p><ul><li>Access-Control-Request-Method：该字段是必须的，用来列出浏览器的 CORS 请求会用到哪些 HTTP 方法</li><li>Access-Control-Request-Headers：该字段是一个逗号分隔的字符串，指定浏览器CORS请求会额外发送的头信息字段</li></ul><p>服务器收到预检请求以后，检查了 Origin、Access-Control-Request-Method、Access-Control-Request-Headers 字段以后，确认允许跨源请求，就可以做出回应</p><div class="language- line-numbers-mode" data-highlighter="shiki" data-ext="" data-title="" style="--shiki-light:#24292e;--shiki-dark:#abb2bf;--shiki-light-bg:#fff;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes github-light one-dark-pro vp-code"><code><span class="line"><span>HTTP/1.1 200 OK</span></span>
<span class="line"><span>Date: Mon, 01 Dec 2008 01:15:39 GMT</span></span>
<span class="line"><span>Server: Apache/2.0.61 (Unix)</span></span>
<span class="line"><span>Access-Control-Allow-Origin: http://api.bob.com</span></span>
<span class="line"><span>Access-Control-Allow-Methods: GET, POST, PUT</span></span>
<span class="line"><span>Access-Control-Allow-Headers: X-Custom-Header</span></span>
<span class="line"><span>Content-Type: text/html; charset=utf-8</span></span>
<span class="line"><span>Content-Encoding: gzip</span></span>
<span class="line"><span>Content-Length: 0</span></span>
<span class="line"><span>Keep-Alive: timeout=2, max=100</span></span>
<span class="line"><span>Connection: Keep-Alive</span></span>
<span class="line"><span>Content-Type: text/plain</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>如果服务器否定了&quot;预检&quot;请求，会返回一个正常的HTTP回应，但是没有任何CORS相关的头信息字段。这时，浏览器就会认定，服务器不同意预检请求，因此会触发一个错误。</p><ul><li>Access-Control-Allow-Origin：表示允许这个 <a href="http://api.bob.com" target="_blank" rel="noopener noreferrer">http://api.bob.com</a> 可以请求数据。设置为 <code>*</code> 表示同意任意跨源请求</li><li>Access-Control-Allow-Methods：该字段必须，它的值是逗号分隔的一个字符串，表明服务器支持的所有跨域请求的方法。注意，返回的是所有支持的方法，而不单是浏览器请求的那个方法。这是为了避免多次&quot;预检&quot;请求。</li><li>Access-Control-Allow-Headers：如果浏览器请求包括<code>Access-Control-Request-Headers</code>字段，则<code>Access-Control-Allow-Headers</code>字段是必需的。它也是一个逗号分隔的字符串，表明服务器支持的所有头信息字段，不限于浏览器在&quot;预检&quot;中请求的字段。</li><li>Access-Control-Allow-Credentials：该字段可选，他的值是一个布尔值，表示是否允许发送 Cookie</li><li>Access-Control-Max-Age：该字段可选，用来指定本次预检请求的有效期，单位为秒。上面结果中，有效期是20天（1728000秒），即允许缓存该条回应1728000秒（即20天），在此期间，不用发出另一条预检请求</li></ul><p>一旦服务器通过了&quot;预检&quot;请求，以后每次浏览器正常的CORS请求，就都跟简单请求一样，会有一个<code>Origin</code>头信息字段。服务器的回应，也都会有一个<code>Access-Control-Allow-Origin</code>头信息字段。</p>`,33)]))}const d=n(l,[["render",o],["__file","1.浏览器同源和跨域问题.html.vue"]]),r=JSON.parse('{"path":"/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E4%B8%83%E5%B1%82%E6%A8%A1%E5%9E%8B/%E5%BA%94%E7%94%A8%E5%B1%82/%E6%8A%80%E6%9C%AF%E5%8E%9F%E7%90%86/1.%E6%B5%8F%E8%A7%88%E5%99%A8%E5%90%8C%E6%BA%90%E5%92%8C%E8%B7%A8%E5%9F%9F%E9%97%AE%E9%A2%98.html","title":"1.浏览器同源和跨域问题","lang":"zh-CN","frontmatter":{"title":"1.浏览器同源和跨域问题","date":"2023-01-19T11:11:41.000Z","tags":["linux"],"description":"一、浏览器同源政策 浏览器安全的基石是“同源政策” 同源是指：A 网页设置的 Cookie，B 网页不能打开，除非这两个网页同源。所谓同源指的是“三个相同“（协议相同、域名相同、端口相同） 同源的目的是为了保证用户信息的安全，防止恶意的网站窃取数据。比如：A 网站是一家银行，用户登陆以后，又去浏览其他网站。如果其他网络可以读取 A 网站的 Cookie...","head":[["meta",{"property":"og:url","content":"https://noahyz.github.io/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E4%B8%83%E5%B1%82%E6%A8%A1%E5%9E%8B/%E5%BA%94%E7%94%A8%E5%B1%82/%E6%8A%80%E6%9C%AF%E5%8E%9F%E7%90%86/1.%E6%B5%8F%E8%A7%88%E5%99%A8%E5%90%8C%E6%BA%90%E5%92%8C%E8%B7%A8%E5%9F%9F%E9%97%AE%E9%A2%98.html"}],["meta",{"property":"og:site_name","content":"noahyz的博客"}],["meta",{"property":"og:title","content":"1.浏览器同源和跨域问题"}],["meta",{"property":"og:description","content":"一、浏览器同源政策 浏览器安全的基石是“同源政策” 同源是指：A 网页设置的 Cookie，B 网页不能打开，除非这两个网页同源。所谓同源指的是“三个相同“（协议相同、域名相同、端口相同） 同源的目的是为了保证用户信息的安全，防止恶意的网站窃取数据。比如：A 网站是一家银行，用户登陆以后，又去浏览其他网站。如果其他网络可以读取 A 网站的 Cookie..."}],["meta",{"property":"og:type","content":"article"}],["meta",{"property":"og:locale","content":"zh-CN"}],["meta",{"property":"article:author","content":"noahyz"}],["meta",{"property":"article:tag","content":"linux"}],["meta",{"property":"article:published_time","content":"2023-01-19T11:11:41.000Z"}],["script",{"type":"application/ld+json"},"{\\"@context\\":\\"https://schema.org\\",\\"@type\\":\\"Article\\",\\"headline\\":\\"1.浏览器同源和跨域问题\\",\\"image\\":[\\"\\"],\\"datePublished\\":\\"2023-01-19T11:11:41.000Z\\",\\"dateModified\\":null,\\"author\\":[{\\"@type\\":\\"Person\\",\\"name\\":\\"noahyz\\",\\"url\\":\\"/about-the-author/\\"}]}"]]},"headers":[{"level":2,"title":"一、浏览器同源政策","slug":"一、浏览器同源政策","link":"#一、浏览器同源政策","children":[]},{"level":2,"title":"二、跨源资源共享 CORS 详解","slug":"二、跨源资源共享-cors-详解","link":"#二、跨源资源共享-cors-详解","children":[{"level":3,"title":"1. 简单请求和非简单请求概念","slug":"_1-简单请求和非简单请求概念","link":"#_1-简单请求和非简单请求概念","children":[]},{"level":3,"title":"2. 简单请求规避跨域问题","slug":"_2-简单请求规避跨域问题","link":"#_2-简单请求规避跨域问题","children":[]},{"level":3,"title":"3. 非简单请求规避跨域问题","slug":"_3-非简单请求规避跨域问题","link":"#_3-非简单请求规避跨域问题","children":[]}]}],"git":{},"readingTime":{"minutes":6.97,"words":2092},"filePathRelative":"计算机网络/七层模型/应用层/技术原理/1.浏览器同源和跨域问题.md","localizedDate":"2023年1月19日","excerpt":"<h2>一、浏览器同源政策</h2>\\n<p>浏览器安全的基石是“同源政策”</p>\\n<ul>\\n<li>同源是指：A 网页设置的 Cookie，B 网页不能打开，除非这两个网页同源。所谓同源指的是“三个相同“（协议相同、域名相同、端口相同）</li>\\n<li>同源的目的是为了保证用户信息的安全，防止恶意的网站窃取数据。比如：A 网站是一家银行，用户登陆以后，又去浏览其他网站。如果其他网络可以读取 A 网站的 Cookie，是一件很危险的操作</li>\\n<li>如果非同源，会有三种行为收到限制\\n<ol>\\n<li>Cookie、LacalStorage 和 IndexDB 无法读取</li>\\n<li>DOM 无法获得</li>\\n<li>AJAX 请求不能发送</li>\\n</ol>\\n</li>\\n</ul>","autoDesc":true}');export{d as comp,r as data};

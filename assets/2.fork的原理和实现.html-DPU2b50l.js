import{_ as e}from"./plugin-vue_export-helper-DlAUqK2U.js";import{c as o,a as r,o as i}from"./app-D1zlwylF.js";const l={};function n(a,t){return i(),o("div",null,t[0]||(t[0]=[r('<h3 id="一、fork-的实现" tabindex="-1"><a class="header-anchor" href="#一、fork-的实现"><span>一、fork 的实现</span></a></h3><p>fork 利用老进程克隆出一个新进程并使新进程执行，新进程之所以能够执行，本质上是它具备程序体，这其中包括代码和数据等资源。因此 fork 就是把某个进程的全部资源复制了一份，然后让处理器的 <code>cs:eip</code> 寄存器指向新进程的指令部分。</p><p>因此 fork 要分两步，先复制进程资源，然后跳过去执行。</p><p>如下列举出我们的操作系统中进程的资源：</p><ul><li>进程的 pcb，即 task_struct</li><li>程序体，即代码段、数据段等，这是进程的实体</li><li>用户栈，编译器需要在栈中创建局部变量，并且函数调用也离不开栈</li><li>内核栈，进入内核态时，一方面要用它来保存上下文环境，另一方面的作用和用户栈一样</li><li>虚拟地址池：每个进程拥有独立的内存空间，其虚拟地址是用虚拟地址池来管理的</li><li>页表：让进程拥有独立的内存空间</li></ul>',5)]))}const c=e(l,[["render",n],["__file","2.fork的原理和实现.html.vue"]]),f=JSON.parse('{"path":"/%E6%8A%80%E6%9C%AF%E4%B8%93%E9%A2%98/%E6%89%8B%E5%86%99%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/7.%E7%B3%BB%E7%BB%9F%E4%BA%A4%E4%BA%92/2.fork%E7%9A%84%E5%8E%9F%E7%90%86%E5%92%8C%E5%AE%9E%E7%8E%B0.html","title":"fork的原理与实现","lang":"zh-CN","frontmatter":{"title":"fork的原理与实现","description":"一、fork 的实现 fork 利用老进程克隆出一个新进程并使新进程执行，新进程之所以能够执行，本质上是它具备程序体，这其中包括代码和数据等资源。因此 fork 就是把某个进程的全部资源复制了一份，然后让处理器的 cs:eip 寄存器指向新进程的指令部分。 因此 fork 要分两步，先复制进程资源，然后跳过去执行。 如下列举出我们的操作系统中进程的资源...","head":[["meta",{"property":"og:url","content":"https://noahyz.github.io/%E6%8A%80%E6%9C%AF%E4%B8%93%E9%A2%98/%E6%89%8B%E5%86%99%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/7.%E7%B3%BB%E7%BB%9F%E4%BA%A4%E4%BA%92/2.fork%E7%9A%84%E5%8E%9F%E7%90%86%E5%92%8C%E5%AE%9E%E7%8E%B0.html"}],["meta",{"property":"og:site_name","content":"noahyz的博客"}],["meta",{"property":"og:title","content":"fork的原理与实现"}],["meta",{"property":"og:description","content":"一、fork 的实现 fork 利用老进程克隆出一个新进程并使新进程执行，新进程之所以能够执行，本质上是它具备程序体，这其中包括代码和数据等资源。因此 fork 就是把某个进程的全部资源复制了一份，然后让处理器的 cs:eip 寄存器指向新进程的指令部分。 因此 fork 要分两步，先复制进程资源，然后跳过去执行。 如下列举出我们的操作系统中进程的资源..."}],["meta",{"property":"og:type","content":"article"}],["meta",{"property":"og:locale","content":"zh-CN"}],["meta",{"property":"article:author","content":"noahyz"}],["script",{"type":"application/ld+json"},"{\\"@context\\":\\"https://schema.org\\",\\"@type\\":\\"Article\\",\\"headline\\":\\"fork的原理与实现\\",\\"image\\":[\\"\\"],\\"dateModified\\":null,\\"author\\":[{\\"@type\\":\\"Person\\",\\"name\\":\\"noahyz\\",\\"url\\":\\"/about-the-author/\\"}]}"]]},"headers":[{"level":3,"title":"一、fork 的实现","slug":"一、fork-的实现","link":"#一、fork-的实现","children":[]}],"git":{},"readingTime":{"minutes":0.95,"words":284},"filePathRelative":"技术专题/手写操作系统/7.系统交互/2.fork的原理和实现.md","excerpt":"<h3>一、fork 的实现</h3>\\n<p>fork 利用老进程克隆出一个新进程并使新进程执行，新进程之所以能够执行，本质上是它具备程序体，这其中包括代码和数据等资源。因此 fork 就是把某个进程的全部资源复制了一份，然后让处理器的 <code>cs:eip</code> 寄存器指向新进程的指令部分。</p>\\n<p>因此 fork 要分两步，先复制进程资源，然后跳过去执行。</p>\\n<p>如下列举出我们的操作系统中进程的资源：</p>\\n<ul>\\n<li>进程的 pcb，即 task_struct</li>\\n<li>程序体，即代码段、数据段等，这是进程的实体</li>\\n<li>用户栈，编译器需要在栈中创建局部变量，并且函数调用也离不开栈</li>\\n<li>内核栈，进入内核态时，一方面要用它来保存上下文环境，另一方面的作用和用户栈一样</li>\\n<li>虚拟地址池：每个进程拥有独立的内存空间，其虚拟地址是用虚拟地址池来管理的</li>\\n<li>页表：让进程拥有独立的内存空间</li>\\n</ul>","autoDesc":true}');export{c as comp,f as data};

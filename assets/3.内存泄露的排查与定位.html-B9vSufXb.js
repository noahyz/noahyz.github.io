import{_ as t}from"./plugin-vue_export-helper-DlAUqK2U.js";import{c as l,a as i,o as a}from"./app-D1zlwylF.js";const n={};function o(r,e){return a(),l("div",null,e[0]||(e[0]=[i('<h2 id="内存泄露的排查与定位" tabindex="-1"><a class="header-anchor" href="#内存泄露的排查与定位"><span>内存泄露的排查与定位</span></a></h2><ul><li>栈内存由系统自动分配和管理。一旦程序运行超出了这个局部变量的作用域，栈内存就会被系统自动回收，所以不会产生内存泄露的问题</li><li>堆内存由应用程序自己来分配和管理。除非程序退出，这些堆内存并不会被系统自动释放，而是需要应用程序明确调用库函数 free 来释放他们。如果程序没有正确释放堆内存，就会造成内存泄露</li><li>只读段，包括程序的代码和常量，由于是只读的，不会再去分配新的内存，所以也不会产生内存泄漏</li><li>数据段，包括全局变量和静态变量，这些变量在定义时就已经确定了大小，所以也不会产生内存泄漏</li><li>最后一个内存映射段，包括动态链接库和共享内存，其中共享内存由程序动态分配和管理。所以，如果程序在分配后忘了回收，就会导致跟堆内存类似的泄漏问题</li></ul><p>内存泄漏的危害非常大，这些忘记释放的内存，不仅应用程序自己不能访问，系统也不能把它们再次分配给其他应用。内存泄漏不断累积，甚至会耗尽系统内存。</p><p>虽然，系统最终可以通过 OOM （Out of Memory）机制杀死进程，但进程在 OOM 前，可能已经引发了一连串的反应，导致严重的性能问题；比如，其他需要内存的进程，可能无法分配新的内存；内存不足，又会触发系统的缓存回收以及 SWAP 机制，从而进一步导致 I/O 的性能问题等等。如下详细的说明：</p><p>当进程发生内存泄漏导致OOM（Out of Memory）时，内核会尝试杀死一些进程以释放内存。在被杀死之前，OOM进程会尝试使用系统资源来满足其内存需求，这可能会导致系统整体变慢，直至崩溃。具体来说，以下是可能导致系统变卡的原因：</p><ol><li><p>系统交换</p><p>当系统内存不足时，内核会尝试将一些不常用的内存页面移到交换分区中，以腾出物理内存。但是，交换分区通常比物理内存慢得多，因此如果内存压力持续较长时间，交换操作可能会导致系统整体变慢</p></li><li><p>I/O阻塞</p><p>当系统内存不足时，内核可能会开始进行页面回收，即将不活跃的内存页面写回到磁盘上，以腾出物理内存。这可能导致系统磁盘I/O负载增加，进而导致磁盘I/O阻塞。如果磁盘I/O阻塞过长时间，可能会导致系统整体变慢。</p></li><li><p>CPU利用率上升</p><p>当内存压力较大时，内核可能会频繁地进行页面回收和交换操作，这可能导致CPU利用率上升。同时，当进程使用过多的内存时，可能会导致进程频繁地进行内存分配和释放操作，这也可能导致CPU利用率上升。如果CPU利用率过高，可能会导致系统整体变慢。</p></li><li><p>内存分配器性能下降</p><p>当进程频繁地进行内存分配和释放操作时，可能会导致内存分配器出现性能问题。如果内存分配器的性能下降，可能会导致进程内部的性能下降，从而影响系统整体性能。</p></li></ol><p>综上所述，当进程发生内存泄漏导致OOM时，系统整体变卡的原因是多方面的，包括系统交换、I/O阻塞、CPU利用率上升以及内存分配器性能下降等。</p><h3 id="一、场景" tabindex="-1"><a class="header-anchor" href="#一、场景"><span>一、场景</span></a></h3><p>memleak 是 bcc 软件包中的一个工具。另一个用的比较多的是valgrind。</p>',9)]))}const c=t(n,[["render",o],["__file","3.内存泄露的排查与定位.html.vue"]]),h=JSON.parse('{"path":"/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/%E5%B7%A5%E5%85%B7%E8%BF%90%E7%BB%B4/3.%E5%86%85%E5%AD%98%E6%B3%84%E9%9C%B2%E7%9A%84%E6%8E%92%E6%9F%A5%E4%B8%8E%E5%AE%9A%E4%BD%8D.html","title":"3.内存泄露的排查与定位","lang":"zh-CN","frontmatter":{"title":"3.内存泄露的排查与定位","date":"2023-01-19T11:11:41.000Z","tags":["linux"],"description":"内存泄露的排查与定位 栈内存由系统自动分配和管理。一旦程序运行超出了这个局部变量的作用域，栈内存就会被系统自动回收，所以不会产生内存泄露的问题 堆内存由应用程序自己来分配和管理。除非程序退出，这些堆内存并不会被系统自动释放，而是需要应用程序明确调用库函数 free 来释放他们。如果程序没有正确释放堆内存，就会造成内存泄露 只读段，包括程序的代码和常量，...","head":[["meta",{"property":"og:url","content":"https://noahyz.github.io/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/%E5%B7%A5%E5%85%B7%E8%BF%90%E7%BB%B4/3.%E5%86%85%E5%AD%98%E6%B3%84%E9%9C%B2%E7%9A%84%E6%8E%92%E6%9F%A5%E4%B8%8E%E5%AE%9A%E4%BD%8D.html"}],["meta",{"property":"og:site_name","content":"noahyz的博客"}],["meta",{"property":"og:title","content":"3.内存泄露的排查与定位"}],["meta",{"property":"og:description","content":"内存泄露的排查与定位 栈内存由系统自动分配和管理。一旦程序运行超出了这个局部变量的作用域，栈内存就会被系统自动回收，所以不会产生内存泄露的问题 堆内存由应用程序自己来分配和管理。除非程序退出，这些堆内存并不会被系统自动释放，而是需要应用程序明确调用库函数 free 来释放他们。如果程序没有正确释放堆内存，就会造成内存泄露 只读段，包括程序的代码和常量，..."}],["meta",{"property":"og:type","content":"article"}],["meta",{"property":"og:locale","content":"zh-CN"}],["meta",{"property":"article:author","content":"noahyz"}],["meta",{"property":"article:tag","content":"linux"}],["meta",{"property":"article:published_time","content":"2023-01-19T11:11:41.000Z"}],["script",{"type":"application/ld+json"},"{\\"@context\\":\\"https://schema.org\\",\\"@type\\":\\"Article\\",\\"headline\\":\\"3.内存泄露的排查与定位\\",\\"image\\":[\\"\\"],\\"datePublished\\":\\"2023-01-19T11:11:41.000Z\\",\\"dateModified\\":null,\\"author\\":[{\\"@type\\":\\"Person\\",\\"name\\":\\"noahyz\\",\\"url\\":\\"/about-the-author/\\"}]}"]]},"headers":[{"level":2,"title":"内存泄露的排查与定位","slug":"内存泄露的排查与定位","link":"#内存泄露的排查与定位","children":[{"level":3,"title":"一、场景","slug":"一、场景","link":"#一、场景","children":[]}]}],"git":{},"readingTime":{"minutes":3.46,"words":1037},"filePathRelative":"操作系统/内存管理/工具运维/3.内存泄露的排查与定位.md","localizedDate":"2023年1月19日","excerpt":"<h2>内存泄露的排查与定位</h2>\\n<ul>\\n<li>栈内存由系统自动分配和管理。一旦程序运行超出了这个局部变量的作用域，栈内存就会被系统自动回收，所以不会产生内存泄露的问题</li>\\n<li>堆内存由应用程序自己来分配和管理。除非程序退出，这些堆内存并不会被系统自动释放，而是需要应用程序明确调用库函数 free 来释放他们。如果程序没有正确释放堆内存，就会造成内存泄露</li>\\n<li>只读段，包括程序的代码和常量，由于是只读的，不会再去分配新的内存，所以也不会产生内存泄漏</li>\\n<li>数据段，包括全局变量和静态变量，这些变量在定义时就已经确定了大小，所以也不会产生内存泄漏</li>\\n<li>最后一个内存映射段，包括动态链接库和共享内存，其中共享内存由程序动态分配和管理。所以，如果程序在分配后忘了回收，就会导致跟堆内存类似的泄漏问题</li>\\n</ul>","autoDesc":true}');export{c as comp,h as data};

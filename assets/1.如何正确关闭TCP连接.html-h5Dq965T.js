import{_ as o}from"./plugin-vue_export-helper-DlAUqK2U.js";import{c,a as t,o as d}from"./app-D1zlwylF.js";const n={};function s(l,e){return d(),c("div",null,e[0]||(e[0]=[t('<h3 id="一、问题" tabindex="-1"><a class="header-anchor" href="#一、问题"><span>一、问题</span></a></h3><p>在使用 TCP 网络编程时，比如 send/write 调用成功后，调用 close 关闭 socket。这种场景中有可能出现，发送的数据，传输到对端不完整。</p><h3 id="二、原因" tabindex="-1"><a class="header-anchor" href="#二、原因"><span>二、原因</span></a></h3><p><code>send()</code> 成功返回只意味着内核接收了数据，并准备在某个特定的时间发送他们。内核在接收到数据后，还要把数据包发送到网卡等等一系列过程之后，最终数据才能到达对端主机。对端主机的内核收到数据后，然后拥有对应 socket 的进程从中读取数据。此时，数据才算是真正的完成了传输。</p><p>当调用 <code>close()</code> 关闭 socket 的时候，整个 TCP 连接也随之关闭。但此时可能还有数据在内核的发送缓冲区中，或者已经发送但未被确认。发送方如果 <code>send()</code> 后立即进行 <code>close()</code>，就可能出现数据其实还未发送的情况。</p><p>设置 socket 选项 <code>SO_LINGER</code> 会尝试将残留在内核发送缓冲区的数据发送给对方，这种看似解决了问题，但有时依然会出现数据发送不全的问题。</p><p>原因在于，发送方执行 <code>close()</code> 的时候，如果他的接收缓冲区中仍有数据没有读取，或者调用 <code>close()</code> 后有新的数据到达，这时他会发送一个 RST 报文告知对方数据丢失，没有正常使用 FIN 四次挥手断开连接，因此设置 <code>SO_LINGER</code> 没有效果。</p><h3 id="三、解决" tabindex="-1"><a class="header-anchor" href="#三、解决"><span>三、解决</span></a></h3><p>那么如果发送方先读取了自己接收缓冲区的数据，再进行 <code>close()</code>，此时问题也不会得到解决。</p><p>需要借助 <code>shutdown()</code>，<code>shutdown()</code> 会发送一个 FIN 给对方，告知对方我即将关闭 socket。此时可以通过 <code>recv()</code> 返回 0（收到 EOF）检测到接收端的关闭。</p><p>因此，正确的关闭逻辑应该是：</p><ul><li>发送方进行 <code>send()</code> 完成之后，然后调用 <code>shutdown()</code> 关闭 socket 的写。然后通过检测 <code>recv()</code> 返回 0（也即由于接收方 close 导致）。最后再去 close</li><li>接收方，通过判断 <code>recv() </code> 返回值为 0（由于发送方 shutdown 导致），然后写完自己还需要写的数据，最后 close 掉</li></ul><p>注意，如果遇到恶意的或错误的 client，永远不 <code>close()</code>，则服务器 <code>recv()</code> 将不会返回 0（阻塞且 <code>errno == EAGAIN</code>），因此需要加一个超时控制，若 <code>shutdown(WR)</code> 若干秒后 <code>recv()</code> 未返回 0，则直接 <code>close()</code> 强制关闭此连接。</p><p>即使如此，<code>shutdown()</code> 也不能保证接收方接受到所有数据，这只是发送方能做到的最大努力。最好的办法还是像 HTTP 协议那样，附有消息的长度信息，这就需要有能力自己设计协议。</p><p>还有一种方法，Linux 记录了未确认数据的数量，可以使用<code>ioctl</code>的<code>SIOCOUTQ</code>选项查询，如果这个数字达到 0，我们至少可以确认所有的发送数据到达了远程操作系统，只是只能在 Linux 平台下实现。</p>',15)]))}const p=o(n,[["render",s],["__file","1.如何正确关闭TCP连接.html.vue"]]),E=JSON.parse('{"path":"/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E4%B8%83%E5%B1%82%E6%A8%A1%E5%9E%8B/%E4%BC%A0%E8%BE%93%E5%B1%82/%E7%BC%96%E7%A8%8B%E8%B0%83%E8%AF%95/1.%E5%A6%82%E4%BD%95%E6%AD%A3%E7%A1%AE%E5%85%B3%E9%97%ADTCP%E8%BF%9E%E6%8E%A5.html","title":"1.如何正确关闭TCP连接","lang":"zh-CN","frontmatter":{"title":"1.如何正确关闭TCP连接","description":"一、问题 在使用 TCP 网络编程时，比如 send/write 调用成功后，调用 close 关闭 socket。这种场景中有可能出现，发送的数据，传输到对端不完整。 二、原因 send() 成功返回只意味着内核接收了数据，并准备在某个特定的时间发送他们。内核在接收到数据后，还要把数据包发送到网卡等等一系列过程之后，最终数据才能到达对端主机。对端主机...","head":[["meta",{"property":"og:url","content":"https://noahyz.github.io/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E4%B8%83%E5%B1%82%E6%A8%A1%E5%9E%8B/%E4%BC%A0%E8%BE%93%E5%B1%82/%E7%BC%96%E7%A8%8B%E8%B0%83%E8%AF%95/1.%E5%A6%82%E4%BD%95%E6%AD%A3%E7%A1%AE%E5%85%B3%E9%97%ADTCP%E8%BF%9E%E6%8E%A5.html"}],["meta",{"property":"og:site_name","content":"noahyz的博客"}],["meta",{"property":"og:title","content":"1.如何正确关闭TCP连接"}],["meta",{"property":"og:description","content":"一、问题 在使用 TCP 网络编程时，比如 send/write 调用成功后，调用 close 关闭 socket。这种场景中有可能出现，发送的数据，传输到对端不完整。 二、原因 send() 成功返回只意味着内核接收了数据，并准备在某个特定的时间发送他们。内核在接收到数据后，还要把数据包发送到网卡等等一系列过程之后，最终数据才能到达对端主机。对端主机..."}],["meta",{"property":"og:type","content":"article"}],["meta",{"property":"og:locale","content":"zh-CN"}],["meta",{"property":"article:author","content":"noahyz"}],["script",{"type":"application/ld+json"},"{\\"@context\\":\\"https://schema.org\\",\\"@type\\":\\"Article\\",\\"headline\\":\\"1.如何正确关闭TCP连接\\",\\"image\\":[\\"\\"],\\"dateModified\\":null,\\"author\\":[{\\"@type\\":\\"Person\\",\\"name\\":\\"noahyz\\",\\"url\\":\\"/about-the-author/\\"}]}"]]},"headers":[{"level":3,"title":"一、问题","slug":"一、问题","link":"#一、问题","children":[]},{"level":3,"title":"二、原因","slug":"二、原因","link":"#二、原因","children":[]},{"level":3,"title":"三、解决","slug":"三、解决","link":"#三、解决","children":[]}],"git":{},"readingTime":{"minutes":2.63,"words":788},"filePathRelative":"计算机网络/七层模型/传输层/编程调试/1.如何正确关闭TCP连接.md","excerpt":"<h3>一、问题</h3>\\n<p>在使用 TCP 网络编程时，比如 send/write 调用成功后，调用 close 关闭 socket。这种场景中有可能出现，发送的数据，传输到对端不完整。</p>\\n<h3>二、原因</h3>\\n<p><code>send()</code> 成功返回只意味着内核接收了数据，并准备在某个特定的时间发送他们。内核在接收到数据后，还要把数据包发送到网卡等等一系列过程之后，最终数据才能到达对端主机。对端主机的内核收到数据后，然后拥有对应 socket 的进程从中读取数据。此时，数据才算是真正的完成了传输。</p>\\n<p>当调用 <code>close()</code> 关闭 socket 的时候，整个 TCP 连接也随之关闭。但此时可能还有数据在内核的发送缓冲区中，或者已经发送但未被确认。发送方如果 <code>send()</code> 后立即进行 <code>close()</code>，就可能出现数据其实还未发送的情况。</p>","autoDesc":true}');export{p as comp,E as data};

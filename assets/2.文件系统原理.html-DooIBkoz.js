import{_ as e}from"./plugin-vue_export-helper-DlAUqK2U.js";import{c as o,a as n,o as t}from"./app-D1zlwylF.js";const l="/assets/inode%E8%8A%82%E7%82%B9%E7%BB%93%E6%9E%84-D0tS4eB3.png",p="/assets/inode%E4%B8%8E%E7%9B%AE%E5%BD%95%E9%A1%B9%E7%9A%84%E5%85%B3%E7%B3%BB-qiLd1mCu.png",a="/assets/%E8%B6%85%E7%BA%A7%E5%9D%97%E9%80%BB%E8%BE%91%E7%BB%93%E6%9E%84-C8sf2Btg.png",d="/assets/%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F%E5%B8%83%E5%B1%80-9mYsEc_B.png",E={};function s(B,i){return t(),o("div",null,i[0]||(i[0]=[n('<h4 id="_1-inode" tabindex="-1"><a class="header-anchor" href="#_1-inode"><span>1. inode</span></a></h4><ul><li>硬盘的读写单位是扇区。</li><li>文件系统的读写单位是“块”，一个块是由多个扇区组成。</li><li>文件系统中的文件至少要占据一个块，当文件体积大于一个块时，文件会被拆分成多个块。</li></ul><p>因此我们需要将“块”组织起来。</p><p>unix 文件系统将文件以“索引结构”进行组织</p><ul><li>优点：文件中的块依然可以分散到不连续的零散空间中，保证磁盘高利用率</li><li>优点：文件系统为每个文件的所有块建立了一个索引表，索引表就是块地址数组，每个数组元素就是块的地址，数组元素下标就是文件块的索引，这样访问任意一个块的时候，只要从索引表中获得块地址就可以</li></ul><p>这种索引结构就是 inode（index node），用来索引、跟踪一个文件的所有块。因此 UNIX 文件系统中，一个文件对应一个 inode。</p><p>索引结构的缺点：索引表本身要占用一定的存储空间，文件越大，块就越多，索引表项就越多。</p><p>UNIX 采用的办法：将一部分块放在索引表中，如果文件很大，将其他块放在另一个索引表。具体做法：</p><ul><li>每个索引表中共 15 个索引项，暂时称此索引表为老索引表。老索引表中前 12 个索引项时文件的前 12 个块的地址，他们是文件的“直接块”，即可直接获得地址的块。</li><li>如果文件大于 12 个块，那就再建立个新的块索引表，新索引表称为一级间接块索引表，表中可容纳 256 个块的地址。这 256 个块地址需要通过一级间接块索引表才能获取，因此称为“间接块”。此时文件最大可达到 <code>12+256=268</code> 个块</li><li>如果还不够大，那就建立二级间接块索引表，在老索引表中的第 14 个索引项存储二级间接索引表所在块的地址。此表中各表项存储的是一级间接块索引表。此时文件最大可达 <code>12+256+256*256=65804</code> 个块</li><li>还不够的话，建立三级间接块索引表，在老索引表中的第 15 个索引项存储三级间接块索引表所在块的地址。表中存储的是二级间接块索引表，然后这些二级间接块索引表中建立一级间接块索引表。此时文件最大可达：<code>12+256+256*256+256*256*256=16843020</code> 个块。</li></ul><img src="'+l+'" alt="s" style="zoom:50%;"><p>同时，inode 结构中，包括了一个文件的所有信息：</p><ul><li>i 结点编号是指此 inode 的序号，通常是指他在 inode 数组中的下标</li><li>权限是读、写、执行</li><li>属主是指文件的拥有者</li><li>时间是指创建时间、修改时间、访问时间</li><li>文件大小是指文件的字节尺寸</li><li>连续的各种块指针以及索引表指针是文件所有块的索引，也就是指向文件的实体部分</li></ul><p>总结：inode 是文件在文件系统上的元信息（文件本身的元信息是他自己的文件头），要想通过文件系统获得文件的实体，必须先要找到文件的 inode。inode 的数量等于文件的数量，硬盘分区中所有文件的 inode 通过名为 inode_table 数组表示，此数组元素的下标便是文件 inode 的编号。</p><p>文件的数量间接决定了分区空间的利用率。说“间接”，是因为文件大小不一。于是一个分区的利用率分为 inode 的利用率和磁盘空间利用率两种，<code>df -i</code> 可以查看 inode 利用率，df 不带参数可查看空间利用率。</p><h4 id="_2-目录" tabindex="-1"><a class="header-anchor" href="#_2-目录"><span>2. 目录</span></a></h4><p>在 Linux 中，目录和文件都用 inode 表示，目录也是文件。inode 结构相同，因此区分该 inode 是普通文件还是目录文件，唯一的地方只能是数据块本身的内容，即数据块的内容要么是普通文件本身的数据，要么是目录中的目录项。</p><p>目录项中包含文件名、inode 编号和文件类型等等。有如下作用：</p><ul><li>标识此 inode 表示的是文件是目录，还是普通文件，也就是 inode 所指向的数据块中的内容是什么</li><li>将文件名与 inode 做个绑定关联，这样用户便可以通过文件名来找到文件的实体数据</li></ul><p>因此，通过文件名找文件实体数据块的流程是：</p><ul><li>在目录中找到文件名所在的目录项</li><li>从目录项中获取 inode 编号</li><li>用 inode 编号作为 inode 数组的索引下标，找到 inode</li><li>从该 inode 中获取数据块的地址，读取数据块</li></ul><p>每个分区都有自己的根目录，创建文件系统之后他的位置就是固定不变的。查找任意文件时，都直接到根目录的数据块中找相关的目录项，然后递归查找，最终可以找到任意子目录中的文件。</p><img src="'+p+'" style="zoom:50%;"><h4 id="_3-超级块与文件系统布局" tabindex="-1"><a class="header-anchor" href="#_3-超级块与文件系统布局"><span>3. 超级块与文件系统布局</span></a></h4><p>上文留下了几个问题，比如：</p><ul><li>inode 数组存储在哪里？大小是多少？</li><li>每个分区都有自己的根目录，但是他的地址在哪里？</li></ul><p>针对这些元信息的存储问题，又引入了“超级块”。超级块中会保存：inode 数组的地址以及大小、inode 位图地址以及大小（用来管理 inode 的使用情况）、根目录的地址以及大小、空闲块位图的地址以及大小。</p><img src="'+a+'" style="zoom:50%;"><p>魔数通常用来确定文件系统的类型标志，然后调用不同的文件系统驱动程序访问该分区。</p><p>超级块的位置和大小是固定的，存储在各分区的第 2 个扇区，通常是占用一个扇区大小，具体大小与实际文件系统类型为准。</p><p>现在我们就清楚了我们整个文件系统的布局了，也是参考了 ext2 文件系统。</p><img src="'+d+'" style="zoom:50%;"><p>操作系统引导块：操作系统引导记录 OBR 所在的地址，即操作系统引导扇区。他位于各分区最开始的扇区。根据文件系统类型的不同，引导程序可能占用多个扇区，这多个扇区组成一个数据块</p>',32)]))}const m=e(E,[["render",s],["__file","2.文件系统原理.html.vue"]]),h=JSON.parse('{"path":"/%E6%8A%80%E6%9C%AF%E4%B8%93%E9%A2%98/%E6%89%8B%E5%86%99%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/6.%E7%A1%AC%E7%9B%98/2.%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F%E5%8E%9F%E7%90%86.html","title":"文件系统原理","lang":"zh-CN","frontmatter":{"title":"文件系统原理","description":"1. inode 硬盘的读写单位是扇区。 文件系统的读写单位是“块”，一个块是由多个扇区组成。 文件系统中的文件至少要占据一个块，当文件体积大于一个块时，文件会被拆分成多个块。 因此我们需要将“块”组织起来。 unix 文件系统将文件以“索引结构”进行组织 优点：文件中的块依然可以分散到不连续的零散空间中，保证磁盘高利用率 优点：文件系统为每个文件的所...","head":[["meta",{"property":"og:url","content":"https://noahyz.github.io/%E6%8A%80%E6%9C%AF%E4%B8%93%E9%A2%98/%E6%89%8B%E5%86%99%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/6.%E7%A1%AC%E7%9B%98/2.%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F%E5%8E%9F%E7%90%86.html"}],["meta",{"property":"og:site_name","content":"noahyz的博客"}],["meta",{"property":"og:title","content":"文件系统原理"}],["meta",{"property":"og:description","content":"1. inode 硬盘的读写单位是扇区。 文件系统的读写单位是“块”，一个块是由多个扇区组成。 文件系统中的文件至少要占据一个块，当文件体积大于一个块时，文件会被拆分成多个块。 因此我们需要将“块”组织起来。 unix 文件系统将文件以“索引结构”进行组织 优点：文件中的块依然可以分散到不连续的零散空间中，保证磁盘高利用率 优点：文件系统为每个文件的所..."}],["meta",{"property":"og:type","content":"article"}],["meta",{"property":"og:locale","content":"zh-CN"}],["meta",{"property":"article:author","content":"noahyz"}],["script",{"type":"application/ld+json"},"{\\"@context\\":\\"https://schema.org\\",\\"@type\\":\\"Article\\",\\"headline\\":\\"文件系统原理\\",\\"image\\":[\\"\\"],\\"dateModified\\":null,\\"author\\":[{\\"@type\\":\\"Person\\",\\"name\\":\\"noahyz\\",\\"url\\":\\"/about-the-author/\\"}]}"]]},"headers":[],"git":{},"readingTime":{"minutes":5.7,"words":1709},"filePathRelative":"技术专题/手写操作系统/6.硬盘/2.文件系统原理.md","excerpt":"<h4>1. inode</h4>\\n<ul>\\n<li>硬盘的读写单位是扇区。</li>\\n<li>文件系统的读写单位是“块”，一个块是由多个扇区组成。</li>\\n<li>文件系统中的文件至少要占据一个块，当文件体积大于一个块时，文件会被拆分成多个块。</li>\\n</ul>\\n<p>因此我们需要将“块”组织起来。</p>\\n<p>unix 文件系统将文件以“索引结构”进行组织</p>\\n<ul>\\n<li>优点：文件中的块依然可以分散到不连续的零散空间中，保证磁盘高利用率</li>\\n<li>优点：文件系统为每个文件的所有块建立了一个索引表，索引表就是块地址数组，每个数组元素就是块的地址，数组元素下标就是文件块的索引，这样访问任意一个块的时候，只要从索引表中获得块地址就可以</li>\\n</ul>","autoDesc":true}');export{m as comp,h as data};

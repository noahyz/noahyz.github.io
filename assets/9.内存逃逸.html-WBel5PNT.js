import{_ as s}from"./plugin-vue_export-helper-DlAUqK2U.js";import{c as a,a as n,o as l}from"./app-D1zlwylF.js";const t={};function h(e,i){return l(),a("div",null,i[0]||(i[0]=[n(`<h2 id="go语言的内存逃逸" tabindex="-1"><a class="header-anchor" href="#go语言的内存逃逸"><span>Go语言的内存逃逸</span></a></h2><p>Golang 程序变量会携带一组校验数据，用来证明他的整个生命周期是否在运行时完全可知。如果变量通过了这些校验，他就可以在栈上分配。否则就说它逃逸了，必须在堆上分配。</p><h3 id="一、引起变量逃逸到堆上的典型情况" tabindex="-1"><a class="header-anchor" href="#一、引起变量逃逸到堆上的典型情况"><span>一、引起变量逃逸到堆上的典型情况</span></a></h3><ul><li><strong>在方法内把局部变量指针返回</strong>，局部变量原本应该在栈中分配，在栈中回收。但是由于返回时被外部引用，因此其生命周期大于栈，则溢出。</li><li><strong>发送指针或带有指针的值到 channel 中。</strong> 在编译时，是没有办法知道哪个 goroutine 会在 channel 上接收数据。所以编译器没法知道变量什么时候才会被释放。</li><li><strong>在一个切片上存储指针或带指针的值。</strong> 一个典型的例子就是 []*string 。这会导致切片的内容逃逸。尽管其后面的数组可能是在栈上分配的，但其引用的值一定是在堆上。</li><li><strong>slice 的背后数组被重新分配了，因为 append 时可能会超出其容量( cap )。</strong> slice 初始化的地方在编译时是可以知道的，它最开始会在栈上分配。如果切片背后的存储要基于运行时的数据进行扩充，就会在堆上分配。</li><li><strong>在 interface 类型上调用方法。</strong> 在 interface 类型上调用方法都是动态调度的 —— 方法的真正实现只能在运行时知道。想像一个 io.Reader 类型的变量 r , 调用 r.Read(b) 会使得 r 的值和切片b 的背后存储都逃逸掉，所以会在堆上分配。</li></ul><h3 id="二、查询逃逸情况" tabindex="-1"><a class="header-anchor" href="#二、查询逃逸情况"><span>二、查询逃逸情况</span></a></h3><div class="language-go line-numbers-mode" data-highlighter="shiki" data-ext="go" data-title="go" style="--shiki-light:#24292e;--shiki-dark:#abb2bf;--shiki-light-bg:#fff;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes github-light one-dark-pro vp-code"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#C678DD;">package</span><span style="--shiki-light:#6F42C1;--shiki-dark:#E5C07B;"> main</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#C678DD;">import</span><span style="--shiki-light:#032F62;--shiki-dark:#98C379;"> &quot;</span><span style="--shiki-light:#6F42C1;--shiki-dark:#98C379;">fmt</span><span style="--shiki-light:#032F62;--shiki-dark:#98C379;">&quot;</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#C678DD;">type</span><span style="--shiki-light:#6F42C1;--shiki-dark:#E5C07B;"> A</span><span style="--shiki-light:#D73A49;--shiki-dark:#C678DD;"> struct</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;"> {</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E06C75;">    s</span><span style="--shiki-light:#D73A49;--shiki-dark:#C678DD;"> string</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">}</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#7F848E;--shiki-light-font-style:inherit;--shiki-dark-font-style:italic;">// 这是上面提到的 &quot;在方法内把局部变量指针返回&quot; 的情况</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#C678DD;">func</span><span style="--shiki-light:#6F42C1;--shiki-dark:#61AFEF;"> foo</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">(</span><span style="--shiki-light:#E36209;--shiki-dark:#E06C75;--shiki-light-font-style:inherit;--shiki-dark-font-style:italic;">s</span><span style="--shiki-light:#D73A49;--shiki-dark:#C678DD;"> string</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">) </span><span style="--shiki-light:#D73A49;--shiki-dark:#C678DD;">*</span><span style="--shiki-light:#6F42C1;--shiki-dark:#E5C07B;">A</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;"> {</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E06C75;">    a</span><span style="--shiki-light:#D73A49;--shiki-dark:#E5C07B;"> :=</span><span style="--shiki-light:#6F42C1;--shiki-dark:#61AFEF;"> new</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">(</span><span style="--shiki-light:#6F42C1;--shiki-dark:#E5C07B;">A</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">)</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E06C75;">    a</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">.</span><span style="--shiki-light:#24292E;--shiki-dark:#E06C75;">s</span><span style="--shiki-light:#D73A49;--shiki-dark:#E5C07B;"> =</span><span style="--shiki-light:#24292E;--shiki-dark:#E06C75;"> s</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#C678DD;">    return</span><span style="--shiki-light:#24292E;--shiki-dark:#E06C75;"> a</span><span style="--shiki-light:#6A737D;--shiki-dark:#7F848E;--shiki-light-font-style:inherit;--shiki-dark-font-style:italic;"> //返回局部变量a,在C语言中妥妥野指针，但在go则ok，但a会逃逸到堆</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">}</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#C678DD;">func</span><span style="--shiki-light:#6F42C1;--shiki-dark:#61AFEF;"> main</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">() {</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E06C75;">    a</span><span style="--shiki-light:#D73A49;--shiki-dark:#E5C07B;"> :=</span><span style="--shiki-light:#6F42C1;--shiki-dark:#61AFEF;"> foo</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#98C379;">&quot;hello&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">)</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E06C75;">    b</span><span style="--shiki-light:#D73A49;--shiki-dark:#E5C07B;"> :=</span><span style="--shiki-light:#24292E;--shiki-dark:#E06C75;"> a</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">.</span><span style="--shiki-light:#24292E;--shiki-dark:#E06C75;">s</span><span style="--shiki-light:#D73A49;--shiki-dark:#C678DD;"> +</span><span style="--shiki-light:#032F62;--shiki-dark:#98C379;"> &quot; world&quot;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E06C75;">    c</span><span style="--shiki-light:#D73A49;--shiki-dark:#E5C07B;"> :=</span><span style="--shiki-light:#24292E;--shiki-dark:#E06C75;"> b</span><span style="--shiki-light:#D73A49;--shiki-dark:#C678DD;"> +</span><span style="--shiki-light:#032F62;--shiki-dark:#98C379;"> &quot;!&quot;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E06C75;">    fmt</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#61AFEF;">Println</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">(</span><span style="--shiki-light:#24292E;--shiki-dark:#E06C75;">c</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">)</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">}</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><div class="language-shell line-numbers-mode" data-highlighter="shiki" data-ext="shell" data-title="shell" style="--shiki-light:#24292e;--shiki-dark:#abb2bf;--shiki-light-bg:#fff;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes github-light one-dark-pro vp-code"><code><span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#61AFEF;">zhangyi@NOAHYZHANG-MB0</span><span style="--shiki-light:#032F62;--shiki-dark:#98C379;"> test24</span><span style="--shiki-light:#032F62;--shiki-dark:#98C379;"> %</span><span style="--shiki-light:#032F62;--shiki-dark:#98C379;"> go</span><span style="--shiki-light:#032F62;--shiki-dark:#98C379;"> build</span><span style="--shiki-light:#005CC5;--shiki-dark:#D19A66;"> -gcflags=-m</span><span style="--shiki-light:#032F62;--shiki-dark:#98C379;"> main.go</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;"> </span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#7F848E;--shiki-light-font-style:inherit;--shiki-dark-font-style:italic;"># command-line-arguments</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#61AFEF;">./main.go:9:6:</span><span style="--shiki-light:#032F62;--shiki-dark:#98C379;"> can</span><span style="--shiki-light:#032F62;--shiki-dark:#98C379;"> inline</span><span style="--shiki-light:#032F62;--shiki-dark:#98C379;"> foo</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#61AFEF;">./main.go:15:13:</span><span style="--shiki-light:#032F62;--shiki-dark:#98C379;"> inlining</span><span style="--shiki-light:#032F62;--shiki-dark:#98C379;"> call</span><span style="--shiki-light:#032F62;--shiki-dark:#98C379;"> to</span><span style="--shiki-light:#032F62;--shiki-dark:#98C379;"> foo</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#61AFEF;">./main.go:18:16:</span><span style="--shiki-light:#032F62;--shiki-dark:#98C379;"> inlining</span><span style="--shiki-light:#032F62;--shiki-dark:#98C379;"> call</span><span style="--shiki-light:#032F62;--shiki-dark:#98C379;"> to</span><span style="--shiki-light:#032F62;--shiki-dark:#98C379;"> fmt.Println</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#61AFEF;">./main.go:9:10:</span><span style="--shiki-light:#032F62;--shiki-dark:#98C379;"> leaking</span><span style="--shiki-light:#032F62;--shiki-dark:#98C379;"> param:</span><span style="--shiki-light:#032F62;--shiki-dark:#98C379;"> s</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#61AFEF;">./main.go:10:13:</span><span style="--shiki-light:#032F62;--shiki-dark:#98C379;"> new</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">(</span><span style="--shiki-light:#6F42C1;--shiki-dark:#61AFEF;">A</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">) </span><span style="--shiki-light:#032F62;--shiki-dark:#98C379;">escapes</span><span style="--shiki-light:#032F62;--shiki-dark:#98C379;"> to</span><span style="--shiki-light:#032F62;--shiki-dark:#98C379;"> heap</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#61AFEF;">./main.go:15:13:</span><span style="--shiki-light:#032F62;--shiki-dark:#98C379;"> new</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">(</span><span style="--shiki-light:#6F42C1;--shiki-dark:#61AFEF;">A</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">) </span><span style="--shiki-light:#032F62;--shiki-dark:#98C379;">does</span><span style="--shiki-light:#032F62;--shiki-dark:#98C379;"> not</span><span style="--shiki-light:#032F62;--shiki-dark:#98C379;"> escape</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#61AFEF;">./main.go:16:14:</span><span style="--shiki-light:#032F62;--shiki-dark:#98C379;"> a.s</span><span style="--shiki-light:#032F62;--shiki-dark:#98C379;"> +</span><span style="--shiki-light:#032F62;--shiki-dark:#98C379;"> &quot; world&quot;</span><span style="--shiki-light:#032F62;--shiki-dark:#98C379;"> does</span><span style="--shiki-light:#032F62;--shiki-dark:#98C379;"> not</span><span style="--shiki-light:#032F62;--shiki-dark:#98C379;"> escape</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#61AFEF;">./main.go:17:12:</span><span style="--shiki-light:#032F62;--shiki-dark:#98C379;"> b</span><span style="--shiki-light:#032F62;--shiki-dark:#98C379;"> +</span><span style="--shiki-light:#032F62;--shiki-dark:#98C379;"> &quot;!&quot;</span><span style="--shiki-light:#032F62;--shiki-dark:#98C379;"> escapes</span><span style="--shiki-light:#032F62;--shiki-dark:#98C379;"> to</span><span style="--shiki-light:#032F62;--shiki-dark:#98C379;"> heap</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#61AFEF;">./main.go:18:16:</span><span style="--shiki-light:#032F62;--shiki-dark:#98C379;"> c</span><span style="--shiki-light:#032F62;--shiki-dark:#98C379;"> escapes</span><span style="--shiki-light:#032F62;--shiki-dark:#98C379;"> to</span><span style="--shiki-light:#032F62;--shiki-dark:#98C379;"> heap</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#61AFEF;">./main.go:18:16:</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;"> []interface {} literal does not escape</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#ABB2BF;">&lt;</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">autogenerated</span><span style="--shiki-light:#D73A49;--shiki-dark:#ABB2BF;">&gt;</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">:1: .this does not escape</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>如上，我们可以看到，内存的逃逸情况。</p><ul><li><code>./main.go:10:13: new(A) escapes to heap</code> ，说明 new(A) 逃逸了，也就是在方法内把局部变量的指针返回。从栈上分配的内存逃逸到堆上</li><li><code>./main.go:16:14: a.s + &quot; world&quot; does not escape</code> ，没有逃逸，因为它只在方法内存在，会在方法结束时被回收</li><li><code>./main.go:17:12: b + &quot;!&quot; escapes to heap</code> ，说明变量 c 发生了逃逸，通过 <code>fmt.Println(...interface{})</code> 打印的变量，都会发生逃逸</li></ul>`,9)]))}const r=s(t,[["render",h],["__file","9.内存逃逸.html.vue"]]),d=JSON.parse('{"path":"/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/go%E8%AF%AD%E8%A8%80/%E5%BA%95%E5%B1%82%E5%AE%9E%E7%8E%B0/9.%E5%86%85%E5%AD%98%E9%80%83%E9%80%B8.html","title":"9.内存逃逸","lang":"zh-CN","frontmatter":{"title":"9.内存逃逸","date":"2023-01-19T11:11:41.000Z","tags":["go"],"description":"Go语言的内存逃逸 Golang 程序变量会携带一组校验数据，用来证明他的整个生命周期是否在运行时完全可知。如果变量通过了这些校验，他就可以在栈上分配。否则就说它逃逸了，必须在堆上分配。 一、引起变量逃逸到堆上的典型情况 在方法内把局部变量指针返回，局部变量原本应该在栈中分配，在栈中回收。但是由于返回时被外部引用，因此其生命周期大于栈，则溢出。 发送指...","head":[["meta",{"property":"og:url","content":"https://noahyz.github.io/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/go%E8%AF%AD%E8%A8%80/%E5%BA%95%E5%B1%82%E5%AE%9E%E7%8E%B0/9.%E5%86%85%E5%AD%98%E9%80%83%E9%80%B8.html"}],["meta",{"property":"og:site_name","content":"noahyz的博客"}],["meta",{"property":"og:title","content":"9.内存逃逸"}],["meta",{"property":"og:description","content":"Go语言的内存逃逸 Golang 程序变量会携带一组校验数据，用来证明他的整个生命周期是否在运行时完全可知。如果变量通过了这些校验，他就可以在栈上分配。否则就说它逃逸了，必须在堆上分配。 一、引起变量逃逸到堆上的典型情况 在方法内把局部变量指针返回，局部变量原本应该在栈中分配，在栈中回收。但是由于返回时被外部引用，因此其生命周期大于栈，则溢出。 发送指..."}],["meta",{"property":"og:type","content":"article"}],["meta",{"property":"og:locale","content":"zh-CN"}],["meta",{"property":"article:author","content":"noahyz"}],["meta",{"property":"article:tag","content":"go"}],["meta",{"property":"article:published_time","content":"2023-01-19T11:11:41.000Z"}],["script",{"type":"application/ld+json"},"{\\"@context\\":\\"https://schema.org\\",\\"@type\\":\\"Article\\",\\"headline\\":\\"9.内存逃逸\\",\\"image\\":[\\"\\"],\\"datePublished\\":\\"2023-01-19T11:11:41.000Z\\",\\"dateModified\\":null,\\"author\\":[{\\"@type\\":\\"Person\\",\\"name\\":\\"noahyz\\",\\"url\\":\\"/about-the-author/\\"}]}"]]},"headers":[{"level":2,"title":"Go语言的内存逃逸","slug":"go语言的内存逃逸","link":"#go语言的内存逃逸","children":[{"level":3,"title":"一、引起变量逃逸到堆上的典型情况","slug":"一、引起变量逃逸到堆上的典型情况","link":"#一、引起变量逃逸到堆上的典型情况","children":[]},{"level":3,"title":"二、查询逃逸情况","slug":"二、查询逃逸情况","link":"#二、查询逃逸情况","children":[]}]}],"git":{},"readingTime":{"minutes":2.53,"words":759},"filePathRelative":"编程语言/go语言/底层实现/9.内存逃逸.md","localizedDate":"2023年1月19日","excerpt":"<h2>Go语言的内存逃逸</h2>\\n<p>Golang 程序变量会携带一组校验数据，用来证明他的整个生命周期是否在运行时完全可知。如果变量通过了这些校验，他就可以在栈上分配。否则就说它逃逸了，必须在堆上分配。</p>\\n<h3>一、引起变量逃逸到堆上的典型情况</h3>\\n<ul>\\n<li><strong>在方法内把局部变量指针返回</strong>，局部变量原本应该在栈中分配，在栈中回收。但是由于返回时被外部引用，因此其生命周期大于栈，则溢出。</li>\\n<li><strong>发送指针或带有指针的值到 channel 中。</strong> 在编译时，是没有办法知道哪个 goroutine 会在 channel 上接收数据。所以编译器没法知道变量什么时候才会被释放。</li>\\n<li><strong>在一个切片上存储指针或带指针的值。</strong> 一个典型的例子就是 []*string 。这会导致切片的内容逃逸。尽管其后面的数组可能是在栈上分配的，但其引用的值一定是在堆上。</li>\\n<li><strong>slice 的背后数组被重新分配了，因为 append 时可能会超出其容量( cap )。</strong> slice 初始化的地方在编译时是可以知道的，它最开始会在栈上分配。如果切片背后的存储要基于运行时的数据进行扩充，就会在堆上分配。</li>\\n<li><strong>在 interface 类型上调用方法。</strong> 在 interface 类型上调用方法都是动态调度的 —— 方法的真正实现只能在运行时知道。想像一个 io.Reader 类型的变量 r , 调用 r.Read(b) 会使得 r 的值和切片b 的背后存储都逃逸掉，所以会在堆上分配。</li>\\n</ul>","autoDesc":true}');export{r as comp,d as data};

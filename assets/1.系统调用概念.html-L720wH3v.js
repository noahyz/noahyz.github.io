import{_ as n}from"./plugin-vue_export-helper-DlAUqK2U.js";import{c as e,a,o as i}from"./app-D1zlwylF.js";const l={};function p(t,s){return i(),e("div",null,s[0]||(s[0]=[a(`<h3 id="一、linux-系统调用" tabindex="-1"><a class="header-anchor" href="#一、linux-系统调用"><span>一、Linux 系统调用</span></a></h3><p>Linux 系统调用是用中断门来实现的，通过软中断指令 int 来主动发起中断信息。Linux 只占用一个中断向量号，即 <code>0x80</code>，处理器执行指令 <code>int 0x80</code> 时便触发了系统调用。为了让用户程序可以通过这一个中断门调用多种系统功能，在系统调用之前，Linux 在寄存器 eax 中写入子功能号。当用户程序通过 <code>int 0x80</code> 进行系统调用时，对应的中断处理例程会根据 eax 的值来判断用户进程申请那种系统调用。</p><p>我们来看 syscall 的 man 手册</p><div class="language- line-numbers-mode" data-highlighter="shiki" data-ext="" data-title="" style="--shiki-light:#24292e;--shiki-dark:#abb2bf;--shiki-light-bg:#fff;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes github-light one-dark-pro vp-code"><code><span class="line"><span>syscall - indirect system call</span></span>
<span class="line"><span>#define SYS_getpid __NR_getpid</span></span>
<span class="line"><span>#define __NR_getpid 172</span></span>
<span class="line"><span>__SYSCALL(__NR_getpid, sys_getpid)</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>这里的 syscall 是间接的（<code>indirect system call</code>）。就是 C 库函数</p><div class="language- line-numbers-mode" data-highlighter="shiki" data-ext="" data-title="" style="--shiki-light:#24292e;--shiki-dark:#abb2bf;--shiki-light-bg:#fff;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes github-light one-dark-pro vp-code"><code><span class="line"><span>_syscall - invoking a system call without library support (OBSOLETE)</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div></div></div><p>这里的 <code>_syscall</code> 是系统调用，但是他是过时的（obsolete）</p><h3 id="二、系统调用实现" tabindex="-1"><a class="header-anchor" href="#二、系统调用实现"><span>二、系统调用实现</span></a></h3><p>一个系统功能调用分为两部分</p><ul><li>一部分是暴露给用户进程的接口函数，它属于用户空间，此部分知识用户进程使用系统调用的途径，只负责发需求</li><li>另一部分是与之对应的内核具体实现，它属于内核空间，此部分完成的是功能需求，就是系统调用子功能处理函数</li></ul><p>系统调用的实现思路</p><ol><li>用中断门实现系统调用，效仿 Linux 用 0x80 号中断作为系统调用的入口</li><li>在 IDT 中安装 0x80 号中断对应的描述符，在该描述符中注册系统调用对应的中断处理例程</li><li>建立系统调用子功能表 syscall_table，利用 eax 寄存器中的子功能号在该表中索引相应的处理函数</li><li>用宏实现用户空间系统调用接口 <code>_syscall</code>，最大支持 3 个参数的系统调用。使用寄存器传参，eax 为子功能号，ebx、ecx、edx 依次保存参数</li></ol><p>系统调用的接口如下：</p><div class="language- line-numbers-mode" data-highlighter="shiki" data-ext="" data-title="" style="--shiki-light:#24292e;--shiki-dark:#abb2bf;--shiki-light-bg:#fff;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes github-light one-dark-pro vp-code"><code><span class="line"><span>#define _syscall3(NUMBER, ARG1, ARG2, ARG3) ({</span></span>
<span class="line"><span>    int retval;</span></span>
<span class="line"><span>    asm volatile(&quot;int $0x80&quot; : &quot;=a&quot; (retval) : &quot;a&quot; (NUMBER), &quot;b&quot; (ARG1), &quot;c&quot; (ARG2), &quot;d&quot; (ARG3) : &quot;memory&quot;);</span></span>
<span class="line"><span>    retval;</span></span>
<span class="line"><span>})</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>这段内联汇编，输入参数，eax 表示子功能号，ebx、ecx、edx 分别是三个参数，调用 0x80 中断，最终结果通过 eax 输出。</p><p>我们再来看一下 0x80 号中断处理例程：</p><div class="language- line-numbers-mode" data-highlighter="shiki" data-ext="" data-title="" style="--shiki-light:#24292e;--shiki-dark:#abb2bf;--shiki-light-bg:#fff;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes github-light one-dark-pro vp-code"><code><span class="line"><span>syscall_handler:</span></span>
<span class="line"><span>;1 保存上下文环境</span></span>
<span class="line"><span>   push 0			    ; 压入0, 使栈中格式统一</span></span>
<span class="line"><span></span></span>
<span class="line"><span>   push ds</span></span>
<span class="line"><span>   push es</span></span>
<span class="line"><span>   push fs</span></span>
<span class="line"><span>   push gs</span></span>
<span class="line"><span>   pushad			    ; PUSHAD指令压入32位寄存器，其入栈顺序是:</span></span>
<span class="line"><span>				          ; EAX,ECX,EDX,EBX,ESP,EBP,ESI,EDI </span></span>
<span class="line"><span>				 </span></span>
<span class="line"><span>   push 0x80			 ; 此位置压入0x80也是为了保持统一的栈格式</span></span>
<span class="line"><span></span></span>
<span class="line"><span>;2 为系统调用子功能传入参数</span></span>
<span class="line"><span>   push edx			    ; 系统调用中第3个参数</span></span>
<span class="line"><span>   push ecx			    ; 系统调用中第2个参数</span></span>
<span class="line"><span>   push ebx			    ; 系统调用中第1个参数</span></span>
<span class="line"><span></span></span>
<span class="line"><span>;3 调用子功能处理函数</span></span>
<span class="line"><span>   call [syscall_table + eax*4]	    ; 编译器会在栈中根据C函数声明匹配正确数量的参数</span></span>
<span class="line"><span>   add esp, 12			                ; 跨过上面的三个参数</span></span>
<span class="line"><span></span></span>
<span class="line"><span>;4 将call调用后的返回值存入待当前内核栈中eax的位置</span></span>
<span class="line"><span>   mov [esp + 8*4], eax	</span></span>
<span class="line"><span>   jmp intr_exit		    ; intr_exit返回,恢复上下文</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>先压入中断错误码、然后保存任务的上下文，接着显式压入了中断号 0x80。</p><p>接下来是为子功能函数准备参数，由于目前只支持 3 个参数的系统调用，因此只压入了 3 个参数。按照 C 调用约定，最右边的参数先入栈，因此压入参数的顺序是 edx、ecx、ebx。注意，我们不管具体系统调用中参数是几个，一律压入 3 个参数。因为在函数体中，编译器生成的取参数指令是从栈顶往上（跨过栈顶的返回地址，由高地址方向）获取参数的，参数个数是通过函数声明事先确定好的，因此并不会获取到错误的参数，从而保证了多余的参数用不上。因此尽管压入了 3 个参数，但对于那些参数少于 3 个的函数也不会出错，仅仅是浪费了一点栈空间。</p><p>寄存器 eax 中是系统调用子功能号，数组 syscall_table 中存储的是函数地址，每个成员是 4 个字节大小。因此通过偏移量来调用子功能处理函数。调用完之后，通过 <code>add esp, 12</code> 跨过这三个参数（edx、ecx、ebx）。</p><p><code>mov [esp + 8*4], eax</code> 就是将返回值写到了栈（此时是内核栈）中保存 eax 的那个内核空间。<code>8*4</code> 相当于跳过了 <code>0x80,ECX,EDX,EBX,ESP,EBP,ESI,EDI </code> 这些，找到了 eax 的位置。为什么这么做呢？</p><p>我们要把返回值传给用户进程，但是从内核态退出时，要从内核栈中恢复寄存器上下文，这会将当前 eax 的返回值覆盖。那么，我们把寄存器 eax 的值回写到内核栈中用于保存 eax 的内存处，这样从内核返回时，popd 指令也只是用该返回值重新覆盖一个 eax 寄存器，返回到用户态时，用户进程便获取到了系统调用函数的返回值。</p><p>最后从中断出口函数 <code>intr_exit</code> 返回。</p>`,23)]))}const r=n(l,[["render",p],["__file","1.系统调用概念.html.vue"]]),o=JSON.parse('{"path":"/%E6%8A%80%E6%9C%AF%E4%B8%93%E9%A2%98/%E6%89%8B%E5%86%99%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/7.%E7%B3%BB%E7%BB%9F%E4%BA%A4%E4%BA%92/1.%E7%B3%BB%E7%BB%9F%E8%B0%83%E7%94%A8%E6%A6%82%E5%BF%B5.html","title":"系统调用概念","lang":"zh-CN","frontmatter":{"title":"系统调用概念","description":"一、Linux 系统调用 Linux 系统调用是用中断门来实现的，通过软中断指令 int 来主动发起中断信息。Linux 只占用一个中断向量号，即 0x80，处理器执行指令 int 0x80 时便触发了系统调用。为了让用户程序可以通过这一个中断门调用多种系统功能，在系统调用之前，Linux 在寄存器 eax 中写入子功能号。当用户程序通过 int 0x...","head":[["meta",{"property":"og:url","content":"https://noahyz.github.io/%E6%8A%80%E6%9C%AF%E4%B8%93%E9%A2%98/%E6%89%8B%E5%86%99%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/7.%E7%B3%BB%E7%BB%9F%E4%BA%A4%E4%BA%92/1.%E7%B3%BB%E7%BB%9F%E8%B0%83%E7%94%A8%E6%A6%82%E5%BF%B5.html"}],["meta",{"property":"og:site_name","content":"noahyz的博客"}],["meta",{"property":"og:title","content":"系统调用概念"}],["meta",{"property":"og:description","content":"一、Linux 系统调用 Linux 系统调用是用中断门来实现的，通过软中断指令 int 来主动发起中断信息。Linux 只占用一个中断向量号，即 0x80，处理器执行指令 int 0x80 时便触发了系统调用。为了让用户程序可以通过这一个中断门调用多种系统功能，在系统调用之前，Linux 在寄存器 eax 中写入子功能号。当用户程序通过 int 0x..."}],["meta",{"property":"og:type","content":"article"}],["meta",{"property":"og:locale","content":"zh-CN"}],["meta",{"property":"article:author","content":"noahyz"}],["script",{"type":"application/ld+json"},"{\\"@context\\":\\"https://schema.org\\",\\"@type\\":\\"Article\\",\\"headline\\":\\"系统调用概念\\",\\"image\\":[\\"\\"],\\"dateModified\\":null,\\"author\\":[{\\"@type\\":\\"Person\\",\\"name\\":\\"noahyz\\",\\"url\\":\\"/about-the-author/\\"}]}"]]},"headers":[{"level":3,"title":"一、Linux 系统调用","slug":"一、linux-系统调用","link":"#一、linux-系统调用","children":[]},{"level":3,"title":"二、系统调用实现","slug":"二、系统调用实现","link":"#二、系统调用实现","children":[]}],"git":{},"readingTime":{"minutes":4.46,"words":1338},"filePathRelative":"技术专题/手写操作系统/7.系统交互/1.系统调用概念.md","excerpt":"<h3>一、Linux 系统调用</h3>\\n<p>Linux 系统调用是用中断门来实现的，通过软中断指令 int 来主动发起中断信息。Linux 只占用一个中断向量号，即 <code>0x80</code>，处理器执行指令 <code>int 0x80</code> 时便触发了系统调用。为了让用户程序可以通过这一个中断门调用多种系统功能，在系统调用之前，Linux 在寄存器 eax 中写入子功能号。当用户程序通过 <code>int 0x80</code> 进行系统调用时，对应的中断处理例程会根据 eax 的值来判断用户进程申请那种系统调用。</p>\\n<p>我们来看 syscall 的 man 手册</p>","autoDesc":true}');export{r as comp,o as data};

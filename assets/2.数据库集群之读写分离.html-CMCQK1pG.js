import{_ as e}from"./plugin-vue_export-helper-DlAUqK2U.js";import{c as n,a as r,o as a}from"./app-D1zlwylF.js";const o={};function E(l,t){return a(),n("div",null,t[0]||(t[0]=[r('<h3 id="一、高性能数据库集群-读写分离" tabindex="-1"><a class="header-anchor" href="#一、高性能数据库集群-读写分离"><span>一、高性能数据库集群：读写分离</span></a></h3><p>基本原理是将数据库读写操作分散到不同的节点上。例如数据库主机负责读写操作，从机负责读操作。<br> 引入了两个问题：<strong>主从复制延迟</strong>和<strong>分配机制</strong></p><h4 id="_1-主从复制延迟" tabindex="-1"><a class="header-anchor" href="#_1-主从复制延迟"><span>1. 主从复制延迟</span></a></h4><p>以 MySQL 为例，主从复制延迟可能达到 1 秒，如果有大量数据同步，延迟 1 分钟也有可能。会导致从主机读取的数据和从机读取的数据不一致。</p><p>解决办法：</p><ul><li>写操作后的读操作指定发给主服务器。缺点：和业务强绑定，对业务的侵入和影响较大，新来的程序员可能会写出bug</li><li>读从机失败后再读一次主机。二次读取，无需和业务绑定，但是如果有很多二次读取，会增加主机的读压力。</li><li>关键业务读写操作全部指向主机，非关键业务采用读写分离。</li></ul><h4 id="_2-分配机制" tabindex="-1"><a class="header-anchor" href="#_2-分配机制"><span>2. 分配机制</span></a></h4><p>需要解决访问那台机器的问题，将读写操作区分开来，然后访问不同的数据库服务器，一般有两种方式：<strong>程序代码封装</strong>和<strong>中间件封装</strong></p><ul><li>程序代码封装。在代码中抽象一个数据访问层，实现读写操作分离和数据库服务器连接的管理。<br> 但是需要解决故障情况下，如果主从发生切换，则可能需要所有系统都修改配置并重启。且每个语言都需要实现。<br> 阿里的 TDDL 是一个通用的数据访问层，所有功能封装在 jar 包，具有主备、读写分离、动态数据库配置等功能</li><li>中间件封装。将作为数据库集群和业务之间的中间人。<br> 难点：1. 所有的数据库操作请求都要经过中间件，对性能要求高。2. 中间件需要探测数据库服务器的主从状态。3. 需要支持完整的 SQL 语法和数据库服务器的协议，实现复杂<br> MySQL 官方提供了 MySQL Router，主要功能有读写分离、故障自动切换、负载均衡、连接池等</li></ul>',9)]))}const s=e(o,[["render",E],["__file","2.数据库集群之读写分离.html.vue"]]),c=JSON.parse('{"path":"/%E6%9E%B6%E6%9E%84%E6%A1%86%E6%9E%B6/%E6%9E%B6%E6%9E%84%E6%A8%A1%E5%BC%8F/%E9%AB%98%E6%80%A7%E8%83%BD%E6%9E%B6%E6%9E%84%E6%A8%A1%E5%BC%8F/2.%E6%95%B0%E6%8D%AE%E5%BA%93%E9%9B%86%E7%BE%A4%E4%B9%8B%E8%AF%BB%E5%86%99%E5%88%86%E7%A6%BB.html","title":"2.数据库集群之读写分离","lang":"zh-CN","frontmatter":{"title":"2.数据库集群之读写分离","date":"2023-01-19T11:11:41.000Z","tags":["linux"],"description":"一、高性能数据库集群：读写分离 基本原理是将数据库读写操作分散到不同的节点上。例如数据库主机负责读写操作，从机负责读操作。 引入了两个问题：主从复制延迟和分配机制 1. 主从复制延迟 以 MySQL 为例，主从复制延迟可能达到 1 秒，如果有大量数据同步，延迟 1 分钟也有可能。会导致从主机读取的数据和从机读取的数据不一致。 解决办法： 写操作后的读操...","head":[["meta",{"property":"og:url","content":"https://noahyz.github.io/%E6%9E%B6%E6%9E%84%E6%A1%86%E6%9E%B6/%E6%9E%B6%E6%9E%84%E6%A8%A1%E5%BC%8F/%E9%AB%98%E6%80%A7%E8%83%BD%E6%9E%B6%E6%9E%84%E6%A8%A1%E5%BC%8F/2.%E6%95%B0%E6%8D%AE%E5%BA%93%E9%9B%86%E7%BE%A4%E4%B9%8B%E8%AF%BB%E5%86%99%E5%88%86%E7%A6%BB.html"}],["meta",{"property":"og:site_name","content":"noahyz的博客"}],["meta",{"property":"og:title","content":"2.数据库集群之读写分离"}],["meta",{"property":"og:description","content":"一、高性能数据库集群：读写分离 基本原理是将数据库读写操作分散到不同的节点上。例如数据库主机负责读写操作，从机负责读操作。 引入了两个问题：主从复制延迟和分配机制 1. 主从复制延迟 以 MySQL 为例，主从复制延迟可能达到 1 秒，如果有大量数据同步，延迟 1 分钟也有可能。会导致从主机读取的数据和从机读取的数据不一致。 解决办法： 写操作后的读操..."}],["meta",{"property":"og:type","content":"article"}],["meta",{"property":"og:locale","content":"zh-CN"}],["meta",{"property":"article:author","content":"noahyz"}],["meta",{"property":"article:tag","content":"linux"}],["meta",{"property":"article:published_time","content":"2023-01-19T11:11:41.000Z"}],["script",{"type":"application/ld+json"},"{\\"@context\\":\\"https://schema.org\\",\\"@type\\":\\"Article\\",\\"headline\\":\\"2.数据库集群之读写分离\\",\\"image\\":[\\"\\"],\\"datePublished\\":\\"2023-01-19T11:11:41.000Z\\",\\"dateModified\\":null,\\"author\\":[{\\"@type\\":\\"Person\\",\\"name\\":\\"noahyz\\",\\"url\\":\\"/about-the-author/\\"}]}"]]},"headers":[{"level":3,"title":"一、高性能数据库集群：读写分离","slug":"一、高性能数据库集群-读写分离","link":"#一、高性能数据库集群-读写分离","children":[]}],"git":{},"readingTime":{"minutes":1.95,"words":585},"filePathRelative":"架构框架/架构模式/高性能架构模式/2.数据库集群之读写分离.md","localizedDate":"2023年1月19日","excerpt":"<h3>一、高性能数据库集群：读写分离</h3>\\n<p>基本原理是将数据库读写操作分散到不同的节点上。例如数据库主机负责读写操作，从机负责读操作。<br>\\n引入了两个问题：<strong>主从复制延迟</strong>和<strong>分配机制</strong></p>\\n<h4>1. 主从复制延迟</h4>\\n<p>以 MySQL 为例，主从复制延迟可能达到 1 秒，如果有大量数据同步，延迟 1 分钟也有可能。会导致从主机读取的数据和从机读取的数据不一致。</p>\\n<p>解决办法：</p>\\n<ul>\\n<li>写操作后的读操作指定发给主服务器。缺点：和业务强绑定，对业务的侵入和影响较大，新来的程序员可能会写出bug</li>\\n<li>读从机失败后再读一次主机。二次读取，无需和业务绑定，但是如果有很多二次读取，会增加主机的读压力。</li>\\n<li>关键业务读写操作全部指向主机，非关键业务采用读写分离。</li>\\n</ul>","autoDesc":true}');export{s as comp,c as data};

import{_ as n}from"./plugin-vue_export-helper-DlAUqK2U.js";import{c as a,a as l,o as i}from"./app-D1zlwylF.js";const e="/assets/%E8%99%9A%E5%9F%BA%E7%B1%BB%E7%9A%84%E7%BB%A7%E6%89%BF-DjDcJ3pI.png",p={};function t(d,s){return i(),a("div",null,s[0]||(s[0]=[l(`<p>本文测试代码的环境为：x86-64，ubuntu22.04，gcc7.5.0</p><h2 id="一、缘起" tabindex="-1"><a class="header-anchor" href="#一、缘起"><span>一、缘起</span></a></h2><p>先使用一段代码引入本文所要探讨的主题。</p><div class="language- line-numbers-mode" data-highlighter="shiki" data-ext="" data-title="" style="--shiki-light:#24292e;--shiki-dark:#abb2bf;--shiki-light-bg:#fff;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes github-light one-dark-pro vp-code"><code><span class="line"><span>class X {};</span></span>
<span class="line"><span>class Y : public virtual X {};</span></span>
<span class="line"><span>class Z : public virtual X {};</span></span>
<span class="line"><span>class A : public Y, public Z {};</span></span>
<span class="line"><span></span></span>
<span class="line"><span>int main() {</span></span>
<span class="line"><span>    std::cout &lt;&lt; &quot;sizeof X: &quot; &lt;&lt; sizeof(X) &lt;&lt; std::endl;</span></span>
<span class="line"><span>    std::cout &lt;&lt; &quot;sizeof Y: &quot; &lt;&lt; sizeof(Y) &lt;&lt; std::endl;</span></span>
<span class="line"><span>    std::cout &lt;&lt; &quot;sizeof Z: &quot; &lt;&lt; sizeof(Z) &lt;&lt; std::endl;</span></span>
<span class="line"><span>    std::cout &lt;&lt; &quot;sizeof A: &quot; &lt;&lt; sizeof(A) &lt;&lt; std::endl;</span></span>
<span class="line"><span></span></span>
<span class="line"><span>    X x1, x2;</span></span>
<span class="line"><span>    std::cout &lt;&lt; &amp;x1 &lt;&lt; &quot; &quot; &lt;&lt; &amp;x2 &lt;&lt; std::endl;</span></span>
<span class="line"><span></span></span>
<span class="line"><span>    Y y1, y2;</span></span>
<span class="line"><span>    std::cout &lt;&lt; &amp;y1 &lt;&lt; &quot; &quot; &lt;&lt; &amp;y2 &lt;&lt; std::endl;</span></span>
<span class="line"><span></span></span>
<span class="line"><span>    Z z1, z2;</span></span>
<span class="line"><span>    std::cout &lt;&lt; &amp;z1 &lt;&lt; &quot; &quot; &lt;&lt; &amp;z2 &lt;&lt; std::endl;</span></span>
<span class="line"><span></span></span>
<span class="line"><span>    A a1, a2;</span></span>
<span class="line"><span>    std::cout &lt;&lt; &amp;a1 &lt;&lt; &quot; &quot; &lt;&lt; &amp;a2 &lt;&lt; std::endl;</span></span>
<span class="line"><span>    return 0;</span></span>
<span class="line"><span>}</span></span>
<span class="line"><span></span></span>
<span class="line"><span># g++ main.cpp -g -o main</span></span>
<span class="line"><span># ./main</span></span>
<span class="line"><span>sizeof X: 1</span></span>
<span class="line"><span>sizeof Y: 8</span></span>
<span class="line"><span>sizeof Z: 8</span></span>
<span class="line"><span>sizeof A: 16</span></span>
<span class="line"><span>0x7fffb23046fe 0x7fffb23046ff</span></span>
<span class="line"><span>0x7fffb2304700 0x7fffb2304708</span></span>
<span class="line"><span>0x7fffb2304710 0x7fffb2304718</span></span>
<span class="line"><span>0x7fffb2304720 0x7fffb2304730</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>如上的代码也是虚继承解决菱形继承中命名冲突和冗数据的问题。虚继承的目的是让某个类做出声明，承诺愿意共享他的基类。这个被共享的基类就称为虚基类。</p><p>在这种机制下，无论虚基类在继承体系中出现了多少次，在派生类中都只包含一份虚基类的成员。</p><p>虚派生只影响从指定了虚基类的派生类中进一步派生出来的类，他不会影响派生类本身。</p><h3 id="_1-空类占用的空间" tabindex="-1"><a class="header-anchor" href="#_1-空类占用的空间"><span>1. 空类占用的空间</span></a></h3><p>首先我们发现一个空的类 X。他占用的空间为 1 字节。</p><p>为什么呢？对于空类，编译器会安插一个 char。<strong>让这个类对象能有一个地址，并且可以让这个类的两个对象在内存中有不同的地址</strong>。</p><h3 id="_2-继承类占用的空间" tabindex="-1"><a class="header-anchor" href="#_2-继承类占用的空间"><span>2. 继承类占用的空间</span></a></h3><p>我们看到类 Y 和 类 Z 占用的空间大小都为 8 字节。我们来分析为什么是 8 字节。</p><p>首先，这个大小是与机器、编译器有关。我们是 64 位机器，并且编译器是 gcc7.5.0 的。也就是指针默认是 8 字节。除此之外，可能还会受到如下三种因素的影响。注意，我说的是可能。</p><ul><li>C++ 语言支持 虚拟继承 时，子类中会有一个指向虚基类实例的指针，64 位机器，指针占用 8 字节</li><li>编译器会对空类安插一个字节，如上所示。</li><li>内存对齐的限制，C++ 的类也是一个结构体，需要内存对齐。64 位机器上对齐数默认是 8 字节。</li></ul><p>我列了如上三种可能，然后如下图是类 X、Y、Z 的对象布局。</p><figure><img src="`+e+`" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure><p>我们可以看到在类 Y 和 类 Z 中，已经有了一个指向虚基类实例的指针了，编译器就不再需要为了区别空类而安插一个字节了。并且指针是 8 字节，内存也是对齐的，不需要额外的内存对齐了。</p><p>我们可以通过 gdb 简单看到这些信息</p><div class="language- line-numbers-mode" data-highlighter="shiki" data-ext="" data-title="" style="--shiki-light:#24292e;--shiki-dark:#abb2bf;--shiki-light-bg:#fff;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes github-light one-dark-pro vp-code"><code><span class="line"><span>(gdb) p y1</span></span>
<span class="line"><span>$1 = {&lt;X&gt; = {&lt;No data fields&gt;}, _vptr.Y = 0x555555557cd8 &lt;VTT for Y&gt;}</span></span>
<span class="line"><span>(gdb) p y2</span></span>
<span class="line"><span>$2 = {&lt;X&gt; = {&lt;No data fields&gt;}, _vptr.Y = 0x555555557cd8 &lt;VTT for Y&gt;}</span></span>
<span class="line"><span>(gdb) p z1</span></span>
<span class="line"><span>$3 = {&lt;X&gt; = {&lt;No data fields&gt;}, _vptr.Z = 0x555555557cb8 &lt;VTT for Z&gt;}</span></span>
<span class="line"><span>(gdb) p z2</span></span>
<span class="line"><span>$4 = {&lt;X&gt; = {&lt;No data fields&gt;}, _vptr.Z = 0x555555557cb8 &lt;VTT for Z&gt;}</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>可以看到，类 Y 和 类 Z 的对象中有对应的指针。所以类 Y 和类 Z 对象占用的空间大小为 8 字节。</p><h3 id="_3-多继承的情况" tabindex="-1"><a class="header-anchor" href="#_3-多继承的情况"><span>3. 多继承的情况</span></a></h3><p>首先无论虚基类在继承体系中出现了多少次，在派生类中都只包含一份虚基类的成员。</p><p>再来看看 类 A 的情况，类 A 对象的大小由下列几点决定：</p><ul><li>被大家共享的唯一一个 类 X 的实例，大小为 1 字节</li><li>类 Y 和 类 Z 的大小</li><li>内存对齐所需要的填充大小</li></ul><p>同理，因为类 A 继承了类 Y 和类 Z，所以类 A 对象不再需要为了区别空类而安插一个字节了。同时，也不用管被大家共享的唯一一个类 X 实例的大小了。</p><p>主要需要考虑的就是继承过来的类 Y 和 类 Z 的指向虚基类实例的指针。通过 gdb 查看如下</p><div class="language- line-numbers-mode" data-highlighter="shiki" data-ext="" data-title="" style="--shiki-light:#24292e;--shiki-dark:#abb2bf;--shiki-light-bg:#fff;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes github-light one-dark-pro vp-code"><code><span class="line"><span>(gdb) p a1</span></span>
<span class="line"><span>$5 = {&lt;Y&gt; = {&lt;X&gt; = {&lt;No data fields&gt;}, _vptr.Y = 0x555555557c38 &lt;vtable for A+24&gt;}, &lt;Z&gt; = {_vptr.Z = 0x555555557c50 &lt;VTT for A&gt;}, &lt;No data fields&gt;}</span></span>
<span class="line"><span>(gdb) p a2</span></span>
<span class="line"><span>$6 = {&lt;Y&gt; = {&lt;X&gt; = {&lt;No data fields&gt;}, _vptr.Y = 0x555555557c38 &lt;vtable for A+24&gt;}, &lt;Z&gt; = {_vptr.Z = 0x555555557c50 &lt;VTT for A&gt;}, &lt;No data fields&gt;}</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>所以，类 A 对象占用的空间大小为 16 字节。</p><h2 id="二、类成员数据的布局" tabindex="-1"><a class="header-anchor" href="#二、类成员数据的布局"><span>二、类成员数据的布局</span></a></h2><p>假如我们有这样一个类：</p><div class="language- line-numbers-mode" data-highlighter="shiki" data-ext="" data-title="" style="--shiki-light:#24292e;--shiki-dark:#abb2bf;--shiki-light-bg:#fff;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes github-light one-dark-pro vp-code"><code><span class="line"><span>class A {</span></span>
<span class="line"><span>public:</span></span>
<span class="line"><span>    float x;</span></span>
<span class="line"><span>    static int y;</span></span>
<span class="line"><span>private:</span></span>
<span class="line"><span>    double z;</span></span>
<span class="line"><span>    static char m;</span></span>
<span class="line"><span>public:</span></span>
<span class="line"><span>    char* n;</span></span>
<span class="line"><span>};</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><ul><li>C++ 标准只要求，在同一个访问权限区段中（也就是 private、public、protected 等区段），成员的排列只需符合“较晚出现的成员在类对象中有较高的地址” 这一个条件即可。也就是说，各个成员并不一定得连续排列</li><li>一般由于内存对齐，数据成员之间的边界可能会填补一些字节</li><li>数据成员的排列和访问权限区段（private、public、protected）没有关系。一般编译器会按照声明的顺序进行排列</li><li>编译器也有可能合成一些内部使用的数据成员，比如虚表指针等。至于虚表指针放在哪里，C++ 标准并未规定，由编译器决定。传统上他被放在所有显式声明的数据成员的最后。</li></ul><h2 id="三、继承与数据成员" tabindex="-1"><a class="header-anchor" href="#三、继承与数据成员"><span>三、继承与数据成员</span></a></h2><p>在 C++ 标准中，对于继承，继承类成员和基类成员的排列顺序并未强制规定，编译器可以自由安排。</p><div class="language- line-numbers-mode" data-highlighter="shiki" data-ext="" data-title="" style="--shiki-light:#24292e;--shiki-dark:#abb2bf;--shiki-light-bg:#fff;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes github-light one-dark-pro vp-code"><code><span class="line"><span>class A {</span></span>
<span class="line"><span>private:</span></span>
<span class="line"><span>    int val{1};</span></span>
<span class="line"><span>    char c1{2};</span></span>
<span class="line"><span>};</span></span>
<span class="line"><span></span></span>
<span class="line"><span>class B : public A {</span></span>
<span class="line"><span>private:</span></span>
<span class="line"><span>    char c2{3};</span></span>
<span class="line"><span>};</span></span>
<span class="line"><span></span></span>
<span class="line"><span>class C : public B {</span></span>
<span class="line"><span>private:</span></span>
<span class="line"><span>    char c3{4};</span></span>
<span class="line"><span>};</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>如上的代码，在没有多态的情况下，也就是没有虚函数的时候，派生类就只是拿到了基类的数据成员。如 gdb 所示：</p><div class="language- line-numbers-mode" data-highlighter="shiki" data-ext="" data-title="" style="--shiki-light:#24292e;--shiki-dark:#abb2bf;--shiki-light-bg:#fff;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes github-light one-dark-pro vp-code"><code><span class="line"><span>(gdb) p &amp;c</span></span>
<span class="line"><span>$1 = (C *) 0x7fffffffde70</span></span>
<span class="line"><span>(gdb) x /8xb 0x7fffffffde70</span></span>
<span class="line"><span>0x7fffffffde70: 0x01    0x00    0x00    0x00    0x02    0x03    0x04    0x00</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>如上可以看到，类 A、B、C 占用都为 8 字节。编译器对内存布局是比较紧密的。</p><h3 id="_1-多态下的类数据成员" tabindex="-1"><a class="header-anchor" href="#_1-多态下的类数据成员"><span>1. 多态下的类数据成员</span></a></h3><p>我们再来看看多态下的类对象的变化。</p><div class="language- line-numbers-mode" data-highlighter="shiki" data-ext="" data-title="" style="--shiki-light:#24292e;--shiki-dark:#abb2bf;--shiki-light-bg:#fff;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes github-light one-dark-pro vp-code"><code><span class="line"><span>class X {</span></span>
<span class="line"><span>public:</span></span>
<span class="line"><span>    virtual float get_a() { return a; }</span></span>
<span class="line"><span></span></span>
<span class="line"><span>protected:</span></span>
<span class="line"><span>    float a{0}, b{0};</span></span>
<span class="line"><span>};</span></span>
<span class="line"><span></span></span>
<span class="line"><span>class Y : public X {</span></span>
<span class="line"><span>protected:</span></span>
<span class="line"><span>    float c{0};</span></span>
<span class="line"><span>};</span></span>
<span class="line"><span></span></span>
<span class="line"><span>int main() {</span></span>
<span class="line"><span>    X x;</span></span>
<span class="line"><span>    Y y;</span></span>
<span class="line"><span>    std::cout &lt;&lt; sizeof(X) &lt;&lt; &quot; &quot; &lt;&lt; sizeof(Y) &lt;&lt; std::endl;  // 16  24</span></span>
<span class="line"><span>    return 0;</span></span>
<span class="line"><span>}</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>当加入虚函数的时候，我们的类会发生如下的几点变化，可能会带来空间和存取时间上的额外负担。</p><ul><li>类 X 会产生一个虚表（virtual table），用来存放他所声明的每一个虚函数的地址。这个虚表中元素个数一般就是虚函数的个数，再加上一个或两个 slots（用于支持 <code>runtime type identification</code>）</li><li>在每一个类 X 的对象中会导入一个虚表指针（vptr），提供执行期的链接，使每一个对象能够找到相应的虚表</li><li>会优化构造函数，使其能够为 vptr 设定初值，让他指向类所对应的虚表。这意味着，派生类和每一个基类的构造函数中，都会重新设定 vptr 的值。</li><li>会优化析构函数，使其能够析构掉 vptr。析构的调用顺序是反向的，从派生类到基类</li></ul><p>我们通过 gdb 可以看到对象的结构：</p><div class="language- line-numbers-mode" data-highlighter="shiki" data-ext="" data-title="" style="--shiki-light:#24292e;--shiki-dark:#abb2bf;--shiki-light-bg:#fff;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes github-light one-dark-pro vp-code"><code><span class="line"><span>(gdb) p x</span></span>
<span class="line"><span>$1 = {_vptr.X = 0x555555557d50 &lt;vtable for X+16&gt;, a = 0, b = 0}</span></span>
<span class="line"><span>(gdb) p y</span></span>
<span class="line"><span>$2 = {&lt;X&gt; = {_vptr.X = 0x555555557d38 &lt;vtable for Y+16&gt;, a = 0, b = 0}, c = 0}</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>如果基类对象中有 vptr，那么派生类中也会有 vptr。用于指向不同的虚表。</p>`,46)]))}const v=n(p,[["render",t],["__file","4.数据语意.html.vue"]]),u=JSON.parse('{"path":"/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/c__%E8%AF%AD%E8%A8%80/%E5%AF%B9%E8%B1%A1%E6%A8%A1%E5%9E%8B/4.%E6%95%B0%E6%8D%AE%E8%AF%AD%E6%84%8F.html","title":"4.数据语意","lang":"zh-CN","frontmatter":{"title":"4.数据语意","description":"本文测试代码的环境为：x86-64，ubuntu22.04，gcc7.5.0 一、缘起 先使用一段代码引入本文所要探讨的主题。 如上的代码也是虚继承解决菱形继承中命名冲突和冗数据的问题。虚继承的目的是让某个类做出声明，承诺愿意共享他的基类。这个被共享的基类就称为虚基类。 在这种机制下，无论虚基类在继承体系中出现了多少次，在派生类中都只包含一份虚基类的成...","head":[["meta",{"property":"og:url","content":"https://noahyz.github.io/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/c__%E8%AF%AD%E8%A8%80/%E5%AF%B9%E8%B1%A1%E6%A8%A1%E5%9E%8B/4.%E6%95%B0%E6%8D%AE%E8%AF%AD%E6%84%8F.html"}],["meta",{"property":"og:site_name","content":"noahyz的博客"}],["meta",{"property":"og:title","content":"4.数据语意"}],["meta",{"property":"og:description","content":"本文测试代码的环境为：x86-64，ubuntu22.04，gcc7.5.0 一、缘起 先使用一段代码引入本文所要探讨的主题。 如上的代码也是虚继承解决菱形继承中命名冲突和冗数据的问题。虚继承的目的是让某个类做出声明，承诺愿意共享他的基类。这个被共享的基类就称为虚基类。 在这种机制下，无论虚基类在继承体系中出现了多少次，在派生类中都只包含一份虚基类的成..."}],["meta",{"property":"og:type","content":"article"}],["meta",{"property":"og:locale","content":"zh-CN"}],["meta",{"property":"article:author","content":"noahyz"}],["script",{"type":"application/ld+json"},"{\\"@context\\":\\"https://schema.org\\",\\"@type\\":\\"Article\\",\\"headline\\":\\"4.数据语意\\",\\"image\\":[\\"\\"],\\"dateModified\\":null,\\"author\\":[{\\"@type\\":\\"Person\\",\\"name\\":\\"noahyz\\",\\"url\\":\\"/about-the-author/\\"}]}"]]},"headers":[{"level":2,"title":"一、缘起","slug":"一、缘起","link":"#一、缘起","children":[{"level":3,"title":"1. 空类占用的空间","slug":"_1-空类占用的空间","link":"#_1-空类占用的空间","children":[]},{"level":3,"title":"2. 继承类占用的空间","slug":"_2-继承类占用的空间","link":"#_2-继承类占用的空间","children":[]},{"level":3,"title":"3. 多继承的情况","slug":"_3-多继承的情况","link":"#_3-多继承的情况","children":[]}]},{"level":2,"title":"二、类成员数据的布局","slug":"二、类成员数据的布局","link":"#二、类成员数据的布局","children":[]},{"level":2,"title":"三、继承与数据成员","slug":"三、继承与数据成员","link":"#三、继承与数据成员","children":[{"level":3,"title":"1. 多态下的类数据成员","slug":"_1-多态下的类数据成员","link":"#_1-多态下的类数据成员","children":[]}]}],"git":{},"readingTime":{"minutes":6.21,"words":1864},"filePathRelative":"编程语言/c++语言/对象模型/4.数据语意.md","excerpt":"<p>本文测试代码的环境为：x86-64，ubuntu22.04，gcc7.5.0</p>\\n<h2>一、缘起</h2>\\n<p>先使用一段代码引入本文所要探讨的主题。</p>\\n<div class=\\"language- line-numbers-mode\\" data-highlighter=\\"shiki\\" data-ext=\\"\\" data-title=\\"\\" style=\\"--shiki-light:#24292e;--shiki-dark:#abb2bf;--shiki-light-bg:#fff;--shiki-dark-bg:#282c34\\"><pre class=\\"shiki shiki-themes github-light one-dark-pro vp-code\\"><code><span class=\\"line\\"><span>class X {};</span></span>\\n<span class=\\"line\\"><span>class Y : public virtual X {};</span></span>\\n<span class=\\"line\\"><span>class Z : public virtual X {};</span></span>\\n<span class=\\"line\\"><span>class A : public Y, public Z {};</span></span>\\n<span class=\\"line\\"><span></span></span>\\n<span class=\\"line\\"><span>int main() {</span></span>\\n<span class=\\"line\\"><span>    std::cout &lt;&lt; \\"sizeof X: \\" &lt;&lt; sizeof(X) &lt;&lt; std::endl;</span></span>\\n<span class=\\"line\\"><span>    std::cout &lt;&lt; \\"sizeof Y: \\" &lt;&lt; sizeof(Y) &lt;&lt; std::endl;</span></span>\\n<span class=\\"line\\"><span>    std::cout &lt;&lt; \\"sizeof Z: \\" &lt;&lt; sizeof(Z) &lt;&lt; std::endl;</span></span>\\n<span class=\\"line\\"><span>    std::cout &lt;&lt; \\"sizeof A: \\" &lt;&lt; sizeof(A) &lt;&lt; std::endl;</span></span>\\n<span class=\\"line\\"><span></span></span>\\n<span class=\\"line\\"><span>    X x1, x2;</span></span>\\n<span class=\\"line\\"><span>    std::cout &lt;&lt; &amp;x1 &lt;&lt; \\" \\" &lt;&lt; &amp;x2 &lt;&lt; std::endl;</span></span>\\n<span class=\\"line\\"><span></span></span>\\n<span class=\\"line\\"><span>    Y y1, y2;</span></span>\\n<span class=\\"line\\"><span>    std::cout &lt;&lt; &amp;y1 &lt;&lt; \\" \\" &lt;&lt; &amp;y2 &lt;&lt; std::endl;</span></span>\\n<span class=\\"line\\"><span></span></span>\\n<span class=\\"line\\"><span>    Z z1, z2;</span></span>\\n<span class=\\"line\\"><span>    std::cout &lt;&lt; &amp;z1 &lt;&lt; \\" \\" &lt;&lt; &amp;z2 &lt;&lt; std::endl;</span></span>\\n<span class=\\"line\\"><span></span></span>\\n<span class=\\"line\\"><span>    A a1, a2;</span></span>\\n<span class=\\"line\\"><span>    std::cout &lt;&lt; &amp;a1 &lt;&lt; \\" \\" &lt;&lt; &amp;a2 &lt;&lt; std::endl;</span></span>\\n<span class=\\"line\\"><span>    return 0;</span></span>\\n<span class=\\"line\\"><span>}</span></span>\\n<span class=\\"line\\"><span></span></span>\\n<span class=\\"line\\"><span># g++ main.cpp -g -o main</span></span>\\n<span class=\\"line\\"><span># ./main</span></span>\\n<span class=\\"line\\"><span>sizeof X: 1</span></span>\\n<span class=\\"line\\"><span>sizeof Y: 8</span></span>\\n<span class=\\"line\\"><span>sizeof Z: 8</span></span>\\n<span class=\\"line\\"><span>sizeof A: 16</span></span>\\n<span class=\\"line\\"><span>0x7fffb23046fe 0x7fffb23046ff</span></span>\\n<span class=\\"line\\"><span>0x7fffb2304700 0x7fffb2304708</span></span>\\n<span class=\\"line\\"><span>0x7fffb2304710 0x7fffb2304718</span></span>\\n<span class=\\"line\\"><span>0x7fffb2304720 0x7fffb2304730</span></span></code></pre>\\n<div class=\\"line-numbers\\" aria-hidden=\\"true\\" style=\\"counter-reset:line-number 0\\"><div class=\\"line-number\\"></div><div class=\\"line-number\\"></div><div class=\\"line-number\\"></div><div class=\\"line-number\\"></div><div class=\\"line-number\\"></div><div class=\\"line-number\\"></div><div class=\\"line-number\\"></div><div class=\\"line-number\\"></div><div class=\\"line-number\\"></div><div class=\\"line-number\\"></div><div class=\\"line-number\\"></div><div class=\\"line-number\\"></div><div class=\\"line-number\\"></div><div class=\\"line-number\\"></div><div class=\\"line-number\\"></div><div class=\\"line-number\\"></div><div class=\\"line-number\\"></div><div class=\\"line-number\\"></div><div class=\\"line-number\\"></div><div class=\\"line-number\\"></div><div class=\\"line-number\\"></div><div class=\\"line-number\\"></div><div class=\\"line-number\\"></div><div class=\\"line-number\\"></div><div class=\\"line-number\\"></div><div class=\\"line-number\\"></div><div class=\\"line-number\\"></div><div class=\\"line-number\\"></div><div class=\\"line-number\\"></div><div class=\\"line-number\\"></div><div class=\\"line-number\\"></div><div class=\\"line-number\\"></div><div class=\\"line-number\\"></div><div class=\\"line-number\\"></div><div class=\\"line-number\\"></div></div></div>","autoDesc":true}');export{v as comp,u as data};

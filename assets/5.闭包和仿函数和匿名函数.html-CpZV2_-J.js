import{_ as i}from"./plugin-vue_export-helper-DlAUqK2U.js";import{c as n,a,o as e}from"./app-D1zlwylF.js";const l={};function t(p,s){return e(),n("div",null,s[0]||(s[0]=[a(`<h2 id="一、仿函数" tabindex="-1"><a class="header-anchor" href="#一、仿函数"><span>一、仿函数</span></a></h2><p>Functor/Function Object翻译过来就是仿函数，它是通过重载()运算符模拟函数行为的类。也就是说，它不是函数（所以仿函数翻译的很贴切）。因为它重载了()运算符，因此可以像调用函数一样对它进行调用。STL中大量运用了Function Object，也提供了很多预先定义的Function Object。还是从vector遍历举例：</p><div class="language-c++ line-numbers-mode" data-highlighter="shiki" data-ext="c++" data-title="c++" style="--shiki-light:#24292e;--shiki-dark:#abb2bf;--shiki-light-bg:#fff;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes github-light one-dark-pro vp-code"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#C678DD;">class</span><span style="--shiki-light:#6F42C1;--shiki-dark:#E5C07B;"> PrintInt</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">{</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#C678DD;">public:</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#C678DD;">    void</span><span style="--shiki-light:#D73A49;--shiki-dark:#C678DD;"> operator</span><span style="--shiki-light:#6F42C1;--shiki-dark:#ABB2BF;">()</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">(</span><span style="--shiki-light:#D73A49;--shiki-dark:#C678DD;">int</span><span style="--shiki-light:#E36209;--shiki-dark:#E06C75;--shiki-light-font-style:inherit;--shiki-dark-font-style:italic;"> elem</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">) </span><span style="--shiki-light:#D73A49;--shiki-dark:#C678DD;">const</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">    {</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#ABB2BF;">        std</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">::cout</span><span style="--shiki-light:#D73A49;--shiki-dark:#C678DD;">&lt;&lt;</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">elem</span><span style="--shiki-light:#D73A49;--shiki-dark:#C678DD;">&lt;&lt;</span><span style="--shiki-light:#032F62;--shiki-dark:#98C379;">&#39; &#39;</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">    }</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">};</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;"> </span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#ABB2BF;">std</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">::vector</span><span style="--shiki-light:#D73A49;--shiki-dark:#C678DD;">&lt;int&gt;</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;"> v;</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#61AFEF;">for_each</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">(</span><span style="--shiki-light:#24292E;--shiki-dark:#E5C07B;">v</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#61AFEF;">begin</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">(),</span><span style="--shiki-light:#24292E;--shiki-dark:#E5C07B;">v</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#61AFEF;">end</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">(), </span><span style="--shiki-light:#6F42C1;--shiki-dark:#61AFEF;">PrintInt</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">()); </span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;"> </span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#7F848E;--shiki-light-font-style:inherit;--shiki-dark-font-style:italic;">//C++ 11 lambda stype</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#61AFEF;">for_each</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">(</span><span style="--shiki-light:#6F42C1;--shiki-dark:#61AFEF;">begin</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">(v), </span><span style="--shiki-light:#6F42C1;--shiki-dark:#61AFEF;">end</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">(v), [](</span><span style="--shiki-light:#D73A49;--shiki-dark:#C678DD;">int</span><span style="--shiki-light:#E36209;--shiki-dark:#E06C75;--shiki-light-font-style:inherit;--shiki-dark-font-style:italic;"> n</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">){ cout</span><span style="--shiki-light:#D73A49;--shiki-dark:#C678DD;">&lt;&lt;</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;"> n </span><span style="--shiki-light:#D73A49;--shiki-dark:#C678DD;">&lt;&lt;</span><span style="--shiki-light:#032F62;--shiki-dark:#98C379;">&quot;, &quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">; });</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>仿函数的优点：</p><p>1.<a href="https://so.csdn.net/so/search?q=%E4%BB%BF%E5%87%BD%E6%95%B0&amp;spm=1001.2101.3001.7020" target="_blank" rel="noopener noreferrer">仿函数</a>是对象，可以拥有成员函数和成员变量，即仿函数拥有状态(states)<br> 2.每个仿函数都有自己的类型<br> 3.仿函数通常比一般函数快（很多信息编译期确定）</p><h2 id="二、闭包" tabindex="-1"><a class="header-anchor" href="#二、闭包"><span>二、闭包</span></a></h2><p><strong>闭包</strong>（<a href="https://link.zhihu.com/?target=https%3A//en.wikipedia.org/wiki/Closure_(computer_programming)" target="_blank" rel="noopener noreferrer">Closure</a>）可以被理解为一个附带数据的操作，WikiPedia 对闭包的定义是 <em>&quot;In programming languages, a <strong>closure</strong>, also <strong>lexical closure</strong> or <strong>function closure</strong>, is a technique for implementing <strong>lexically scoped name binding</strong> in a language with <strong>first-class functions</strong>.&quot;</em>，其中有两层含义：</p><ol><li>词法作用域（<a href="https://link.zhihu.com/?target=https%3A//en.wikipedia.org/wiki/Lexically_scoped" target="_blank" rel="noopener noreferrer">lexically scoped</a>）的名字绑定（<a href="https://link.zhihu.com/?target=https%3A//en.wikipedia.org/wiki/Name_binding" target="_blank" rel="noopener noreferrer">name binding</a>）：在词法作用域（C++ 的词法作用域是静态绑定的，包括块、函数、类、命名空间、全局作用域等）中，变量名与其词法上下文的标识符相关联，而独立于运行时的调用栈；</li><li>函数被当作头等公民（<a href="https://link.zhihu.com/?target=https%3A//en.wikipedia.org/wiki/First-class_citizen" target="_blank" rel="noopener noreferrer">first-class citizen</a>）：在运行时可以构造一个函数对象并将其作为参数传递给其他函数；</li></ol><p>显然 C++ 98 并不符合这两点定义，因此 C++ 98 中并没有严格意义上的闭包，但我们可以用仿函数（<a href="https://link.zhihu.com/?target=https%3A//www.geeksforgeeks.org/functors-in-cpp/" target="_blank" rel="noopener noreferrer">Functor</a>）来模拟闭包的行为；仿函数即一个重载了小括号操作符的类，这个类拥有与函数相近的行为方式，它拥有自己的私有成员变量，例如：</p><div class="language- line-numbers-mode" data-highlighter="shiki" data-ext="" data-title="" style="--shiki-light:#24292e;--shiki-dark:#abb2bf;--shiki-light-bg:#fff;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes github-light one-dark-pro vp-code"><code><span class="line"><span>class Adder</span></span>
<span class="line"><span>{</span></span>
<span class="line"><span>public:</span></span>
<span class="line"><span>    int operator()(int num)</span></span>
<span class="line"><span>    {</span></span>
<span class="line"><span>        sum += num;</span></span>
<span class="line"><span>        return sum;</span></span>
<span class="line"><span>    }</span></span>
<span class="line"><span></span></span>
<span class="line"><span>    Adder() : sum(0) {}</span></span>
<span class="line"><span>    Adder(int num) : sum(num) {}</span></span>
<span class="line"><span>private:</span></span>
<span class="line"><span>    int sum;</span></span>
<span class="line"><span>};</span></span>
<span class="line"><span></span></span>
<span class="line"><span>int main()</span></span>
<span class="line"><span>{</span></span>
<span class="line"><span>    Adder adder(0);</span></span>
<span class="line"><span>    cout &lt;&lt; adder(1) &lt;&lt; endl;</span></span>
<span class="line"><span>    cout &lt;&lt; adder(2) &lt;&lt; endl;</span></span>
<span class="line"><span>    cout &lt;&lt; adder(3) &lt;&lt; endl;</span></span>
<span class="line"><span>}</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>相比之下 golang 中真正的闭包显得简洁很多：</p><div class="language- line-numbers-mode" data-highlighter="shiki" data-ext="" data-title="" style="--shiki-light:#24292e;--shiki-dark:#abb2bf;--shiki-light-bg:#fff;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes github-light one-dark-pro vp-code"><code><span class="line"><span>unc adder() func(int) int {</span></span>
<span class="line"><span>    sum := 0</span></span>
<span class="line"><span>    return func(num int) int {</span></span>
<span class="line"><span>        sum += num</span></span>
<span class="line"><span>        return sum</span></span>
<span class="line"><span>    }</span></span>
<span class="line"><span>}</span></span>
<span class="line"><span></span></span>
<span class="line"><span>func main() {</span></span>
<span class="line"><span>    numAdder := adder()</span></span>
<span class="line"><span>    fmt.Println(numAdder(1))</span></span>
<span class="line"><span>    fmt.Println(numAdder(2))</span></span>
<span class="line"><span>    fmt.Println(numAdder(3))</span></span>
<span class="line"><span>}</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h2 id="三、匿名函数" tabindex="-1"><a class="header-anchor" href="#三、匿名函数"><span>三、匿名函数</span></a></h2><p>C++ 11 标准中正式引入了匿名函数，也叫做 lambda 表达式（<a href="https://link.zhihu.com/?target=https%3A//en.cppreference.com/w/cpp/language/lambda" target="_blank" rel="noopener noreferrer">Lambda Expression</a>）；匿名函数是一种没有被绑定标识符的函数，可以用于很方便地定义一个临时的函数对象，或作为一个函数对象传递给更上层的函数（例如 <code>std::for_each</code>），其在 C++ 11 的语法上表现得非常轻量级，不需要像普通的<strong>具名函数</strong>一样单独在头文件中作出声明，且<strong>符合闭包的定义</strong>。</p><h3 id="_1-闭包和匿名函数的关系" tabindex="-1"><a class="header-anchor" href="#_1-闭包和匿名函数的关系"><span>1. 闭包和匿名函数的关系</span></a></h3><ol><li>匿名函数和闭包的关系就如同类和类对象的关系，匿名函数和类的定义都只存在于源码（代码段）中，而闭包和类对象则是在运行时占用内存空间的实体；</li><li>对匿名函数的定义会生成一个独一无二的类，并在运行时生成其类对象；</li><li>可以知道实际上匿名函数也是用仿函数实现的，它实际上是 C++ 11 加入的语法糖，不过其语法特性是符合闭包定义的。</li></ol>`,16)]))}const k=i(l,[["render",t],["__file","5.闭包和仿函数和匿名函数.html.vue"]]),d=JSON.parse(`{"path":"/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/c__%E8%AF%AD%E8%A8%80/%E5%9F%BA%E7%A1%80%E8%AF%AD%E6%B3%95/5.%E9%97%AD%E5%8C%85%E5%92%8C%E4%BB%BF%E5%87%BD%E6%95%B0%E5%92%8C%E5%8C%BF%E5%90%8D%E5%87%BD%E6%95%B0.html","title":"5.闭包和仿函数和匿名函数","lang":"zh-CN","frontmatter":{"title":"5.闭包和仿函数和匿名函数","date":"2023-01-19T11:11:41.000Z","tags":["linux"],"description":"一、仿函数 Functor/Function Object翻译过来就是仿函数，它是通过重载()运算符模拟函数行为的类。也就是说，它不是函数（所以仿函数翻译的很贴切）。因为它重载了()运算符，因此可以像调用函数一样对它进行调用。STL中大量运用了Function Object，也提供了很多预先定义的Function Object。还是从vector遍历举...","head":[["meta",{"property":"og:url","content":"https://noahyz.github.io/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/c__%E8%AF%AD%E8%A8%80/%E5%9F%BA%E7%A1%80%E8%AF%AD%E6%B3%95/5.%E9%97%AD%E5%8C%85%E5%92%8C%E4%BB%BF%E5%87%BD%E6%95%B0%E5%92%8C%E5%8C%BF%E5%90%8D%E5%87%BD%E6%95%B0.html"}],["meta",{"property":"og:site_name","content":"noahyz的博客"}],["meta",{"property":"og:title","content":"5.闭包和仿函数和匿名函数"}],["meta",{"property":"og:description","content":"一、仿函数 Functor/Function Object翻译过来就是仿函数，它是通过重载()运算符模拟函数行为的类。也就是说，它不是函数（所以仿函数翻译的很贴切）。因为它重载了()运算符，因此可以像调用函数一样对它进行调用。STL中大量运用了Function Object，也提供了很多预先定义的Function Object。还是从vector遍历举..."}],["meta",{"property":"og:type","content":"article"}],["meta",{"property":"og:locale","content":"zh-CN"}],["meta",{"property":"article:author","content":"noahyz"}],["meta",{"property":"article:tag","content":"linux"}],["meta",{"property":"article:published_time","content":"2023-01-19T11:11:41.000Z"}],["script",{"type":"application/ld+json"},"{\\"@context\\":\\"https://schema.org\\",\\"@type\\":\\"Article\\",\\"headline\\":\\"5.闭包和仿函数和匿名函数\\",\\"image\\":[\\"\\"],\\"datePublished\\":\\"2023-01-19T11:11:41.000Z\\",\\"dateModified\\":null,\\"author\\":[{\\"@type\\":\\"Person\\",\\"name\\":\\"noahyz\\",\\"url\\":\\"/about-the-author/\\"}]}"]]},"headers":[{"level":2,"title":"一、仿函数","slug":"一、仿函数","link":"#一、仿函数","children":[]},{"level":2,"title":"二、闭包","slug":"二、闭包","link":"#二、闭包","children":[]},{"level":2,"title":"三、匿名函数","slug":"三、匿名函数","link":"#三、匿名函数","children":[{"level":3,"title":"1. 闭包和匿名函数的关系","slug":"_1-闭包和匿名函数的关系","link":"#_1-闭包和匿名函数的关系","children":[]}]}],"git":{},"readingTime":{"minutes":3.09,"words":926},"filePathRelative":"编程语言/c++语言/基础语法/5.闭包和仿函数和匿名函数.md","localizedDate":"2023年1月19日","excerpt":"<h2>一、仿函数</h2>\\n<p>Functor/Function Object翻译过来就是仿函数，它是通过重载()运算符模拟函数行为的类。也就是说，它不是函数（所以仿函数翻译的很贴切）。因为它重载了()运算符，因此可以像调用函数一样对它进行调用。STL中大量运用了Function Object，也提供了很多预先定义的Function Object。还是从vector遍历举例：</p>\\n<div class=\\"language-c++ line-numbers-mode\\" data-highlighter=\\"shiki\\" data-ext=\\"c++\\" data-title=\\"c++\\" style=\\"--shiki-light:#24292e;--shiki-dark:#abb2bf;--shiki-light-bg:#fff;--shiki-dark-bg:#282c34\\"><pre class=\\"shiki shiki-themes github-light one-dark-pro vp-code\\"><code><span class=\\"line\\"><span style=\\"--shiki-light:#D73A49;--shiki-dark:#C678DD\\">class</span><span style=\\"--shiki-light:#6F42C1;--shiki-dark:#E5C07B\\"> PrintInt</span></span>\\n<span class=\\"line\\"><span style=\\"--shiki-light:#24292E;--shiki-dark:#ABB2BF\\">{</span></span>\\n<span class=\\"line\\"><span style=\\"--shiki-light:#D73A49;--shiki-dark:#C678DD\\">public:</span></span>\\n<span class=\\"line\\"><span style=\\"--shiki-light:#D73A49;--shiki-dark:#C678DD\\">    void</span><span style=\\"--shiki-light:#D73A49;--shiki-dark:#C678DD\\"> operator</span><span style=\\"--shiki-light:#6F42C1;--shiki-dark:#ABB2BF\\">()</span><span style=\\"--shiki-light:#24292E;--shiki-dark:#ABB2BF\\">(</span><span style=\\"--shiki-light:#D73A49;--shiki-dark:#C678DD\\">int</span><span style=\\"--shiki-light:#E36209;--shiki-dark:#E06C75;--shiki-light-font-style:inherit;--shiki-dark-font-style:italic\\"> elem</span><span style=\\"--shiki-light:#24292E;--shiki-dark:#ABB2BF\\">) </span><span style=\\"--shiki-light:#D73A49;--shiki-dark:#C678DD\\">const</span></span>\\n<span class=\\"line\\"><span style=\\"--shiki-light:#24292E;--shiki-dark:#ABB2BF\\">    {</span></span>\\n<span class=\\"line\\"><span style=\\"--shiki-light:#6F42C1;--shiki-dark:#ABB2BF\\">        std</span><span style=\\"--shiki-light:#24292E;--shiki-dark:#ABB2BF\\">::cout</span><span style=\\"--shiki-light:#D73A49;--shiki-dark:#C678DD\\">&lt;&lt;</span><span style=\\"--shiki-light:#24292E;--shiki-dark:#ABB2BF\\">elem</span><span style=\\"--shiki-light:#D73A49;--shiki-dark:#C678DD\\">&lt;&lt;</span><span style=\\"--shiki-light:#032F62;--shiki-dark:#98C379\\">' '</span><span style=\\"--shiki-light:#24292E;--shiki-dark:#ABB2BF\\">;</span></span>\\n<span class=\\"line\\"><span style=\\"--shiki-light:#24292E;--shiki-dark:#ABB2BF\\">    }</span></span>\\n<span class=\\"line\\"><span style=\\"--shiki-light:#24292E;--shiki-dark:#ABB2BF\\">};</span></span>\\n<span class=\\"line\\"><span style=\\"--shiki-light:#24292E;--shiki-dark:#ABB2BF\\"> </span></span>\\n<span class=\\"line\\"><span style=\\"--shiki-light:#6F42C1;--shiki-dark:#ABB2BF\\">std</span><span style=\\"--shiki-light:#24292E;--shiki-dark:#ABB2BF\\">::vector</span><span style=\\"--shiki-light:#D73A49;--shiki-dark:#C678DD\\">&lt;int&gt;</span><span style=\\"--shiki-light:#24292E;--shiki-dark:#ABB2BF\\"> v;</span></span>\\n<span class=\\"line\\"><span style=\\"--shiki-light:#6F42C1;--shiki-dark:#61AFEF\\">for_each</span><span style=\\"--shiki-light:#24292E;--shiki-dark:#ABB2BF\\">(</span><span style=\\"--shiki-light:#24292E;--shiki-dark:#E5C07B\\">v</span><span style=\\"--shiki-light:#24292E;--shiki-dark:#ABB2BF\\">.</span><span style=\\"--shiki-light:#6F42C1;--shiki-dark:#61AFEF\\">begin</span><span style=\\"--shiki-light:#24292E;--shiki-dark:#ABB2BF\\">(),</span><span style=\\"--shiki-light:#24292E;--shiki-dark:#E5C07B\\">v</span><span style=\\"--shiki-light:#24292E;--shiki-dark:#ABB2BF\\">.</span><span style=\\"--shiki-light:#6F42C1;--shiki-dark:#61AFEF\\">end</span><span style=\\"--shiki-light:#24292E;--shiki-dark:#ABB2BF\\">(), </span><span style=\\"--shiki-light:#6F42C1;--shiki-dark:#61AFEF\\">PrintInt</span><span style=\\"--shiki-light:#24292E;--shiki-dark:#ABB2BF\\">()); </span></span>\\n<span class=\\"line\\"><span style=\\"--shiki-light:#24292E;--shiki-dark:#ABB2BF\\"> </span></span>\\n<span class=\\"line\\"><span style=\\"--shiki-light:#6A737D;--shiki-dark:#7F848E;--shiki-light-font-style:inherit;--shiki-dark-font-style:italic\\">//C++ 11 lambda stype</span></span>\\n<span class=\\"line\\"><span style=\\"--shiki-light:#6F42C1;--shiki-dark:#61AFEF\\">for_each</span><span style=\\"--shiki-light:#24292E;--shiki-dark:#ABB2BF\\">(</span><span style=\\"--shiki-light:#6F42C1;--shiki-dark:#61AFEF\\">begin</span><span style=\\"--shiki-light:#24292E;--shiki-dark:#ABB2BF\\">(v), </span><span style=\\"--shiki-light:#6F42C1;--shiki-dark:#61AFEF\\">end</span><span style=\\"--shiki-light:#24292E;--shiki-dark:#ABB2BF\\">(v), [](</span><span style=\\"--shiki-light:#D73A49;--shiki-dark:#C678DD\\">int</span><span style=\\"--shiki-light:#E36209;--shiki-dark:#E06C75;--shiki-light-font-style:inherit;--shiki-dark-font-style:italic\\"> n</span><span style=\\"--shiki-light:#24292E;--shiki-dark:#ABB2BF\\">){ cout</span><span style=\\"--shiki-light:#D73A49;--shiki-dark:#C678DD\\">&lt;&lt;</span><span style=\\"--shiki-light:#24292E;--shiki-dark:#ABB2BF\\"> n </span><span style=\\"--shiki-light:#D73A49;--shiki-dark:#C678DD\\">&lt;&lt;</span><span style=\\"--shiki-light:#032F62;--shiki-dark:#98C379\\">\\", \\"</span><span style=\\"--shiki-light:#24292E;--shiki-dark:#ABB2BF\\">; });</span></span></code></pre>\\n<div class=\\"line-numbers\\" aria-hidden=\\"true\\" style=\\"counter-reset:line-number 0\\"><div class=\\"line-number\\"></div><div class=\\"line-number\\"></div><div class=\\"line-number\\"></div><div class=\\"line-number\\"></div><div class=\\"line-number\\"></div><div class=\\"line-number\\"></div><div class=\\"line-number\\"></div><div class=\\"line-number\\"></div><div class=\\"line-number\\"></div><div class=\\"line-number\\"></div><div class=\\"line-number\\"></div><div class=\\"line-number\\"></div><div class=\\"line-number\\"></div><div class=\\"line-number\\"></div></div></div>","autoDesc":true}`);export{k as comp,d as data};

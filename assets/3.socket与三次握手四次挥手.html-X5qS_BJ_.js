import{_ as s}from"./plugin-vue_export-helper-DlAUqK2U.js";import{c as n,a,o as i}from"./app-D1zlwylF.js";const c="/assets/tcp%E9%80%9A%E4%BF%A1%E5%9B%BE%E7%A4%BA-K1xkRvRR.png",l="/assets/socket%E5%B1%82%E9%9D%A2%E7%9A%84%E4%B8%89%E6%AC%A1%E6%8F%A1%E6%89%8B%E8%BF%87%E7%A8%8B-BOUFJk_1.png",t={};function o(d,e){return i(),n("div",null,e[0]||(e[0]=[a('<p>本文我们结合 TCP 的三次握手、四次挥手，来谈一谈 socket 相关的系统调用。</p><h3 id="一、socket-系统调用" tabindex="-1"><a class="header-anchor" href="#一、socket-系统调用"><span>一、socket 系统调用</span></a></h3><p><code>socket()</code> ：负责产生一个套接字的描述符</p><p><code>bind()</code>：将创建好的 socket 与地址（IP 以及端口）绑定</p><p><code>listen()</code>：为接收用户请求做好就绪准备，比如初始化好半连接队列、全连接队列。listen 的第二个参数 backlog 与全连接队列的最大长度有关。</p><p><code>accept()</code>：一般情况下，如果没有请求到来，那么服务器会阻塞在 accept 函数上。当有请求时，也就是全连接队列中有已经就绪的连接时，他会返回一个新的描述符。这个新的描述符代表可以与客户端通信的 TCP 连接。</p><p><code>connect()</code>：客户端在创建 socket 成功后，使用 connect 发起连接。如果客户端程序没有调用 bind 函数，那么 connect 函数会确定源 IP 地址，并按照一定的算法选择一个临时端口作为源端口。如果是 TCP 连接，那么 connect 函数需要进行 TCP 三次握手，也就是客户端和服务端双方需要建立一些数据结构来维护连接状态。</p><h3 id="二、三次握手过程" tabindex="-1"><a class="header-anchor" href="#二、三次握手过程"><span>二、三次握手过程</span></a></h3><img src="'+c+'" style="zoom:33%;"><figure><img src="'+l+`" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure><ul><li>client 端向 server 端发送 SYN 发起握手，client 端进入 SYN_SENT 状态</li><li>server 端收到 client 端的 SYN 请求后，server 端进入 SYN_RECV 状态，此时内核会将连接存储到半连接队列（<code>SYN Queue</code>），并向 client 端回复 <code>SYN+ACK</code></li><li>client 端收到 server 端的 <code>SYN+ACK</code> 后，client 端回复 ACK 并进入 ESTABLISHED 状态。</li><li>server 端收到 client 端的 ACK 后，内核将此连接从半连接队列（<code>SYN Queue</code>）中取出，添加到全连接队列（<code>Accept Queue</code>），server 端进入 ESTABLISHED 状态</li><li>server 端引用程序调用 accept 函数时，将连接从全连接队列（<code>Accept Queue</code>）中取出</li></ul><p>其中 “全连接队列” 和 “半连接队列” 都有长度大小限制，超过限制时内核会将连接丢弃或者返回 RST 包。</p><ul><li>半连接队列：只进行了两次握手，还未收到客户端确定 ACK 的连接，会放到半连接队列中</li><li>全连接队列：三次握手成功的连接，会放到全连接队列中</li></ul><h3 id="三、全连接队列" tabindex="-1"><a class="header-anchor" href="#三、全连接队列"><span>三、全连接队列</span></a></h3><h4 id="_1-查看全连接队列的长度" tabindex="-1"><a class="header-anchor" href="#_1-查看全连接队列的长度"><span>1. 查看全连接队列的长度</span></a></h4><p>通过 ss 命令可以查看当前 TCP 全连接队列的信息</p><div class="language- line-numbers-mode" data-highlighter="shiki" data-ext="" data-title="" style="--shiki-light:#24292e;--shiki-dark:#abb2bf;--shiki-light-bg:#fff;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes github-light one-dark-pro vp-code"><code><span class="line"><span># -n 不解析服务名称 </span></span>
<span class="line"><span># -t 只显示 tcp sockets </span></span>
<span class="line"><span># -l 显示正在监听(LISTEN)的 sockets </span></span>
<span class="line"><span></span></span>
<span class="line"><span># ss -nlt</span></span>
<span class="line"><span>State  Recv-Q  Send-Q      Local Address:Port        Peer Address:Port</span></span>
<span class="line"><span>LISTEN  0      128         127.0.0.1:16308            0.0.0.0:*</span></span>
<span class="line"><span>LISTEN  0      511         127.0.0.1:33077            0.0.0.0:*</span></span>
<span class="line"><span>LISTEN  0      128         127.0.0.53%lo:53           0.0.0.0:*</span></span>
<span class="line"><span>LISTEN  0      128         0.0.0.0:22                 0.0.0.0:*</span></span>
<span class="line"><span></span></span>
<span class="line"><span> # ss -nt</span></span>
<span class="line"><span>State   Recv-Q       Send-Q       Local Address:Port           Peer Address:Port</span></span>
<span class="line"><span>ESTAB   0            0            172.18.184.201:55306         10.14.34.213:443</span></span>
<span class="line"><span>ESTAB   0            0            127.0.0.1:56898              127.0.0.1:33077</span></span>
<span class="line"><span>ESTAB   0            0            127.0.0.1:33077              127.0.0.1:56898</span></span>
<span class="line"><span>ESTAB   0            0            127.0.0.1:56948              127.0.0.1:33077</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>对于 LISTEN 状态的 socket：</p><ul><li><p>Recv-Q：已完成三次握手等待应用程序 accept 的 TCP 连接数量。</p><p>该值最大为：<code>Send-Q + 1</code>，即 <code>min(backlog, somaxconn)+1</code></p><p>之所以加 1，是因为操作系统内核的实现中，在判断队列是否已满时，用的是 <code>&gt;</code> 号，这导致当已创建成功的连接数量正好等于 <code>min(backlog, somaxconn)</code> 时，还会再多创建一个 TCP 连接，最终结果就是 <code>min(backlog, somaxconn)+1</code></p></li><li><p>Send-Q：listen 时，backlog 的大小，其值为 <code>min(backlog, somaxconn)</code></p></li></ul><p>对于非 LISTEN 状态的 socket：</p><ul><li>Recv-Q：操作系统已收到，但未被应用程序读取的字节数</li><li>Send-Q：已发送给对端应用，但未收到确认的字节数。此时，这些数据依然由操作系统持有</li></ul><blockquote><p>backlog：是 listen 的第二个参数，即 <code>int listen(int sockfd, int backlog)</code></p><p>somaxconn：是一个 OS 级别的参数，由 <code>/proc/sys/net/core/somaxconn</code> 指定</p></blockquote><h3 id="四、半连接队列" tabindex="-1"><a class="header-anchor" href="#四、半连接队列"><span>四、半连接队列</span></a></h3><h4 id="_1-查看半连接队列长度" tabindex="-1"><a class="header-anchor" href="#_1-查看半连接队列长度"><span>1. 查看半连接队列长度</span></a></h4><p>TCP 半连接时，服务端处于 SYN_RECV 状态的 TCP 连接，就是 TCP 半连接队列。</p><div class="language- line-numbers-mode" data-highlighter="shiki" data-ext="" data-title="" style="--shiki-light:#24292e;--shiki-dark:#abb2bf;--shiki-light-bg:#fff;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes github-light one-dark-pro vp-code"><code><span class="line"><span>netstat -anpt | grep SYN_RECV | wc -l</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div></div></div><h4 id="_2-设置半连接队列大小" tabindex="-1"><a class="header-anchor" href="#_2-设置半连接队列大小"><span>2. 设置半连接队列大小</span></a></h4><p>半连接队列的大小取决于 <code>max(64, /proc/sys/net/ipv4/tcp_max_syn_backlog)</code></p><h3 id="五、队列溢出" tabindex="-1"><a class="header-anchor" href="#五、队列溢出"><span>五、队列溢出</span></a></h3><h4 id="_1-查看队列溢出" tabindex="-1"><a class="header-anchor" href="#_1-查看队列溢出"><span>1. 查看队列溢出</span></a></h4><div class="language- line-numbers-mode" data-highlighter="shiki" data-ext="" data-title="" style="--shiki-light:#24292e;--shiki-dark:#abb2bf;--shiki-light-bg:#fff;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes github-light one-dark-pro vp-code"><code><span class="line"><span># netstat -s | egrep -i &quot;listen|LISTEN&quot;</span></span>
<span class="line"><span>		189088 times the listen queue of a socket overflowed </span></span>
<span class="line"><span>    30140232 SYNs to LISTEN sockets dropped</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><ul><li>overflowed：表示全连接队列溢出的次数</li><li>sockets dropped：表示半连接队列溢出的次数</li></ul><h4 id="_2-全连接队列溢出" tabindex="-1"><a class="header-anchor" href="#_2-全连接队列溢出"><span>2. 全连接队列溢出</span></a></h4><p>全连接队列满了之后丢弃请求是默认行为，可以通过设置服务端在全连接队列满的时候，向客户端发送 RST 报文。参数 <code>tcpabort_on_overflow</code> 有两种可选值：</p><ul><li>0：如果全连接队列满了，服务端丢弃客户端的请求</li><li>1：如果全连接队列满了，服务端向客户端发送 RST 报文，终止 TCP socket 连接</li></ul><p>全连接队列溢出时，客户端连接不上服务端：</p><ul><li>当 <code>tcpabort_on_overflow=0</code> 时，服务端会丢掉客户端发送的 ACK（三次握手中第三次客户端向服务端回复的 ACK），而处于 ESTABLISHED 状态的客户端会重发 ACK 请求，如果服务端只是短暂繁忙造成的 accept 队列满。那么当有空位时，服务端收到 ACK 请求后可以成功建立连接</li><li>当 <code>tcpabort_on_overflow=1</code> 时，那么客户端会看到很多 <code>connection reset by perr</code> 的错误，这样可以将溢出尽快通知客户端</li></ul><p>通常情况下，应当把 <code>tcpabort_on_overflow</code> 设置为 0，因为这样更有利于应对突发流量，提高连接建立的成功率。而将 <code>tcpabort_on_overflow</code> 设置为 1，可以尽快通知客户端。</p><h4 id="_3-半连接队列溢出" tabindex="-1"><a class="header-anchor" href="#_3-半连接队列溢出"><span>3. 半连接队列溢出</span></a></h4><p>半连接队列满了，一般默认情况下会丢弃</p><h3 id="六、防御-syn-攻击" tabindex="-1"><a class="header-anchor" href="#六、防御-syn-攻击"><span>六、防御 SYN 攻击</span></a></h3><ul><li><strong>增大半连接队列</strong>：可以增大 <code>tcp_max_syn_backlog</code> 的值，同时也要增大全连接队列，也就是需要增大 <code>somaxconn</code> 和 <code>backlog</code></li><li><strong>开启 tcp_syncookies 功能</strong>：可以在不使用 SYN 半连接队列的情况下成功建立连接。<code>tcp_syncookies</code> 参数主要有三个值： <ul><li>0 值：表示关闭该功能</li><li>1 值：表示仅当 SYN 半连接队列放不下时，再启用他</li><li>2 值：表示无条件开启此功能</li></ul></li><li><strong>减少 SYN+ACK 重传次数</strong>：服务端受到 SYN 攻击时，会有大量处于 <code>SYN_RECV</code> 状态的 TCP 连接，处于这个状态的 TCP 会重传 <code>SYN+ACK</code>。如果减少 <code>SYN+ACK</code> 的重传次数，可以加快处于 <code>SYN_RECV</code> 状态的 TCP 连接断开。</li></ul>`,42)]))}const h=s(t,[["render",o],["__file","3.socket与三次握手四次挥手.html.vue"]]),E=JSON.parse('{"path":"/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E4%B8%83%E5%B1%82%E6%A8%A1%E5%9E%8B/%E4%BC%A0%E8%BE%93%E5%B1%82/%E6%8A%80%E6%9C%AF%E5%8E%9F%E7%90%86/3.socket%E4%B8%8E%E4%B8%89%E6%AC%A1%E6%8F%A1%E6%89%8B%E5%9B%9B%E6%AC%A1%E6%8C%A5%E6%89%8B.html","title":"3.socket与三次握手四次挥手","lang":"zh-CN","frontmatter":{"title":"3.socket与三次握手四次挥手","description":"本文我们结合 TCP 的三次握手、四次挥手，来谈一谈 socket 相关的系统调用。 一、socket 系统调用 socket() ：负责产生一个套接字的描述符 bind()：将创建好的 socket 与地址（IP 以及端口）绑定 listen()：为接收用户请求做好就绪准备，比如初始化好半连接队列、全连接队列。listen 的第二个参数 backlo...","head":[["meta",{"property":"og:url","content":"https://noahyz.github.io/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E4%B8%83%E5%B1%82%E6%A8%A1%E5%9E%8B/%E4%BC%A0%E8%BE%93%E5%B1%82/%E6%8A%80%E6%9C%AF%E5%8E%9F%E7%90%86/3.socket%E4%B8%8E%E4%B8%89%E6%AC%A1%E6%8F%A1%E6%89%8B%E5%9B%9B%E6%AC%A1%E6%8C%A5%E6%89%8B.html"}],["meta",{"property":"og:site_name","content":"noahyz的博客"}],["meta",{"property":"og:title","content":"3.socket与三次握手四次挥手"}],["meta",{"property":"og:description","content":"本文我们结合 TCP 的三次握手、四次挥手，来谈一谈 socket 相关的系统调用。 一、socket 系统调用 socket() ：负责产生一个套接字的描述符 bind()：将创建好的 socket 与地址（IP 以及端口）绑定 listen()：为接收用户请求做好就绪准备，比如初始化好半连接队列、全连接队列。listen 的第二个参数 backlo..."}],["meta",{"property":"og:type","content":"article"}],["meta",{"property":"og:locale","content":"zh-CN"}],["meta",{"property":"article:author","content":"noahyz"}],["script",{"type":"application/ld+json"},"{\\"@context\\":\\"https://schema.org\\",\\"@type\\":\\"Article\\",\\"headline\\":\\"3.socket与三次握手四次挥手\\",\\"image\\":[\\"\\"],\\"dateModified\\":null,\\"author\\":[{\\"@type\\":\\"Person\\",\\"name\\":\\"noahyz\\",\\"url\\":\\"/about-the-author/\\"}]}"]]},"headers":[{"level":3,"title":"一、socket 系统调用","slug":"一、socket-系统调用","link":"#一、socket-系统调用","children":[]},{"level":3,"title":"二、三次握手过程","slug":"二、三次握手过程","link":"#二、三次握手过程","children":[]},{"level":3,"title":"三、全连接队列","slug":"三、全连接队列","link":"#三、全连接队列","children":[]},{"level":3,"title":"四、半连接队列","slug":"四、半连接队列","link":"#四、半连接队列","children":[]},{"level":3,"title":"五、队列溢出","slug":"五、队列溢出","link":"#五、队列溢出","children":[]},{"level":3,"title":"六、防御 SYN 攻击","slug":"六、防御-syn-攻击","link":"#六、防御-syn-攻击","children":[]}],"git":{},"readingTime":{"minutes":5.42,"words":1625},"filePathRelative":"计算机网络/七层模型/传输层/技术原理/3.socket与三次握手四次挥手.md","excerpt":"<p>本文我们结合 TCP 的三次握手、四次挥手，来谈一谈 socket 相关的系统调用。</p>\\n<h3>一、socket 系统调用</h3>\\n<p><code>socket()</code> ：负责产生一个套接字的描述符</p>\\n<p><code>bind()</code>：将创建好的 socket 与地址（IP 以及端口）绑定</p>\\n<p><code>listen()</code>：为接收用户请求做好就绪准备，比如初始化好半连接队列、全连接队列。listen 的第二个参数 backlog 与全连接队列的最大长度有关。</p>\\n<p><code>accept()</code>：一般情况下，如果没有请求到来，那么服务器会阻塞在 accept 函数上。当有请求时，也就是全连接队列中有已经就绪的连接时，他会返回一个新的描述符。这个新的描述符代表可以与客户端通信的 TCP 连接。</p>","autoDesc":true}');export{h as comp,E as data};

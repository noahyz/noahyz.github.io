import{_ as n}from"./plugin-vue_export-helper-DlAUqK2U.js";import{c as a,a as t,o as s}from"./app-D1zlwylF.js";const i={};function r(l,e){return s(),a("div",null,e[0]||(e[0]=[t(`<h3 id="一、extern-的由来" tabindex="-1"><a class="header-anchor" href="#一、extern-的由来"><span>一、extern 的由来</span></a></h3><p>编译器一般采用按文件编译的方式，因此在编译时，各个文件中定义的全局变量是互相不可见的。也就是说，在编译期间，全局变量的可见域限制在文件内部。如下</p><div class="language- line-numbers-mode" data-highlighter="shiki" data-ext="" data-title="" style="--shiki-light:#24292e;--shiki-dark:#abb2bf;--shiki-light-bg:#fff;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes github-light one-dark-pro vp-code"><code><span class="line"><span>// a.cpp</span></span>
<span class="line"><span>int val;</span></span>
<span class="line"><span>int main() {}</span></span>
<span class="line"><span></span></span>
<span class="line"><span>// b.cpp</span></span>
<span class="line"><span>int val;</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>编译没有问题，但是链接时会出现问题，重复定义。</p><p>在链接阶段，各个文件的内容（编译产生的 obj 文件）是被合并到一起的。因而，定义于某文件内的全局变量，在链接完成后，他的可见范围被扩大到整个程序。</p><p>extern 的作用就是告诉编译器：“你现在编译的文件中，有一个标识符虽然没有在本文件中定义，但是他是在别的文件中定义的全局变量，你可以使用”。</p><p>extern 不仅可以修饰变量，也可以修饰函数声明</p><h3 id="二、extern-修饰函数声明" tabindex="-1"><a class="header-anchor" href="#二、extern-修饰函数声明"><span>二、extern 修饰函数声明</span></a></h3><p>从本质上讲，变量和函数没有区别。函数名是指向函数二进制开头处的指针。</p><p>对模块中函数的引用，最常用的方法是包含这些函数声明的头文件；也可以使用 extern 的方式。想引用那个函数就用 extern 声明那个函数。这大概是 KISS 原则的一种体现。这样做的一个明显的好处是，可以加速程序的编译（确切的说是预处理）的过程，节省时间。</p><p>使用 <code>extern &quot;C&quot;</code> 也可以实现 C 和 C++ 的混合编程</p><p>c++ 中默认定义了 <code>__cplusplus</code>，C 语言没有该定义。即用来识别是 C 代码和 C++ 代码。</p><p>使用 <code>extern &quot;C&quot;</code> 会让 C++ 编译器按照 C 的编译格式来编译。</p>`,13)]))}const d=n(i,[["render",r],["__file","14.extern的详解.html.vue"]]),o=JSON.parse('{"path":"/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/c__%E8%AF%AD%E8%A8%80/%E5%9F%BA%E7%A1%80%E8%AF%AD%E6%B3%95/14.extern%E7%9A%84%E8%AF%A6%E8%A7%A3.html","title":"14.extern的详解","lang":"zh-CN","frontmatter":{"title":"14.extern的详解","date":"2023-01-19T11:11:41.000Z","tags":["linux"],"description":"一、extern 的由来 编译器一般采用按文件编译的方式，因此在编译时，各个文件中定义的全局变量是互相不可见的。也就是说，在编译期间，全局变量的可见域限制在文件内部。如下 编译没有问题，但是链接时会出现问题，重复定义。 在链接阶段，各个文件的内容（编译产生的 obj 文件）是被合并到一起的。因而，定义于某文件内的全局变量，在链接完成后，他的可见范围被扩...","head":[["meta",{"property":"og:url","content":"https://noahyz.github.io/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/c__%E8%AF%AD%E8%A8%80/%E5%9F%BA%E7%A1%80%E8%AF%AD%E6%B3%95/14.extern%E7%9A%84%E8%AF%A6%E8%A7%A3.html"}],["meta",{"property":"og:site_name","content":"noahyz的博客"}],["meta",{"property":"og:title","content":"14.extern的详解"}],["meta",{"property":"og:description","content":"一、extern 的由来 编译器一般采用按文件编译的方式，因此在编译时，各个文件中定义的全局变量是互相不可见的。也就是说，在编译期间，全局变量的可见域限制在文件内部。如下 编译没有问题，但是链接时会出现问题，重复定义。 在链接阶段，各个文件的内容（编译产生的 obj 文件）是被合并到一起的。因而，定义于某文件内的全局变量，在链接完成后，他的可见范围被扩..."}],["meta",{"property":"og:type","content":"article"}],["meta",{"property":"og:locale","content":"zh-CN"}],["meta",{"property":"article:author","content":"noahyz"}],["meta",{"property":"article:tag","content":"linux"}],["meta",{"property":"article:published_time","content":"2023-01-19T11:11:41.000Z"}],["script",{"type":"application/ld+json"},"{\\"@context\\":\\"https://schema.org\\",\\"@type\\":\\"Article\\",\\"headline\\":\\"14.extern的详解\\",\\"image\\":[\\"\\"],\\"datePublished\\":\\"2023-01-19T11:11:41.000Z\\",\\"dateModified\\":null,\\"author\\":[{\\"@type\\":\\"Person\\",\\"name\\":\\"noahyz\\",\\"url\\":\\"/about-the-author/\\"}]}"]]},"headers":[{"level":3,"title":"一、extern 的由来","slug":"一、extern-的由来","link":"#一、extern-的由来","children":[]},{"level":3,"title":"二、extern 修饰函数声明","slug":"二、extern-修饰函数声明","link":"#二、extern-修饰函数声明","children":[]}],"git":{},"readingTime":{"minutes":1.54,"words":461},"filePathRelative":"编程语言/c++语言/基础语法/14.extern的详解.md","localizedDate":"2023年1月19日","excerpt":"<h3>一、extern 的由来</h3>\\n<p>编译器一般采用按文件编译的方式，因此在编译时，各个文件中定义的全局变量是互相不可见的。也就是说，在编译期间，全局变量的可见域限制在文件内部。如下</p>\\n<div class=\\"language- line-numbers-mode\\" data-highlighter=\\"shiki\\" data-ext=\\"\\" data-title=\\"\\" style=\\"--shiki-light:#24292e;--shiki-dark:#abb2bf;--shiki-light-bg:#fff;--shiki-dark-bg:#282c34\\"><pre class=\\"shiki shiki-themes github-light one-dark-pro vp-code\\"><code><span class=\\"line\\"><span>// a.cpp</span></span>\\n<span class=\\"line\\"><span>int val;</span></span>\\n<span class=\\"line\\"><span>int main() {}</span></span>\\n<span class=\\"line\\"><span></span></span>\\n<span class=\\"line\\"><span>// b.cpp</span></span>\\n<span class=\\"line\\"><span>int val;</span></span></code></pre>\\n<div class=\\"line-numbers\\" aria-hidden=\\"true\\" style=\\"counter-reset:line-number 0\\"><div class=\\"line-number\\"></div><div class=\\"line-number\\"></div><div class=\\"line-number\\"></div><div class=\\"line-number\\"></div><div class=\\"line-number\\"></div><div class=\\"line-number\\"></div></div></div>","autoDesc":true}');export{d as comp,o as data};

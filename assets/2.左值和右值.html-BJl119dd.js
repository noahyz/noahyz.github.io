import{_ as n}from"./plugin-vue_export-helper-DlAUqK2U.js";import{c as a,a as e,o as i}from"./app-D1zlwylF.js";const l="/assets/C__%E8%A1%A8%E8%BE%BE%E5%BC%8F%E7%9A%84%E5%80%BC%E7%B1%BB%E5%88%AB-CxjtlJip.png",p={};function t(r,s){return i(),a("div",null,s[0]||(s[0]=[e('<h4 id="左值和右值" tabindex="-1"><a class="header-anchor" href="#左值和右值"><span>左值和右值</span></a></h4><figure><img src="'+l+`" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure><ul><li>lvalue：通常是可以放在等号左边的表达式，左值</li><li>rvalue：通常是只能放在等号右边的表达式，右值</li><li>glvalue：是 generalized lvalue，广义左值</li><li>xvalue：是 expiring lvalue，将亡值</li><li>prvalue：是 pure rvalue，纯右值</li></ul><div class="language- line-numbers-mode" data-highlighter="shiki" data-ext="" data-title="" style="--shiki-light:#24292e;--shiki-dark:#abb2bf;--shiki-light-bg:#fff;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes github-light one-dark-pro vp-code"><code><span class="line"><span>左值 lvalue 是有标识符、可以取地址的表达式，最常见的情况有：</span></span>
<span class="line"><span>1. 变量、函数或数据成员的名字</span></span>
<span class="line"><span>2. 返回左值引用的表达式，如 ++x、x = 1、count &lt;&lt; &#39; &#39;</span></span>
<span class="line"><span>3. 字符串字面量如：&quot;hello world&quot;</span></span>
<span class="line"><span>在函数调用时，左值可以绑定到左值引用的参数，如T&amp;。一个常量只能绑定到常左值引用，如 const T&amp;</span></span>
<span class="line"><span></span></span>
<span class="line"><span>纯右值 prvalue 是没有标识符、不可以取地址的表达式，一般也称为“临时对象”，最常见的情况有：</span></span>
<span class="line"><span>1. 返回非引用类型的表达式，如 x++、x+1、make_shared&lt;int&gt;(42)</span></span>
<span class="line"><span>2. 除字符串字面量之外的字面量，如 42、true</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><div class="language- line-numbers-mode" data-highlighter="shiki" data-ext="" data-title="" style="--shiki-light:#24292e;--shiki-dark:#abb2bf;--shiki-light-bg:#fff;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes github-light one-dark-pro vp-code"><code><span class="line"><span>template &lt;typename T&gt; </span></span>
<span class="line"><span>smart_ptr(smart_ptr&lt;T&gt;&amp;&amp; other) noexcept {</span></span>
<span class="line"><span>	ptr_ = other.ptr_;</span></span>
<span class="line"><span>}</span></span>
<span class="line"><span>如上，函数中变量 other 是一个左值，other 是个变量的名字，变量有标识符、有地址。类型是右值引用的变量是一个左值</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><div class="language- line-numbers-mode" data-highlighter="shiki" data-ext="" data-title="" style="--shiki-light:#24292e;--shiki-dark:#abb2bf;--shiki-light-bg:#fff;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes github-light one-dark-pro vp-code"><code><span class="line"><span>smart_ptr&lt;shape&gt; ptr1{ new circle(); }</span></span>
<span class="line"><span>new circle() 是一个纯右值，但对于指针，通常使用值传递，并不关心他是左值还是右值</span></span>
<span class="line"><span></span></span>
<span class="line"><span>smart_ptr&lt;shape&gt; ptr2 = std::move(ptr1);</span></span>
<span class="line"><span>std::move(ptr) 的作用就是把一个左值引用强制转换成一个右值引用，而并不改变其内容。因此 std::move(ptr1) 的结果是指向 ptr1 的一个右值引用。std::move(ptr) 是一个有名字的右值，就叫做 xvalue 将亡值，xvalue 是不能取地址的。</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h4 id="生命周期和表达式类型" tabindex="-1"><a class="header-anchor" href="#生命周期和表达式类型"><span>生命周期和表达式类型</span></a></h4><p>临时对象(prvalue)的生命周期。C++的规则是：一个临时对象会在包含这个临时对象的完整表达式估值完成后、按生成顺序的逆序被销毁，除非有生命周期延长发生。</p><div class="language- line-numbers-mode" data-highlighter="shiki" data-ext="" data-title="" style="--shiki-light:#24292e;--shiki-dark:#abb2bf;--shiki-light-bg:#fff;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes github-light one-dark-pro vp-code"><code><span class="line"><span>class shape {</span></span>
<span class="line"><span>public:</span></span>
<span class="line"><span>	virtual ~shape() {}</span></span>
<span class="line"><span>};</span></span>
<span class="line"><span></span></span>
<span class="line"><span>class circle : public shape {</span></span>
<span class="line"><span>public:</span></span>
<span class="line"><span>	circle() { puts(&quot;circle()&quot;); }</span></span>
<span class="line"><span>	~circle() { puts(&quot;~circle()&quot;); }</span></span>
<span class="line"><span>};</span></span>
<span class="line"><span></span></span>
<span class="line"><span>class triangle : public shape {</span></span>
<span class="line"><span>public: </span></span>
<span class="line"><span>	triangle() { puts(&quot;triangle()&quot;); }</span></span>
<span class="line"><span>	~triangle() { puts(&quot;~triangle()&quot;); }</span></span>
<span class="line"><span>};</span></span>
<span class="line"><span></span></span>
<span class="line"><span>class result {</span></span>
<span class="line"><span>public: </span></span>
<span class="line"><span>	result() { puts(&quot;result()&quot;); }</span></span>
<span class="line"><span>	~result() { puts(&quot;~result()&quot;); }</span></span>
<span class="line"><span>};</span></span>
<span class="line"><span></span></span>
<span class="line"><span>result process_shape(const shape&amp; shape1, const shape&amp; shape2) {</span></span>
<span class="line"><span>	puts(&quot;Process_shape()&quot;);</span></span>
<span class="line"><span>	return result();</span></span>
<span class="line"><span>}</span></span>
<span class="line"><span></span></span>
<span class="line"><span>int main() {</span></span>
<span class="line"><span>	puts(&quot;main()&quot;);</span></span>
<span class="line"><span>	process_shape(circle(), triganle());</span></span>
<span class="line"><span>	puts(&quot;something else&quot;);</span></span>
<span class="line"><span>}</span></span>
<span class="line"><span>// 执行结果</span></span>
<span class="line"><span>main()</span></span>
<span class="line"><span>circle()</span></span>
<span class="line"><span>triangle()</span></span>
<span class="line"><span>process_shape()</span></span>
<span class="line"><span>result()</span></span>
<span class="line"><span>~result()</span></span>
<span class="line"><span>~triangle()</span></span>
<span class="line"><span>~circle()</span></span>
<span class="line"><span>something else</span></span>
<span class="line"><span></span></span>
<span class="line"><span>main()</span></span>
<span class="line"><span>triangle()</span></span>
<span class="line"><span>circle()</span></span>
<span class="line"><span>Process_shape()</span></span>
<span class="line"><span>result()</span></span>
<span class="line"><span>~result()</span></span>
<span class="line"><span>~circle()</span></span>
<span class="line"><span>~triangle()</span></span>
<span class="line"><span>something else</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>如果一个 prvalue 被绑定到一个引用上，它的生命周期则会延长到跟这个引用变量一样长。需要注意的是，这条生命周期延长规则只对 纯右值 prvalue 有效，而对 xvalue 无效。</p><h4 id="如何实现移动" tabindex="-1"><a class="header-anchor" href="#如何实现移动"><span>如何实现移动</span></a></h4><ol><li>你的对象应该有分开的拷贝构造和移动构造函数，除非你只打算支持移动，不支持拷贝</li><li>你的对象应该有 swap 成员函数，支持和另外一个对象快速交换成员</li><li>在你的对象命名空间下，应当有一个全局的 swap 函数，调用成员函数 swap 来实现交换。支持这种用法会方便别人(包括你自己在将来)在其他对象里包含你的对象，并快速实现他们的 swap 函数</li><li>实现通用的 operator=</li><li>上面的各个函数如果不抛异常的话，应当标为 noexcept。这对移动构造函数尤为重要</li></ol><h4 id="不要返回本地变量的引用" tabindex="-1"><a class="header-anchor" href="#不要返回本地变量的引用"><span>不要返回本地变量的引用</span></a></h4><p>在函数中返回一个本地对象的引用，由于函数结束时本地对象即将被销毁，返回一个指向本地对象的引用属于未定义行为</p><div class="language- line-numbers-mode" data-highlighter="shiki" data-ext="" data-title="" style="--shiki-light:#24292e;--shiki-dark:#abb2bf;--shiki-light-bg:#fff;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes github-light one-dark-pro vp-code"><code><span class="line"><span>在C++11之前，返回一个本地对象意味着这个对象会被拷贝，除非编译器发现可以做返回值优化(named return value optimization, 或 NRVO)，能把对象直接构造到调用者的栈上。从C++11开始，返回值的优化仍可以发生，但在没有返回值优化的情况下，编译器将试图把本地对象移动出去，而不是拷贝出去。这一行为不需要程序猿手工 std::move 进行干预。如果使用 std::move 对于移动行为没有帮助，反而会影响返回值的优化，多调用一次移动构造。</span></span>
<span class="line"><span>如果返回有分支，编译器没法优化，就不会有NRVO，不会直接构造到调用者的栈上。</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div></div></div><h4 id="引用坍缩和完美转发" tabindex="-1"><a class="header-anchor" href="#引用坍缩和完美转发"><span>引用坍缩和完美转发</span></a></h4><p>对于泛型编程：</p><ol><li>对于 T&amp; ，一定是个左值引用</li><li>对于 T&amp;&amp; ，不一定是右值引用</li></ol><div class="language- line-numbers-mode" data-highlighter="shiki" data-ext="" data-title="" style="--shiki-light:#24292e;--shiki-dark:#abb2bf;--shiki-light-bg:#fff;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes github-light one-dark-pro vp-code"><code><span class="line"><span>对于 template&lt;typename T&gt; foo(T&amp;&amp;) 这样的代码，如果传递过去的参数是左值，T 的推导结果是左值引用；如果传递过去的参数是右值，T 的推导结果是参数的类型本身</span></span>
<span class="line"><span>如果 T 是左值引用，那 T&amp;&amp; 的结果仍然是左值引用，即 type&amp;&amp;&amp; 坍缩成 type&amp; </span></span>
<span class="line"><span>如果 T 是一个实际类型，那 T&amp;&amp; 的结果自然是一个右值引用</span></span>
<span class="line"><span></span></span>
<span class="line"><span>在 T 是模版参数时，T&amp;&amp; 的作用主要是保持值类别进行转发，它有个名字就叫“转发引用”。因为既可以是左值引用，也可以是右值引用，它也曾被叫做“万能引用”。</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>如何解决呢 T&amp;&amp; 的这个问题呢？保证它一定是个右值</p><div class="language- line-numbers-mode" data-highlighter="shiki" data-ext="" data-title="" style="--shiki-light:#24292e;--shiki-dark:#abb2bf;--shiki-light-bg:#fff;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes github-light one-dark-pro vp-code"><code><span class="line"><span>很多标准库的函数，连目标的参数类型都不知道，但我们仍然需要能够保持参数的值类别：左值仍然是左值，右值的仍然是右值。可以使用 std::forward 来实现</span></span>
<span class="line"><span></span></span>
<span class="line"><span>template &lt;typename T&gt;</span></span>
<span class="line"><span>void bar(T&amp;&amp; s) {</span></span>
<span class="line"><span>	foo(std::forward&lt;T&gt;(s)); // 加上 std::forward 这个对象 s 一定是一个右值。不加的时候可能会是左值。</span></span>
<span class="line"><span>}</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div>`,21)]))}const v=n(p,[["render",t],["__file","2.左值和右值.html.vue"]]),u=JSON.parse(`{"path":"/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/c__%E8%AF%AD%E8%A8%80/%E5%9F%BA%E7%A1%80%E8%AF%AD%E6%B3%95/2.%E5%B7%A6%E5%80%BC%E5%92%8C%E5%8F%B3%E5%80%BC.html","title":"2.左值和右值","lang":"zh-CN","frontmatter":{"title":"2.左值和右值","date":"2023-01-19T11:11:41.000Z","tags":["linux"],"description":"左值和右值 lvalue：通常是可以放在等号左边的表达式，左值 rvalue：通常是只能放在等号右边的表达式，右值 glvalue：是 generalized lvalue，广义左值 xvalue：是 expiring lvalue，将亡值 prvalue：是 pure rvalue，纯右值 生命周期和表达式类型 临时对象(prvalue)的生命周期。...","head":[["meta",{"property":"og:url","content":"https://noahyz.github.io/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/c__%E8%AF%AD%E8%A8%80/%E5%9F%BA%E7%A1%80%E8%AF%AD%E6%B3%95/2.%E5%B7%A6%E5%80%BC%E5%92%8C%E5%8F%B3%E5%80%BC.html"}],["meta",{"property":"og:site_name","content":"noahyz的博客"}],["meta",{"property":"og:title","content":"2.左值和右值"}],["meta",{"property":"og:description","content":"左值和右值 lvalue：通常是可以放在等号左边的表达式，左值 rvalue：通常是只能放在等号右边的表达式，右值 glvalue：是 generalized lvalue，广义左值 xvalue：是 expiring lvalue，将亡值 prvalue：是 pure rvalue，纯右值 生命周期和表达式类型 临时对象(prvalue)的生命周期。..."}],["meta",{"property":"og:type","content":"article"}],["meta",{"property":"og:locale","content":"zh-CN"}],["meta",{"property":"article:author","content":"noahyz"}],["meta",{"property":"article:tag","content":"linux"}],["meta",{"property":"article:published_time","content":"2023-01-19T11:11:41.000Z"}],["script",{"type":"application/ld+json"},"{\\"@context\\":\\"https://schema.org\\",\\"@type\\":\\"Article\\",\\"headline\\":\\"2.左值和右值\\",\\"image\\":[\\"\\"],\\"datePublished\\":\\"2023-01-19T11:11:41.000Z\\",\\"dateModified\\":null,\\"author\\":[{\\"@type\\":\\"Person\\",\\"name\\":\\"noahyz\\",\\"url\\":\\"/about-the-author/\\"}]}"]]},"headers":[],"git":{},"readingTime":{"minutes":4.81,"words":1442},"filePathRelative":"编程语言/c++语言/基础语法/2.左值和右值.md","localizedDate":"2023年1月19日","excerpt":"<h4>左值和右值</h4>\\n<figure><figcaption></figcaption></figure>\\n<ul>\\n<li>lvalue：通常是可以放在等号左边的表达式，左值</li>\\n<li>rvalue：通常是只能放在等号右边的表达式，右值</li>\\n<li>glvalue：是 generalized lvalue，广义左值</li>\\n<li>xvalue：是 expiring lvalue，将亡值</li>\\n<li>prvalue：是 pure rvalue，纯右值</li>\\n</ul>\\n<div class=\\"language- line-numbers-mode\\" data-highlighter=\\"shiki\\" data-ext=\\"\\" data-title=\\"\\" style=\\"--shiki-light:#24292e;--shiki-dark:#abb2bf;--shiki-light-bg:#fff;--shiki-dark-bg:#282c34\\"><pre class=\\"shiki shiki-themes github-light one-dark-pro vp-code\\"><code><span class=\\"line\\"><span>左值 lvalue 是有标识符、可以取地址的表达式，最常见的情况有：</span></span>\\n<span class=\\"line\\"><span>1. 变量、函数或数据成员的名字</span></span>\\n<span class=\\"line\\"><span>2. 返回左值引用的表达式，如 ++x、x = 1、count &lt;&lt; ' '</span></span>\\n<span class=\\"line\\"><span>3. 字符串字面量如：\\"hello world\\"</span></span>\\n<span class=\\"line\\"><span>在函数调用时，左值可以绑定到左值引用的参数，如T&amp;。一个常量只能绑定到常左值引用，如 const T&amp;</span></span>\\n<span class=\\"line\\"><span></span></span>\\n<span class=\\"line\\"><span>纯右值 prvalue 是没有标识符、不可以取地址的表达式，一般也称为“临时对象”，最常见的情况有：</span></span>\\n<span class=\\"line\\"><span>1. 返回非引用类型的表达式，如 x++、x+1、make_shared&lt;int&gt;(42)</span></span>\\n<span class=\\"line\\"><span>2. 除字符串字面量之外的字面量，如 42、true</span></span></code></pre>\\n<div class=\\"line-numbers\\" aria-hidden=\\"true\\" style=\\"counter-reset:line-number 0\\"><div class=\\"line-number\\"></div><div class=\\"line-number\\"></div><div class=\\"line-number\\"></div><div class=\\"line-number\\"></div><div class=\\"line-number\\"></div><div class=\\"line-number\\"></div><div class=\\"line-number\\"></div><div class=\\"line-number\\"></div><div class=\\"line-number\\"></div></div></div>","autoDesc":true}`);export{v as comp,u as data};

import{_ as a}from"./plugin-vue_export-helper-DlAUqK2U.js";import{c as t,a as i,o as l}from"./app-D1zlwylF.js";const p="/assets/CPU%E5%A4%96%E9%83%A8%E4%B8%AD%E6%96%AD%E7%B1%BB%E5%9E%8B-D2pBwfUg.png",n="/assets/%E4%BB%BB%E5%8A%A1%E9%97%A8%E6%8F%8F%E8%BF%B0%E7%AC%A6-C3Ct28zt.png",s="/assets/%E4%B8%AD%E6%96%AD%E9%97%A8%E6%8F%8F%E8%BF%B0%E7%AC%A6-CgRQujHy.png",r="/assets/%E9%99%B7%E9%98%B1%E9%97%A8%E6%8F%8F%E8%BF%B0%E7%AC%A6-D0nD-to0.png",o="/assets/%E8%B0%83%E7%94%A8%E9%97%A8%E6%8F%8F%E8%BF%B0%E7%AC%A6-zZFDxhZm.png",c="/assets/%E4%B8%AD%E6%96%AD%E6%8F%8F%E8%BF%B0%E7%AC%A6%E8%A1%A8%E5%AF%84%E5%AD%98%E5%99%A8-CH_fEIdt.png",d="/assets/%E6%97%A0%E7%89%B9%E6%9D%83%E7%BA%A7%E6%97%B6%E4%B8%AD%E6%96%AD%E7%9A%84%E5%8E%8B%E6%A0%88%E6%83%85%E5%86%B5-BGlh6-85.png",h={};function E(u,e){return l(),t("div",null,e[0]||(e[0]=[i('<h2 id="中断" tabindex="-1"><a class="header-anchor" href="#中断"><span>中断</span></a></h2><h3 id="一、中断分类" tabindex="-1"><a class="header-anchor" href="#一、中断分类"><span>一、中断分类</span></a></h3><p>内部中断：来自 CPU 内部的中断。按中断是否正常来划分，分为“软中断” 和 “异常”</p><p>外部中断：来自 CPU 外部的中断。按是否导致宕机来划分，分为“可屏蔽中断” 和 “不可屏蔽中断”</p><h4 id="_1-外部中断" tabindex="-1"><a class="header-anchor" href="#_1-外部中断"><span>1. 外部中断</span></a></h4><p>外部的中断源必须是某个硬件。因此外部中断又称为硬件中断。</p><p>CPU 提供了两条信号线，分别是 INTR（INTeRrupt）和 NMI（Non Maskable Interrupt）。外部中断是通过这两根信号线通知 CPU 的。</p><figure><img src="'+p+'" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure><p>如下，所说的内容都是基于单核 CPU。</p><ul><li>从 INTR 引脚收到的中断不影响系统运行，可以随时处理，甚至 CPU 可以不处理，因为不影响 CPU 的运行</li><li>从 NMI 引脚收到的中断，影响CPU的运行，所以必须响应</li></ul><p>于是衍生出新的概念名词</p><ul><li>可屏蔽中断：通过 INTR 引脚引入 CPU 的，CPU 可以不理会。外部设备如网卡、硬盘发出的中断都是可屏蔽中断 <ul><li>因为不会让系统宕机，所以可以通过 eflags 寄存器中的 IF 位将所有这些外部设备的中断屏蔽</li><li>linux 中，CPU 处理这类中断时，会分为上半部和下半部，分开来处理。上半部是需要立即执行的部分，所以通常情况是只完成中断应答或硬件复位等重要紧迫的工作。而中断处理程序中那些不紧急的部分则被推迟到下半部中完成。比如网络中的数据到达网卡后，中断的上半部会将网卡缓冲区中的数据拷贝到内核缓冲区中；下半部则是 CPU 拿到网络数据后，处理数据的操作，这部分操作倒显得不那么紧急。</li></ul></li><li>不可屏蔽中断：通过 NMI 引脚引入 CPU 的，表示系统发生了致命的错误，比如：电源掉电、内存读写错误、总线奇偶校验错误。</li></ul><p>中断发起时，相应的中断向量号通过 NMI 或 INTR 引脚被送入 CPU，中断向量号是中断向量表或中断描述符表里的中断项的下标，CPU 根据此中断向量号在中断向量表或中断描述符表中检索对应的中断处理程序并执行。</p><p>不可屏蔽中断，一般都是硬件问题（物理上的问题），对于软件来说没有必要区分，分配一个中断向量号就足够了，因此不可屏蔽中断的中断向量号为 2。</p><h4 id="_2-内部中断" tabindex="-1"><a class="header-anchor" href="#_2-内部中断"><span>2. 内部中断</span></a></h4><p>分为软中断和异常。</p><p>软中断：由软件主动发起的中断，所以主观上，并不是客观上的某种内部错误</p><ul><li><code>int 8位立即数</code>：通过他进行系统调用，8位立即数可表示 256 种中断</li><li><code>int3</code>：他是调试断点指令，其所触发的中断向量号是 3</li><li><code>into</code>：中断溢出指令，触发的中断向量号为 4。能否引发 4 号中断是要看 elfags 标志寄存器中的 OF 位是否为 1，如果是 1 才会引发中断，否则指令什么都不做</li><li><code>bound</code>：检查数组索引越界指令，触发 5 号中断，用于检查数组的索引下标是否在上下边界之内。指令格式：<code>bound 16/32位寄存器 16/32位内存</code>，目的操作数是用寄存器来存储的，其内容是待检测的数组下标值。源操作数是内存，其内容是数组下标的下边界和上边界。</li><li><code>ud2</code>：未定义指令，触发 7 号中断。表示指令无效，CPU 无法识别</li></ul><p>以上几种软中断指令，除第一种的 “int 8位立即数” 之外，其他的几种又可以称为异常。异常是指令执行期间 CPU 内部产生的错误引起的。由于是运行时错误，所以他不受标志寄存器 eflags 中的 IF 位影响。只要中断关系到 “正常” 运行，就不受 IF 位影响。</p><p>异常按照轻重程序分为三种：</p><ul><li>Fault，也称为故障，可以被修复的一种类型，属于最轻的一种异常。当发生此类异常时 CPU 将机器状态恢复到异常之前的状态，之后调用中断处理程序时，CPU 将返回地址依然指向导致 Fault 异常的那条指令。通常中断处理程序会将此问题修复，待中断处理程序返回后便能充实。比如：缺页异常 Page fault。</li><li>Trap，也称为陷阱，此异常通常用于调试中，比如 int3 指令便能引发此类异常，为了让中断处理程序返回后能够继续向下执行，CPU 将中断处理程序的返回地址指向导致异常指令的下一个指令地址。</li><li>Abort，也称为终止，由于错误无法修复，程序将无法继续运行，操作系统为了自保，只能将程序从进程表中去掉。导致此异常的错误通常是硬件错误，或者某些系统数据结构出错。</li></ul><p>CPU 为了统一中断管理，把来自外部设备、内部指令的各种中断类型统统归结为一种管理方式，即为每个中断信号分配一个整数，用此整数作为中断的 ID，而这个整数就是中断向量，用此 ID 作为中断描述符表中的索引，就能找到对应的表项，进而找到对应的中断处理程序。</p><h3 id="二、中断描述符表" tabindex="-1"><a class="header-anchor" href="#二、中断描述符表"><span>二、中断描述符表</span></a></h3><p>中断描述符表（Interrupt Descriptor Table，IDT）是保护模式下用于存储中断处理程序入口的表。多提一句，实模式下，用于存储中断处理程序入口的表叫做中断向量表（Interrupt Vector Table，IVT）。</p><p>中断描述符表地址不限制，在哪里都可以；且每个描述符用 8 字节描述。</p><ul><li>各种门都属于系统段，所以 S 位等于 0。S 位表示系统段或数据段。</li><li>P 位要置 0，表示门描述符中的中断处理程序不在内存中。</li></ul><p>中断描述符表中的 “描述符” 也称为 “门”。 接下来我们看下不同种类的门描述符。</p><h4 id="_1-任务门描述符" tabindex="-1"><a class="header-anchor" href="#_1-任务门描述符"><span>1. 任务门描述符</span></a></h4><figure><img src="'+n+'" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure><p>任务门和任务状态段（Task Status Segment，TSS）是 Intel 处理器在硬件一级提供的任务切换机制，所以任务门需要和 TSS 配合在一起使用，在任务门中记录的是 TSS 选择子，偏移量未使用。任务门可以存在于全局描述符表 GDT、局部描述符表 LDT、中断描述符表 IDT 中。描述符中任务门的 type 值为二进制 0101。大多数操作系统（包括 Linux）都未用 TSS 实现任务切换，所以少关注</p><h4 id="_2-中断门描述符" tabindex="-1"><a class="header-anchor" href="#_2-中断门描述符"><span>2. 中断门描述符</span></a></h4><figure><img src="'+s+'" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure><p>中断门包含了中断处理程序所在段的段选择子和段内偏移地址。当通过此方式进入中断后，标志寄存器 eflags 中的 IF 位自动置 0，也就是在进入中断后，自动把中断关闭，避免中断嵌套。Linux 就是利用中断门实现的系统调用，就是那个著名的 <code>int 0x80</code>。中断门只允许存在于 IDT 中。描述符中中断门的 type 值为二进制 1110。</p><h4 id="_3-陷阱门描述符" tabindex="-1"><a class="header-anchor" href="#_3-陷阱门描述符"><span>3. 陷阱门描述符</span></a></h4><figure><img src="'+r+'" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure><p>陷阱门进入中断后，标志寄存器 eflags 中的 IF 位不会自动置 0，只允许存在于 IDT 中。描述符中陷阱门的 type 值为二进制 1111。</p><h4 id="_4-调用门描述符" tabindex="-1"><a class="header-anchor" href="#_4-调用门描述符"><span>4. 调用门描述符</span></a></h4><figure><img src="'+o+'" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure><p>调用门是提供给用户进程进入特权 0 级的方式，其 DPL 为 3。调用门中记录例程的地址，他不能用 int 指令调用，只能用 call 和 jmp 指令。调用门可以安装在 GDT 和 LDT 中。描述符中调用门的 type 值为二进制 1100。</p><h4 id="_5-中断描述符寄存器" tabindex="-1"><a class="header-anchor" href="#_5-中断描述符寄存器"><span>5. 中断描述符寄存器</span></a></h4><p>我们把精力放在中断门，像 Linux 那样，用它来实现系统调用。现代的操作系统很少用到调用门和任务门。</p><p>在门描述符中有个 P 位，将 P 位置 0 表示门描述符中的中断处理程序不在内存中。</p><p>在 CPU 中有个中断描述符表寄存器（Intrrupt Descriptor Table Register，IDTR），该寄存器分为两部分：</p><ul><li>第 0 - 15 位是表界限，即 IDT 大小减一。16 位表界限最大范围是 0xffff，可容纳的描述符个数是：<code>64KB / 8 = 8192</code> 个。并且第 0 个门描述符也可用（区别 GDT 中第 0 个描述符不可用）</li><li>第 16 - 47 位是 IDT 的基地址</li></ul><img src="'+c+'" alt="t" style="zoom:50%;"><p>使用指令 “ <code>lidt 48位内存数据</code>” 来加载 IDTR。</p><h3 id="三、中断处理过程以及保护" tabindex="-1"><a class="header-anchor" href="#三、中断处理过程以及保护"><span>三、中断处理过程以及保护</span></a></h3><p>完整的中断过程分为 CPU 外和 CPU 内两部分。</p><ul><li>CPU 外：外部设备的中断由中断代理芯片接收，处理后将该中断的中断向量号发送到 CPU</li><li>CPU 内：CPU 执行中断向量号对应的中断处理程序</li></ul><p>对应 CPU 内执行的操作，我们进行分解：</p><ul><li>CPU 根据中断向量号定位中断门描述符。中断向量号是中断描述符的索引，中断描述符是 8 个字节。因此 CPU 用中断向量号乘以 8 后，再与 IDTR 中的中断描述符表地址相加，所求的地址之和便是该中断向量号对应的中断描述符。</li><li>处理器进行特权级检查。</li></ul><h3 id="四、中断发生时的压栈" tabindex="-1"><a class="header-anchor" href="#四、中断发生时的压栈"><span>四、中断发生时的压栈</span></a></h3><p>中断门描述符中保存的是中断处理程序所在代码段的选择子及在段内偏移量，处理器从该描述符中加载目标代码段选择子到代码段寄存器 CS 及偏移量到指令指针寄存器 EIP 中。</p><p>注意：只要段寄存器被加载，段描述符缓冲寄存器就会被刷新，处理器都认为是换了一个段，属于段间转移，也就是远转移。</p><p>所以，当前进程被中断打断后，为了从中断返回后能继续运行该进程，处理器自动把 CS 和 EIP 的当前值保存到中断处理程序使用的栈中。不同特权级别下处理器使用不同的栈，至于中断处理程序使用的是那个栈，要视它当时所在的特权级别，因为中断是可以在任何特权级别下发生。</p><p>除了要保存 CS、EIP 外，还需要保存标志寄存器 eflags。如果涉及到特权级变化，还要压入 SS 和 ESP 寄存器。</p><h4 id="_1-无特权级变化时-中断的压栈情况" tabindex="-1"><a class="header-anchor" href="#_1-无特权级变化时-中断的压栈情况"><span>1. 无特权级变化时，中断的压栈情况</span></a></h4><img src="'+d+'" alt="s" style="zoom:70%;"><ul><li>处理器会自动压入 <code>eflags、cs、eip、错误码</code></li><li>我们手动压入 <code>ds、es、fs、gs</code> 段寄存器</li><li>我们手动压入通用寄存器，可以使用 pushad，可以按照顺序压入：<code>EAX、ECX、EDX、EBX、ESP、EBP、ESI、EDI</code> 这 8 个通用寄存器</li></ul>',59)]))}const C=a(h,[["render",E],["__file","1.中断.html.vue"]]),B=JSON.parse('{"path":"/%E6%8A%80%E6%9C%AF%E4%B8%93%E9%A2%98/%E6%89%8B%E5%86%99%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/3.%E4%B8%AD%E6%96%AD/1.%E4%B8%AD%E6%96%AD.html","title":"11.中断","lang":"zh-CN","frontmatter":{"title":"11.中断","description":"中断 一、中断分类 内部中断：来自 CPU 内部的中断。按中断是否正常来划分，分为“软中断” 和 “异常” 外部中断：来自 CPU 外部的中断。按是否导致宕机来划分，分为“可屏蔽中断” 和 “不可屏蔽中断” 1. 外部中断 外部的中断源必须是某个硬件。因此外部中断又称为硬件中断。 CPU 提供了两条信号线，分别是 INTR（INTeRrupt）和 NM...","head":[["meta",{"property":"og:url","content":"https://noahyz.github.io/%E6%8A%80%E6%9C%AF%E4%B8%93%E9%A2%98/%E6%89%8B%E5%86%99%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/3.%E4%B8%AD%E6%96%AD/1.%E4%B8%AD%E6%96%AD.html"}],["meta",{"property":"og:site_name","content":"noahyz的博客"}],["meta",{"property":"og:title","content":"11.中断"}],["meta",{"property":"og:description","content":"中断 一、中断分类 内部中断：来自 CPU 内部的中断。按中断是否正常来划分，分为“软中断” 和 “异常” 外部中断：来自 CPU 外部的中断。按是否导致宕机来划分，分为“可屏蔽中断” 和 “不可屏蔽中断” 1. 外部中断 外部的中断源必须是某个硬件。因此外部中断又称为硬件中断。 CPU 提供了两条信号线，分别是 INTR（INTeRrupt）和 NM..."}],["meta",{"property":"og:type","content":"article"}],["meta",{"property":"og:locale","content":"zh-CN"}],["meta",{"property":"article:author","content":"noahyz"}],["script",{"type":"application/ld+json"},"{\\"@context\\":\\"https://schema.org\\",\\"@type\\":\\"Article\\",\\"headline\\":\\"11.中断\\",\\"image\\":[\\"\\"],\\"dateModified\\":null,\\"author\\":[{\\"@type\\":\\"Person\\",\\"name\\":\\"noahyz\\",\\"url\\":\\"/about-the-author/\\"}]}"]]},"headers":[{"level":2,"title":"中断","slug":"中断","link":"#中断","children":[{"level":3,"title":"一、中断分类","slug":"一、中断分类","link":"#一、中断分类","children":[]},{"level":3,"title":"二、中断描述符表","slug":"二、中断描述符表","link":"#二、中断描述符表","children":[]},{"level":3,"title":"三、中断处理过程以及保护","slug":"三、中断处理过程以及保护","link":"#三、中断处理过程以及保护","children":[]},{"level":3,"title":"四、中断发生时的压栈","slug":"四、中断发生时的压栈","link":"#四、中断发生时的压栈","children":[]}]}],"git":{},"readingTime":{"minutes":9.58,"words":2873},"filePathRelative":"技术专题/手写操作系统/3.中断/1.中断.md","excerpt":"<h2>中断</h2>\\n<h3>一、中断分类</h3>\\n<p>内部中断：来自 CPU 内部的中断。按中断是否正常来划分，分为“软中断” 和 “异常”</p>\\n<p>外部中断：来自 CPU 外部的中断。按是否导致宕机来划分，分为“可屏蔽中断” 和 “不可屏蔽中断”</p>\\n<h4>1. 外部中断</h4>\\n<p>外部的中断源必须是某个硬件。因此外部中断又称为硬件中断。</p>\\n<p>CPU 提供了两条信号线，分别是 INTR（INTeRrupt）和 NMI（Non Maskable Interrupt）。外部中断是通过这两根信号线通知 CPU 的。</p>\\n<figure><figcaption></figcaption></figure>","autoDesc":true}');export{C as comp,B as data};

import{_ as n}from"./plugin-vue_export-helper-DlAUqK2U.js";import{c as a,a as s,o as i}from"./app-D1zlwylF.js";const l={};function t(d,e){return i(),a("div",null,e[0]||(e[0]=[s(`<h3 id="一、preload-失效原因" tabindex="-1"><a class="header-anchor" href="#一、preload-失效原因"><span>一、preload 失效原因</span></a></h3><h4 id="_1-rtld-deepbind-的使用" tabindex="-1"><a class="header-anchor" href="#_1-rtld-deepbind-的使用"><span>1. RTLD_DEEPBIND 的使用</span></a></h4><p>来自于：<a href="http://linux.die.net/man/3/dlopen" target="_blank" rel="noopener noreferrer">http://linux.die.net/man/3/dlopen</a></p><p>RTLD_DEEPBIND（自 glibc 2.3.4 起）将此库中符号的查找范围置于全局范围之前。这意味着自包含库将优先使用其自己的符号，而不是已加载库中包含的具有相同名称的全局符号。该标志未在 POSIX.1-2001 中指定。</p><p>可以使用 <code>LD_DEBUG=all</code> 查看链接的过程</p><h4 id="_2-通过静态链接的方式" tabindex="-1"><a class="header-anchor" href="#_2-通过静态链接的方式"><span>2. 通过静态链接的方式</span></a></h4><p>使用 <code>gcc -static</code> 参数可以把 <code>libc.so</code> 静态链接进执行程序中。但这也就意味着程序不再支持动态链接。</p><h3 id="_3-设置执行文件的-setgid-setuid-权限" tabindex="-1"><a class="header-anchor" href="#_3-设置执行文件的-setgid-setuid-权限"><span>3. 设置执行文件的 setgid/setuid 权限</span></a></h3><p>在有 SUID 权限的执行文件，系统会忽略 LD_PRELOAD 环境变量</p><h4 id="_4-内联方式" tabindex="-1"><a class="header-anchor" href="#_4-内联方式"><span>4. 内联方式</span></a></h4><p>编译器可能会某些函数进行了内联优化，并不会调用 so 库中的函数，因而通过优先加载自定义动态库的方式不可行。比如：strcmp 函数</p><p>一种解决方案：可以在编译测试程序时，添加 <code>-fno-builtin-strcmp</code> 关闭 strcmp 函数的优化</p><h3 id="_5-链接库的顺序" tabindex="-1"><a class="header-anchor" href="#_5-链接库的顺序"><span>5. 链接库的顺序</span></a></h3><p>当使用 dlsym 的 RTLD_NEXT 时，需要注意链接库的顺序。ld-linux 链接器也有 malloc、free 的实现，可能会存在 dlsym 查看到 ld-linux 内部实现的符号。</p><div class="language- line-numbers-mode" data-highlighter="shiki" data-ext="" data-title="" style="--shiki-light:#24292e;--shiki-dark:#abb2bf;--shiki-light-bg:#fff;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes github-light one-dark-pro vp-code"><code><span class="line"><span>void* func = dlsym(RTLD_NEXT, &quot;malloc&quot;);</span></span>
<span class="line"><span>Dl_info dl_info;</span></span>
<span class="line"><span>if (!dladdr(func, &amp;dl_info)) {</span></span>
<span class="line"><span>		// dladdr() failed </span></span>
<span class="line"><span>}</span></span>
<span class="line"><span>if (strstr(dl_info.dli_fname, &quot;ld-linux&quot;)) {</span></span>
<span class="line"><span>		// &#39;malloc&#39; is inside linker/loader</span></span>
<span class="line"><span>}</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>如果我们发现一个函数在 ld-linux 中，这时，没有直接的办法可以继续在所有其他库中搜索相同的函数名称。但是，如果您知道函数所在的特定库的名称，比如 <a href="http://libc.so" target="_blank" rel="noopener noreferrer">libc.so</a> 。则可以使用 dlopen 和 dlsym 来获取所需的指针。</p><div class="language- line-numbers-mode" data-highlighter="shiki" data-ext="" data-title="" style="--shiki-light:#24292e;--shiki-dark:#abb2bf;--shiki-light-bg:#fff;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes github-light one-dark-pro vp-code"><code><span class="line"><span>void* handle = dlopen(&quot;libc.so.6&quot;, RTLD_LAZY);</span></span>
<span class="line"><span>if (!handle) {</span></span>
<span class="line"><span>		// dlopen() failed</span></span>
<span class="line"><span>}</span></span>
<span class="line"><span>void* func = dlsym(handle, &quot;free&quot;);</span></span>
<span class="line"><span>if (!func) {</span></span>
<span class="line"><span>		// Bad! &#39;free&#39; was not found inside libc</span></span>
<span class="line"><span>}</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div>`,17)]))}const o=n(l,[["render",t],["__file","2.preload失效问题.html.vue"]]),c=JSON.parse('{"path":"/%E6%8A%80%E6%9C%AF%E4%B8%93%E9%A2%98/hook/2.preload%E5%A4%B1%E6%95%88%E9%97%AE%E9%A2%98.html","title":"2.preload失效问题","lang":"zh-CN","frontmatter":{"title":"2.preload失效问题","date":"2023-01-19T11:11:41.000Z","tags":["linux"],"description":"一、preload 失效原因 1. RTLD_DEEPBIND 的使用 来自于：http://linux.die.net/man/3/dlopen RTLD_DEEPBIND（自 glibc 2.3.4 起）将此库中符号的查找范围置于全局范围之前。这意味着自包含库将优先使用其自己的符号，而不是已加载库中包含的具有相同名称的全局符号。该标志未在 POSI...","head":[["meta",{"property":"og:url","content":"https://noahyz.github.io/%E6%8A%80%E6%9C%AF%E4%B8%93%E9%A2%98/hook/2.preload%E5%A4%B1%E6%95%88%E9%97%AE%E9%A2%98.html"}],["meta",{"property":"og:site_name","content":"noahyz的博客"}],["meta",{"property":"og:title","content":"2.preload失效问题"}],["meta",{"property":"og:description","content":"一、preload 失效原因 1. RTLD_DEEPBIND 的使用 来自于：http://linux.die.net/man/3/dlopen RTLD_DEEPBIND（自 glibc 2.3.4 起）将此库中符号的查找范围置于全局范围之前。这意味着自包含库将优先使用其自己的符号，而不是已加载库中包含的具有相同名称的全局符号。该标志未在 POSI..."}],["meta",{"property":"og:type","content":"article"}],["meta",{"property":"og:locale","content":"zh-CN"}],["meta",{"property":"article:author","content":"noahyz"}],["meta",{"property":"article:tag","content":"linux"}],["meta",{"property":"article:published_time","content":"2023-01-19T11:11:41.000Z"}],["script",{"type":"application/ld+json"},"{\\"@context\\":\\"https://schema.org\\",\\"@type\\":\\"Article\\",\\"headline\\":\\"2.preload失效问题\\",\\"image\\":[\\"\\"],\\"datePublished\\":\\"2023-01-19T11:11:41.000Z\\",\\"dateModified\\":null,\\"author\\":[{\\"@type\\":\\"Person\\",\\"name\\":\\"noahyz\\",\\"url\\":\\"/about-the-author/\\"}]}"]]},"headers":[{"level":3,"title":"一、preload 失效原因","slug":"一、preload-失效原因","link":"#一、preload-失效原因","children":[]},{"level":3,"title":"3. 设置执行文件的 setgid/setuid 权限","slug":"_3-设置执行文件的-setgid-setuid-权限","link":"#_3-设置执行文件的-setgid-setuid-权限","children":[]},{"level":3,"title":"5. 链接库的顺序","slug":"_5-链接库的顺序","link":"#_5-链接库的顺序","children":[]}],"git":{},"readingTime":{"minutes":1.56,"words":467},"filePathRelative":"技术专题/hook/2.preload失效问题.md","localizedDate":"2023年1月19日","excerpt":"<h3>一、preload 失效原因</h3>\\n<h4>1. RTLD_DEEPBIND 的使用</h4>\\n<p>来自于：<a href=\\"http://linux.die.net/man/3/dlopen\\" target=\\"_blank\\" rel=\\"noopener noreferrer\\">http://linux.die.net/man/3/dlopen</a></p>\\n<p>RTLD_DEEPBIND（自 glibc 2.3.4 起）将此库中符号的查找范围置于全局范围之前。这意味着自包含库将优先使用其自己的符号，而不是已加载库中包含的具有相同名称的全局符号。该标志未在 POSIX.1-2001 中指定。</p>","autoDesc":true}');export{o as comp,c as data};

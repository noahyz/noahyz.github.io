import{_ as s}from"./plugin-vue_export-helper-DlAUqK2U.js";import{c as a,a as i,o as l}from"./app-D1zlwylF.js";const e={};function c(p,n){return l(),a("div",null,n[0]||(n[0]=[i(`<h2 id="gcc-使用" tabindex="-1"><a class="header-anchor" href="#gcc-使用"><span>gcc 使用</span></a></h2><p>在windows 下动态链接库是以 .dll 后缀的文件，linux 是以 .so 为后缀的文件。</p><h3 id="一、gcc-在执行编译工作的时候-总共需要4步" tabindex="-1"><a class="header-anchor" href="#一、gcc-在执行编译工作的时候-总共需要4步"><span>一、gcc 在执行编译工作的时候，总共需要4步：</span></a></h3><ol><li>预处理。生成.i 的文件【预处理器】</li><li>将预处理后的文件转换成汇编语言，生成 .s 文件【编译器】</li><li>将汇编变为目标代码，生成 .o 文件【汇编器】</li><li>连接目标代码，生成可执行程序。【链接器】</li></ol><h3 id="二、参数" tabindex="-1"><a class="header-anchor" href="#二、参数"><span>二、参数</span></a></h3><div class="language- line-numbers-mode" data-highlighter="shiki" data-ext="" data-title="" style="--shiki-light:#24292e;--shiki-dark:#abb2bf;--shiki-light-bg:#fff;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes github-light one-dark-pro vp-code"><code><span class="line"><span>1. -c：进行预处理、编译、和汇编。也就是把程序作成 obj 文件</span></span>
<span class="line"><span>2. -S：进行预处理、编译，把文件编译成汇编代码</span></span>
<span class="line"><span>3. -E：进行预处理。不生成文件，因此需要重定向到一个输出文件里面。 Gcc -E hello.c &gt; hello.txt</span></span>
<span class="line"><span>4. -o：制定目标名称。</span></span>
<span class="line"><span>5. -include file：包含某个代码，简单来说，就是便以某个文件，需要另一个文件的时候，就可以用它设定，功能就相当于代码中使用#include&lt;filename&gt;。 gcc hello.c -include /root/hello.h</span></span>
<span class="line"><span>6. -Idir：在使用“ #include “file” ”的时候，gcc 会在当前目录查找你所制定的头文件，如果没有找到，便回到默认的头文件目录找。如果使用 -I 制定了目录，他会先在你所制定的目录查找，然后再按常规的顺序去找。对于 #include&lt;file&gt; ，gcc/g++ 会到 -I 制定的目录查找，查找不到，然后将到系统的默认的头文件目录查找。</span></span>
<span class="line"><span>7. -idirafter dir：在 -I 的目录里面查找失败，就到这个目录里面查找</span></span>
<span class="line"><span>8. -C：在预处理的时候，不删除注释信息，一般和 -E 使用，有时候分析程序，这个很方便</span></span>
<span class="line"><span>9. -M：生成文件关联的信息。包含目标文件所依赖的所有源代码。</span></span>
<span class="line"><span>10. -MM：和-M 一样，但是它将忽略由#include&lt;file&gt; 造成的依赖。</span></span>
<span class="line"><span>11. -MD：和 -M 相同，但是输出将导入到 .d 文件里面</span></span>
<span class="line"><span>12. -MMD：和-MM 相同，但是输出将导入到 .d 文件里面</span></span>
<span class="line"><span>13. -llibrary：指定编译的时候使用的库。 gcc -lcurses hello.c ：使用 ncurses 库编译程序。</span></span>
<span class="line"><span>14. -Ldir：指定编译的时候，搜索库的路径。比如自己的库，可以用它指定目录，不然编译器将只在标准库的目录找。这个dir 就是目录的名称</span></span>
<span class="line"><span>15. -O0、-O1、-O2、-O3：编译器的优化选项的4个级别，-O0表示没有优化，-O1为默认值、-O3优化级别最高</span></span>
<span class="line"><span>16. -g：只是编译器，在编译的时候，产生调试信息，可以使用gdb</span></span>
<span class="line"><span>17. -static：此选项禁止使用动态库，所以编译出来的东西，一般都很大，也不需要什么动态链接库，就可以运行</span></span>
<span class="line"><span>18. -share：此选项尽量使用动态库，所以生成文件比较小，但是需要系统链接动态库。 </span></span>
<span class="line"><span>19. -w：不生成任何警告信息</span></span>
<span class="line"><span>20. -Wall：生成所有警告信息</span></span>
<span class="line"><span>21. -fPIC：为了在动态库中生成位置无关的代码。通过全局偏移表（GOT）访问所有常量地址。程序启动时动态加载程序解析GOT条目。</span></span>
<span class="line"><span>22. -fpic：和 -fPIC 相同，区别在于如果链接的可执行文件的GOT大小超过计算机特定的最大大小，则会从链接器收到错误消息，指示 -fpic 不起作用；在这种情况下，请使用 -fPIC 重新编译。GOT 大小根据操作系统的不同而大小不一样，SPARC上为8K，在AArch64 上为28k，x86没有限制。所以一般请使用 -fPIC选项。</span></span>
<span class="line"><span>23. -Wl,-options：把参数（options）传递给链接器 ld，如果 options 中间有逗号，就把 options 分成多个选项，然后传递给链接程序。</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div>`,6)]))}const r=s(e,[["render",c],["__file","3.gcc使用.html.vue"]]),o=JSON.parse('{"path":"/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/c__%E8%AF%AD%E8%A8%80/%E7%BC%96%E8%AF%91%E8%B0%83%E8%AF%95/3.gcc%E4%BD%BF%E7%94%A8.html","title":"3.gcc使用","lang":"zh-CN","frontmatter":{"title":"3.gcc使用","description":"gcc 使用 在windows 下动态链接库是以 .dll 后缀的文件，linux 是以 .so 为后缀的文件。 一、gcc 在执行编译工作的时候，总共需要4步： 预处理。生成.i 的文件【预处理器】 将预处理后的文件转换成汇编语言，生成 .s 文件【编译器】 将汇编变为目标代码，生成 .o 文件【汇编器】 连接目标代码，生成可执行程序。【链接器】 二、参数","head":[["meta",{"property":"og:url","content":"https://noahyz.github.io/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/c__%E8%AF%AD%E8%A8%80/%E7%BC%96%E8%AF%91%E8%B0%83%E8%AF%95/3.gcc%E4%BD%BF%E7%94%A8.html"}],["meta",{"property":"og:site_name","content":"noahyz的博客"}],["meta",{"property":"og:title","content":"3.gcc使用"}],["meta",{"property":"og:description","content":"gcc 使用 在windows 下动态链接库是以 .dll 后缀的文件，linux 是以 .so 为后缀的文件。 一、gcc 在执行编译工作的时候，总共需要4步： 预处理。生成.i 的文件【预处理器】 将预处理后的文件转换成汇编语言，生成 .s 文件【编译器】 将汇编变为目标代码，生成 .o 文件【汇编器】 连接目标代码，生成可执行程序。【链接器】 二、参数"}],["meta",{"property":"og:type","content":"article"}],["meta",{"property":"og:locale","content":"zh-CN"}],["meta",{"property":"article:author","content":"noahyz"}],["script",{"type":"application/ld+json"},"{\\"@context\\":\\"https://schema.org\\",\\"@type\\":\\"Article\\",\\"headline\\":\\"3.gcc使用\\",\\"image\\":[\\"\\"],\\"dateModified\\":null,\\"author\\":[{\\"@type\\":\\"Person\\",\\"name\\":\\"noahyz\\",\\"url\\":\\"/about-the-author/\\"}]}"]]},"headers":[{"level":2,"title":"gcc 使用","slug":"gcc-使用","link":"#gcc-使用","children":[{"level":3,"title":"一、gcc 在执行编译工作的时候，总共需要4步：","slug":"一、gcc-在执行编译工作的时候-总共需要4步","link":"#一、gcc-在执行编译工作的时候-总共需要4步","children":[]},{"level":3,"title":"二、参数","slug":"二、参数","link":"#二、参数","children":[]}]}],"git":{},"readingTime":{"minutes":3.19,"words":956},"filePathRelative":"编程语言/c++语言/编译调试/3.gcc使用.md","excerpt":"<h2>gcc 使用</h2>\\n<p>在windows 下动态链接库是以 .dll 后缀的文件，linux 是以 .so 为后缀的文件。</p>\\n<h3>一、gcc 在执行编译工作的时候，总共需要4步：</h3>\\n<ol>\\n<li>预处理。生成.i 的文件【预处理器】</li>\\n<li>将预处理后的文件转换成汇编语言，生成 .s 文件【编译器】</li>\\n<li>将汇编变为目标代码，生成 .o 文件【汇编器】</li>\\n<li>连接目标代码，生成可执行程序。【链接器】</li>\\n</ol>\\n<h3>二、参数</h3>\\n<div class=\\"language- line-numbers-mode\\" data-highlighter=\\"shiki\\" data-ext=\\"\\" data-title=\\"\\" style=\\"--shiki-light:#24292e;--shiki-dark:#abb2bf;--shiki-light-bg:#fff;--shiki-dark-bg:#282c34\\"><pre class=\\"shiki shiki-themes github-light one-dark-pro vp-code\\"><code><span class=\\"line\\"><span>1. -c：进行预处理、编译、和汇编。也就是把程序作成 obj 文件</span></span>\\n<span class=\\"line\\"><span>2. -S：进行预处理、编译，把文件编译成汇编代码</span></span>\\n<span class=\\"line\\"><span>3. -E：进行预处理。不生成文件，因此需要重定向到一个输出文件里面。 Gcc -E hello.c &gt; hello.txt</span></span>\\n<span class=\\"line\\"><span>4. -o：制定目标名称。</span></span>\\n<span class=\\"line\\"><span>5. -include file：包含某个代码，简单来说，就是便以某个文件，需要另一个文件的时候，就可以用它设定，功能就相当于代码中使用#include&lt;filename&gt;。 gcc hello.c -include /root/hello.h</span></span>\\n<span class=\\"line\\"><span>6. -Idir：在使用“ #include “file” ”的时候，gcc 会在当前目录查找你所制定的头文件，如果没有找到，便回到默认的头文件目录找。如果使用 -I 制定了目录，他会先在你所制定的目录查找，然后再按常规的顺序去找。对于 #include&lt;file&gt; ，gcc/g++ 会到 -I 制定的目录查找，查找不到，然后将到系统的默认的头文件目录查找。</span></span>\\n<span class=\\"line\\"><span>7. -idirafter dir：在 -I 的目录里面查找失败，就到这个目录里面查找</span></span>\\n<span class=\\"line\\"><span>8. -C：在预处理的时候，不删除注释信息，一般和 -E 使用，有时候分析程序，这个很方便</span></span>\\n<span class=\\"line\\"><span>9. -M：生成文件关联的信息。包含目标文件所依赖的所有源代码。</span></span>\\n<span class=\\"line\\"><span>10. -MM：和-M 一样，但是它将忽略由#include&lt;file&gt; 造成的依赖。</span></span>\\n<span class=\\"line\\"><span>11. -MD：和 -M 相同，但是输出将导入到 .d 文件里面</span></span>\\n<span class=\\"line\\"><span>12. -MMD：和-MM 相同，但是输出将导入到 .d 文件里面</span></span>\\n<span class=\\"line\\"><span>13. -llibrary：指定编译的时候使用的库。 gcc -lcurses hello.c ：使用 ncurses 库编译程序。</span></span>\\n<span class=\\"line\\"><span>14. -Ldir：指定编译的时候，搜索库的路径。比如自己的库，可以用它指定目录，不然编译器将只在标准库的目录找。这个dir 就是目录的名称</span></span>\\n<span class=\\"line\\"><span>15. -O0、-O1、-O2、-O3：编译器的优化选项的4个级别，-O0表示没有优化，-O1为默认值、-O3优化级别最高</span></span>\\n<span class=\\"line\\"><span>16. -g：只是编译器，在编译的时候，产生调试信息，可以使用gdb</span></span>\\n<span class=\\"line\\"><span>17. -static：此选项禁止使用动态库，所以编译出来的东西，一般都很大，也不需要什么动态链接库，就可以运行</span></span>\\n<span class=\\"line\\"><span>18. -share：此选项尽量使用动态库，所以生成文件比较小，但是需要系统链接动态库。 </span></span>\\n<span class=\\"line\\"><span>19. -w：不生成任何警告信息</span></span>\\n<span class=\\"line\\"><span>20. -Wall：生成所有警告信息</span></span>\\n<span class=\\"line\\"><span>21. -fPIC：为了在动态库中生成位置无关的代码。通过全局偏移表（GOT）访问所有常量地址。程序启动时动态加载程序解析GOT条目。</span></span>\\n<span class=\\"line\\"><span>22. -fpic：和 -fPIC 相同，区别在于如果链接的可执行文件的GOT大小超过计算机特定的最大大小，则会从链接器收到错误消息，指示 -fpic 不起作用；在这种情况下，请使用 -fPIC 重新编译。GOT 大小根据操作系统的不同而大小不一样，SPARC上为8K，在AArch64 上为28k，x86没有限制。所以一般请使用 -fPIC选项。</span></span>\\n<span class=\\"line\\"><span>23. -Wl,-options：把参数（options）传递给链接器 ld，如果 options 中间有逗号，就把 options 分成多个选项，然后传递给链接程序。</span></span></code></pre>\\n<div class=\\"line-numbers\\" aria-hidden=\\"true\\" style=\\"counter-reset:line-number 0\\"><div class=\\"line-number\\"></div><div class=\\"line-number\\"></div><div class=\\"line-number\\"></div><div class=\\"line-number\\"></div><div class=\\"line-number\\"></div><div class=\\"line-number\\"></div><div class=\\"line-number\\"></div><div class=\\"line-number\\"></div><div class=\\"line-number\\"></div><div class=\\"line-number\\"></div><div class=\\"line-number\\"></div><div class=\\"line-number\\"></div><div class=\\"line-number\\"></div><div class=\\"line-number\\"></div><div class=\\"line-number\\"></div><div class=\\"line-number\\"></div><div class=\\"line-number\\"></div><div class=\\"line-number\\"></div><div class=\\"line-number\\"></div><div class=\\"line-number\\"></div><div class=\\"line-number\\"></div><div class=\\"line-number\\"></div><div class=\\"line-number\\"></div></div></div>","autoDesc":true}');export{r as comp,o as data};

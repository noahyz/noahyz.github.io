import{_ as i}from"./plugin-vue_export-helper-DlAUqK2U.js";import{c as t,a,o as n}from"./app-D1zlwylF.js";const r="/assets/O1%E8%B0%83%E5%BA%A6%E7%AE%97%E6%B3%95-C4aJVJ4Z.png",s={};function l(u,e){return n(),t("div",null,e[0]||(e[0]=[a('<p>Linux 从 2.6 开始引入了 <code>O(1)</code> 调度器</p><h3 id="一、工作原理" tabindex="-1"><a class="header-anchor" href="#一、工作原理"><span>一、工作原理</span></a></h3><img src="'+r+`" style="zoom:50%;"><ul><li>系统中的 runqueue 运行队列，每个 CPU 都有一个 runqueue。这样在 SMP 系统中可以有效的避免多个 CPU 去访问同一个 runqueue。</li><li>每一个 runqueue 运行队列维护了两个结构体。一个是 active 结构体，存储的是运行的进程；另一个是 expired 结构题，存储的是时间片用完的进程。</li><li>active 和 expired 结构体中都有多个链表，分别存储着不同优先级的进程。相同优先级的进程挂在同一条链表上</li><li>同时在 active 和 expired 结构中，还有一个 bitmap 结构，用来指示哪些进程可以运行。</li><li>当 active 结构中无进程可运行时，说明系统中所有进程的时间片都已经耗光，这时候只需要变换 active 和 expire 的指针，即可运行原 expire 结构中的进程。</li></ul><h3 id="二、核心算法" tabindex="-1"><a class="header-anchor" href="#二、核心算法"><span>二、核心算法</span></a></h3><p>如下几行代码比较核心。</p><div class="language- line-numbers-mode" data-highlighter="shiki" data-ext="" data-title="" style="--shiki-light:#24292e;--shiki-dark:#abb2bf;--shiki-light-bg:#fff;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes github-light one-dark-pro vp-code"><code><span class="line"><span>array = rq-&gt;active;	</span></span>
<span class="line"><span>idx = sched_find_first_bit(array-&gt;bitmap);</span></span>
<span class="line"><span>queue = array-&gt;queue + idx;</span></span>
<span class="line"><span>next = list_entry(queue-&gt;next, task_t, run_list);</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>首先在 runqueue 的 active 队列中的 bitmap 中找到一个下标，这个下标就是对应的优先级，然后获取到对应优先级的链表，然后从中获取一个进程。接下来就是执行进程切换，进程调度。</p><h4 id="关于优先级" tabindex="-1"><a class="header-anchor" href="#关于优先级"><span>关于优先级</span></a></h4><p>进程的优先级分为静态优先级和动态优先级。普通优先级时进程创建时默认设置的优先级，动态优先级会在进程运行时经过动态的调整。</p><p>在系统运行中，会根据进程的情况调节其优先级。比如当一个进程经常睡眠，则会增加他的优先级；当一个进程经常占用 CPU，则需要降低其优先级。</p><h4 id="关于时间片" tabindex="-1"><a class="header-anchor" href="#关于时间片"><span>关于时间片</span></a></h4><p>当一个进程的时间片消耗完时，需要将进程从 active 队列中移除，同时设置需要重新调度的标志。还需要计算此进程的优先级、时间片等信息。还要判断是否为交互式进程，或者此进程是不是ji</p>`,13)]))}const o=i(s,[["render",l],["__file","进程调度之O1算法.html.vue"]]),d=JSON.parse('{"path":"/%E6%8A%80%E6%9C%AF%E4%B8%93%E9%A2%98/Linux%E7%A0%94%E7%A9%B6/%E8%BF%9B%E7%A8%8B%E8%B0%83%E5%BA%A6%E4%B9%8BO1%E7%AE%97%E6%B3%95.html","title":"进程调度之 O1 算法","lang":"zh-CN","frontmatter":{"title":"进程调度之 O1 算法","description":"Linux 从 2.6 开始引入了 O(1) 调度器 一、工作原理 系统中的 runqueue 运行队列，每个 CPU 都有一个 runqueue。这样在 SMP 系统中可以有效的避免多个 CPU 去访问同一个 runqueue。 每一个 runqueue 运行队列维护了两个结构体。一个是 active 结构体，存储的是运行的进程；另一个是 expir...","head":[["meta",{"property":"og:url","content":"https://noahyz.github.io/%E6%8A%80%E6%9C%AF%E4%B8%93%E9%A2%98/Linux%E7%A0%94%E7%A9%B6/%E8%BF%9B%E7%A8%8B%E8%B0%83%E5%BA%A6%E4%B9%8BO1%E7%AE%97%E6%B3%95.html"}],["meta",{"property":"og:site_name","content":"noahyz的博客"}],["meta",{"property":"og:title","content":"进程调度之 O1 算法"}],["meta",{"property":"og:description","content":"Linux 从 2.6 开始引入了 O(1) 调度器 一、工作原理 系统中的 runqueue 运行队列，每个 CPU 都有一个 runqueue。这样在 SMP 系统中可以有效的避免多个 CPU 去访问同一个 runqueue。 每一个 runqueue 运行队列维护了两个结构体。一个是 active 结构体，存储的是运行的进程；另一个是 expir..."}],["meta",{"property":"og:type","content":"article"}],["meta",{"property":"og:locale","content":"zh-CN"}],["meta",{"property":"article:author","content":"noahyz"}],["script",{"type":"application/ld+json"},"{\\"@context\\":\\"https://schema.org\\",\\"@type\\":\\"Article\\",\\"headline\\":\\"进程调度之 O1 算法\\",\\"image\\":[\\"\\"],\\"dateModified\\":null,\\"author\\":[{\\"@type\\":\\"Person\\",\\"name\\":\\"noahyz\\",\\"url\\":\\"/about-the-author/\\"}]}"]]},"headers":[{"level":3,"title":"一、工作原理","slug":"一、工作原理","link":"#一、工作原理","children":[]},{"level":3,"title":"二、核心算法","slug":"二、核心算法","link":"#二、核心算法","children":[]}],"git":{},"readingTime":{"minutes":1.87,"words":561},"filePathRelative":"技术专题/Linux研究/进程调度之O1算法.md","excerpt":"<p>Linux 从 2.6 开始引入了 <code>O(1)</code> 调度器</p>\\n<h3>一、工作原理</h3>\\n\\n<ul>\\n<li>系统中的 runqueue 运行队列，每个 CPU 都有一个 runqueue。这样在 SMP 系统中可以有效的避免多个 CPU 去访问同一个 runqueue。</li>\\n<li>每一个 runqueue 运行队列维护了两个结构体。一个是 active 结构体，存储的是运行的进程；另一个是 expired 结构题，存储的是时间片用完的进程。</li>\\n<li>active 和 expired 结构体中都有多个链表，分别存储着不同优先级的进程。相同优先级的进程挂在同一条链表上</li>\\n<li>同时在 active 和 expired 结构中，还有一个 bitmap 结构，用来指示哪些进程可以运行。</li>\\n<li>当 active 结构中无进程可运行时，说明系统中所有进程的时间片都已经耗光，这时候只需要变换 active 和 expire 的指针，即可运行原 expire 结构中的进程。</li>\\n</ul>","autoDesc":true}');export{o as comp,d as data};

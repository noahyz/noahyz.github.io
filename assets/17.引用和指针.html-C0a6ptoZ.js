import{_ as e}from"./plugin-vue_export-helper-DlAUqK2U.js";import{c as l,a as i,o}from"./app-D1zlwylF.js";const n={};function a(c,t){return o(),l("div",null,t[0]||(t[0]=[i('<h2 id="c-中引用和指针的区别" tabindex="-1"><a class="header-anchor" href="#c-中引用和指针的区别"><span>c++ 中引用和指针的区别</span></a></h2><ul><li>从概念上，指针是存放变量地址的一个变量，在逻辑上是独立的。他可以被改变，包括其所指向的地址的改变和其指向的地址中所存放的数据的改变。而引用是一个别名，他的存在具有依赖性，所以引用必须在一开始就被初始化，而且其引用的对象在其整个生命周期中是不能被改变的。</li><li>指针传递参数和引用传递参数是有本质上的不同： <ol><li>指针传递参数本质上是值传递，传递的是一个地址值。值传递的特点是被调函数对形参的任何操作都是作为局部变量进行，不会影响主调函数的实参变量的值</li><li>引用传递过程中，被调函数的形参虽然也作为局部变量在栈中开辟了内存空间，但是这时存放的是由主调函数放进来的实参变量的地址。被调函数对形参的任何操作都被处理成间接寻址，即通过栈中存放的地址访问主调函数中的实参变量。因此，被调函数对形参做的任何操作都影响了主调函数中的实参变量</li></ol></li><li>从编译角度。程序在编译时分别将指针和引用添加到符号表上，符号表上记录的是变量名及变量所对应地址。指针变量在符号表上对应的地址值为指针变量的地址值，而引用在符号表上对应的地址值为引用对象的地址值。符号表生成后就不会再改，因此指针可以改变其指向的对象（指针变量中的值可以改），而引用对象则不能修改。</li></ul><p>相同点：</p><ul><li>都是地址的概念，指针指向一块内存，他的内容是所指内存的地址；而引用则是某块内存的别名</li></ul><p>不同点：</p><ul><li>指针是一个实体，而引用仅是一个别名</li><li>引用只能在定义时被初始化一次，之后不可变；指针可变</li><li>引用没有 const，指针有 const。const 的指针不可变（没有这种形式： <code>int&amp; const a </code> ，引用本身即别名不可以改变，所以不需要这种形式。而 <code>const int&amp; a</code>是有的，意为引用所指的值不可以改变）</li><li>引用不能为空，指针可以为空</li><li><code>sizeof 引用</code> 得到的是所指向的变量（对象）的大小；<code>sizeof 指针</code> 得到的是指针本身的大小</li><li>指针和引用的自增（++）运算意义不一样</li><li>引用是类型安全的，而指针不是（引用比指针多了类型检查）</li></ul>',6)]))}const s=e(n,[["render",a],["__file","17.引用和指针.html.vue"]]),d=JSON.parse('{"path":"/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/c__%E8%AF%AD%E8%A8%80/%E7%BC%96%E7%A0%81%E6%8A%80%E5%B7%A7/17.%E5%BC%95%E7%94%A8%E5%92%8C%E6%8C%87%E9%92%88.html","title":"17.引用和指针的区别","lang":"zh-CN","frontmatter":{"title":"17.引用和指针的区别","date":"2023-01-19T11:11:41.000Z","tags":["linux"],"description":"c++ 中引用和指针的区别 从概念上，指针是存放变量地址的一个变量，在逻辑上是独立的。他可以被改变，包括其所指向的地址的改变和其指向的地址中所存放的数据的改变。而引用是一个别名，他的存在具有依赖性，所以引用必须在一开始就被初始化，而且其引用的对象在其整个生命周期中是不能被改变的。 指针传递参数和引用传递参数是有本质上的不同： 指针传递参数本质上是值传递...","head":[["meta",{"property":"og:url","content":"https://noahyz.github.io/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/c__%E8%AF%AD%E8%A8%80/%E7%BC%96%E7%A0%81%E6%8A%80%E5%B7%A7/17.%E5%BC%95%E7%94%A8%E5%92%8C%E6%8C%87%E9%92%88.html"}],["meta",{"property":"og:site_name","content":"noahyz的博客"}],["meta",{"property":"og:title","content":"17.引用和指针的区别"}],["meta",{"property":"og:description","content":"c++ 中引用和指针的区别 从概念上，指针是存放变量地址的一个变量，在逻辑上是独立的。他可以被改变，包括其所指向的地址的改变和其指向的地址中所存放的数据的改变。而引用是一个别名，他的存在具有依赖性，所以引用必须在一开始就被初始化，而且其引用的对象在其整个生命周期中是不能被改变的。 指针传递参数和引用传递参数是有本质上的不同： 指针传递参数本质上是值传递..."}],["meta",{"property":"og:type","content":"article"}],["meta",{"property":"og:locale","content":"zh-CN"}],["meta",{"property":"article:author","content":"noahyz"}],["meta",{"property":"article:tag","content":"linux"}],["meta",{"property":"article:published_time","content":"2023-01-19T11:11:41.000Z"}],["script",{"type":"application/ld+json"},"{\\"@context\\":\\"https://schema.org\\",\\"@type\\":\\"Article\\",\\"headline\\":\\"17.引用和指针的区别\\",\\"image\\":[\\"\\"],\\"datePublished\\":\\"2023-01-19T11:11:41.000Z\\",\\"dateModified\\":null,\\"author\\":[{\\"@type\\":\\"Person\\",\\"name\\":\\"noahyz\\",\\"url\\":\\"/about-the-author/\\"}]}"]]},"headers":[{"level":2,"title":"c++ 中引用和指针的区别","slug":"c-中引用和指针的区别","link":"#c-中引用和指针的区别","children":[]}],"git":{},"readingTime":{"minutes":2.45,"words":734},"filePathRelative":"编程语言/c++语言/编码技巧/17.引用和指针.md","localizedDate":"2023年1月19日","excerpt":"<h2>c++ 中引用和指针的区别</h2>\\n<ul>\\n<li>从概念上，指针是存放变量地址的一个变量，在逻辑上是独立的。他可以被改变，包括其所指向的地址的改变和其指向的地址中所存放的数据的改变。而引用是一个别名，他的存在具有依赖性，所以引用必须在一开始就被初始化，而且其引用的对象在其整个生命周期中是不能被改变的。</li>\\n<li>指针传递参数和引用传递参数是有本质上的不同：\\n<ol>\\n<li>指针传递参数本质上是值传递，传递的是一个地址值。值传递的特点是被调函数对形参的任何操作都是作为局部变量进行，不会影响主调函数的实参变量的值</li>\\n<li>引用传递过程中，被调函数的形参虽然也作为局部变量在栈中开辟了内存空间，但是这时存放的是由主调函数放进来的实参变量的地址。被调函数对形参的任何操作都被处理成间接寻址，即通过栈中存放的地址访问主调函数中的实参变量。因此，被调函数对形参做的任何操作都影响了主调函数中的实参变量</li>\\n</ol>\\n</li>\\n<li>从编译角度。程序在编译时分别将指针和引用添加到符号表上，符号表上记录的是变量名及变量所对应地址。指针变量在符号表上对应的地址值为指针变量的地址值，而引用在符号表上对应的地址值为引用对象的地址值。符号表生成后就不会再改，因此指针可以改变其指向的对象（指针变量中的值可以改），而引用对象则不能修改。</li>\\n</ul>","autoDesc":true}');export{s as comp,d as data};

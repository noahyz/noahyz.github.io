import{_ as t}from"./plugin-vue_export-helper-DlAUqK2U.js";import{c as a,a as n,o as r}from"./app-D1zlwylF.js";const p={};function o(E,e){return r(),a("div",null,e[0]||(e[0]=[n('<h3 id="一、无数据传输的场景" tabindex="-1"><a class="header-anchor" href="#一、无数据传输的场景"><span>一、无数据传输的场景</span></a></h3><h4 id="_1-客户端主机崩溃" tabindex="-1"><a class="header-anchor" href="#_1-客户端主机崩溃"><span>1. 客户端主机崩溃</span></a></h4><p>客户端主机崩溃了，服务端是无法感知到的。如果服务端没有开启 TCP 的保活机制，又没有进行数据交互，那么服务端的 TCP 连接将会一直处于 ESTABLISHED 连接状态，直到服务端重启进程。</p><p>所以，在没有 TCP 保活机制且双方不传输数据的情况下，一方的 TCP 连接处于 ESTABLISHED 状态，并不代表另一方的连接还一定正常。</p><h4 id="_2-客户端进程崩溃" tabindex="-1"><a class="header-anchor" href="#_2-客户端进程崩溃"><span>2. 客户端进程崩溃</span></a></h4><p>TCP 连接信息是由内核维护的，所以当服务端的进程崩溃后，内核需要回收该进程的所有 TCP 连接资源，于是内核会发送第一次挥手 FIN 报文，后续的挥手过程也都是在内核完成，并不需要进程的参与。所以即使服务端的进程退出了，还是能和客户端完成 TCP 四次挥手的过程。</p><p>我曾经做过实验，使用 <code>kill -9</code> 来模拟进程崩溃的情况，发现在 kill 掉进程后，服务端会发送 FIN 报文，与客户端进行四次挥手。</p><p>所以，即使没有开启 TCP 保活机制，且双方也没有数据交互的情况下，如果其中一方的进程发生了崩溃，这个过程操作系统是可以感知到的，操作系统会发送 FIN 报文给对方，然后与对方进行 TCP 四次挥手。</p><h3 id="二、有数据传输的场景" tabindex="-1"><a class="header-anchor" href="#二、有数据传输的场景"><span>二、有数据传输的场景</span></a></h3><p>在数据传输的场景下，有两种情况：</p><ul><li>客户端主机宕机，又迅速重启，会发生什么？</li><li>客户端主机宕机，一直没有重启，会发生什么？</li></ul><h4 id="_1-客户端主机宕机-又迅速重启" tabindex="-1"><a class="header-anchor" href="#_1-客户端主机宕机-又迅速重启"><span>1. 客户端主机宕机，又迅速重启</span></a></h4><p>在客户端主机宕机后，服务端向客户端发送的报文会得不到任何的响应，在一定时长后，服务端就会触发<strong>超时重传</strong>机制，重传未得到响应的报文。</p><p>服务端重传报文的过程中，客户端主机重启完成后，客户端的内核就会接收重传的报文，然后根据报文的信息传递给对应的进程：</p><ul><li>如果客户端主机上<strong>没有</strong>进程绑定该 TCP 报文的目标端口号，那么客户端内核就会回复 RST 报文，重置该 TCP 连接；</li><li>如果客户端主机上<strong>有</strong>进程绑定该 TCP 报文的目标端口号，由于客户端主机重启后，之前的 TCP 连接的数据结构已经丢失了，客户端内核里协议栈会发现找不到该 TCP 连接的 socket 结构体，于是就会回复 RST 报文，重置该 TCP 连接。</li></ul><p>所以，只要有一方重启完成后，收到之前 TCP 连接的报文，都会回复 RST 报文，以断开连接。</p><h4 id="_2-客户端主机宕机-一直没有重启" tabindex="-1"><a class="header-anchor" href="#_2-客户端主机宕机-一直没有重启"><span>2. 客户端主机宕机，一直没有重启</span></a></h4><p>这种情况，服务端超时重传报文的次数达到一定阈值后，内核就会判定出该 TCP 有问题，然后通过 Socket 接口告诉应用程序该 TCP 连接出问题了，于是服务端的 TCP 连接就会断开。</p><p>那么 TCP 的数据报文具体重传几次呢？在 Linux 系统中，提供了配置项：<code>/proc/sys/net/ipv4/tcp_retries2</code>，默认值是 15。也就是说在 TCP 连接建立的情况下，超时重传的最大次数为 15。</p><p>不过 <code>tcp_retries2</code> 设置了 15 次，并不代表 TCP 超时重传了 15 次才会通知应用程序终止该 TCP 连接。内核会根据 <code>tcp_retries2</code> 设置的值，计算出一个超时时间。如果重传的间隔超过了这个超时时间，则认为超过了阈值，就会停止重传，然后就会断开 TCP 连接。</p>',20)]))}const l=t(p,[["render",o],["__file","4.TCP异常断开连接.html.vue"]]),C=JSON.parse('{"path":"/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E4%B8%83%E5%B1%82%E6%A8%A1%E5%9E%8B/%E4%BC%A0%E8%BE%93%E5%B1%82/%E6%8A%80%E6%9C%AF%E5%8E%9F%E7%90%86/4.TCP%E5%BC%82%E5%B8%B8%E6%96%AD%E5%BC%80%E8%BF%9E%E6%8E%A5.html","title":"4.TCP异常断开连接","lang":"zh-CN","frontmatter":{"title":"4.TCP异常断开连接","description":"一、无数据传输的场景 1. 客户端主机崩溃 客户端主机崩溃了，服务端是无法感知到的。如果服务端没有开启 TCP 的保活机制，又没有进行数据交互，那么服务端的 TCP 连接将会一直处于 ESTABLISHED 连接状态，直到服务端重启进程。 所以，在没有 TCP 保活机制且双方不传输数据的情况下，一方的 TCP 连接处于 ESTABLISHED 状态，并...","head":[["meta",{"property":"og:url","content":"https://noahyz.github.io/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E4%B8%83%E5%B1%82%E6%A8%A1%E5%9E%8B/%E4%BC%A0%E8%BE%93%E5%B1%82/%E6%8A%80%E6%9C%AF%E5%8E%9F%E7%90%86/4.TCP%E5%BC%82%E5%B8%B8%E6%96%AD%E5%BC%80%E8%BF%9E%E6%8E%A5.html"}],["meta",{"property":"og:site_name","content":"noahyz的博客"}],["meta",{"property":"og:title","content":"4.TCP异常断开连接"}],["meta",{"property":"og:description","content":"一、无数据传输的场景 1. 客户端主机崩溃 客户端主机崩溃了，服务端是无法感知到的。如果服务端没有开启 TCP 的保活机制，又没有进行数据交互，那么服务端的 TCP 连接将会一直处于 ESTABLISHED 连接状态，直到服务端重启进程。 所以，在没有 TCP 保活机制且双方不传输数据的情况下，一方的 TCP 连接处于 ESTABLISHED 状态，并..."}],["meta",{"property":"og:type","content":"article"}],["meta",{"property":"og:locale","content":"zh-CN"}],["meta",{"property":"article:author","content":"noahyz"}],["script",{"type":"application/ld+json"},"{\\"@context\\":\\"https://schema.org\\",\\"@type\\":\\"Article\\",\\"headline\\":\\"4.TCP异常断开连接\\",\\"image\\":[\\"\\"],\\"dateModified\\":null,\\"author\\":[{\\"@type\\":\\"Person\\",\\"name\\":\\"noahyz\\",\\"url\\":\\"/about-the-author/\\"}]}"]]},"headers":[{"level":3,"title":"一、无数据传输的场景","slug":"一、无数据传输的场景","link":"#一、无数据传输的场景","children":[]},{"level":3,"title":"二、有数据传输的场景","slug":"二、有数据传输的场景","link":"#二、有数据传输的场景","children":[]}],"git":{},"readingTime":{"minutes":3.24,"words":972},"filePathRelative":"计算机网络/七层模型/传输层/技术原理/4.TCP异常断开连接.md","excerpt":"<h3>一、无数据传输的场景</h3>\\n<h4>1. 客户端主机崩溃</h4>\\n<p>客户端主机崩溃了，服务端是无法感知到的。如果服务端没有开启 TCP 的保活机制，又没有进行数据交互，那么服务端的 TCP 连接将会一直处于 ESTABLISHED 连接状态，直到服务端重启进程。</p>\\n<p>所以，在没有 TCP 保活机制且双方不传输数据的情况下，一方的 TCP 连接处于 ESTABLISHED 状态，并不代表另一方的连接还一定正常。</p>\\n<h4>2. 客户端进程崩溃</h4>\\n<p>TCP 连接信息是由内核维护的，所以当服务端的进程崩溃后，内核需要回收该进程的所有 TCP 连接资源，于是内核会发送第一次挥手 FIN 报文，后续的挥手过程也都是在内核完成，并不需要进程的参与。所以即使服务端的进程退出了，还是能和客户端完成 TCP 四次挥手的过程。</p>","autoDesc":true}');export{l as comp,C as data};
